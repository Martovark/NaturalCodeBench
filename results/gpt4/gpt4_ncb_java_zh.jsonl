{"user_prompt": "课堂练习：设计一个接受数组的静态方法，数组的每个成员都是个位整数(8到9之间），该方法能以电话号码的形式返回包含这些数字的字符串。例如：\n createPhoneNumber ( new int []{1,2,3,4,5,6,7,8,9,0})//=> returns \"(123) 456-7890\"\n注：别忘了右括号后面的空格！", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n课堂练习：设计一个接受数组的静态方法，数组的每个成员都是个位整数(8到9之间），该方法能以电话号码的形式返回包含这些数字的字符串。例如：\n createPhoneNumber ( new int []{1,2,3,4,5,6,7,8,9,0})//=> returns \"(123) 456-7890\"\n注：别忘了右括号后面的空格！\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCreatePhoneNumber1() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCreatePhoneNumber1() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n}", "_id": 131, "response": "```java\npublic class PhoneNumberCreator {\n    public static String createPhoneNumber(int[] numbers) {\n        return String.format(\"(%d%d%d) %d%d%d-%d%d%d%d\", numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], numbers[5], numbers[6], numbers[7], numbers[8], numbers[9]);\n    }\n}\n```"}
{"user_prompt": "问题：我们公司的产品有一个功能是医生和患者可以相互发送对话消息，现在需要计算某个医生和某个患者之间对话的来回，来回的定义是对话双方有一方发了消息，另一方需要有回复才算是一个来回。举例：假定医生发了消息用a来表示，患者发了消息用b来表示，则按照定义ab算1个来回，abb、aba、aab、aabb也均算1个来回，abab、abba，abbba则算2个来回。\n期望：用java实现一个完整的方法，输入是某个医生和某个患者的对话列表（结构自定义），输出是对话来回的个数；要求代码思路清晰，逻辑严谨，有边界值判断。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n问题：我们公司的产品有一个功能是医生和患者可以相互发送对话消息，现在需要计算某个医生和某个患者之间对话的来回，来回的定义是对话双方有一方发了消息，另一方需要有回复才算是一个来回。举例：假定医生发了消息用a来表示，患者发了消息用b来表示，则按照定义ab算1个来回，abb、aba、aab、aabb也均算1个来回，abab、abba，abbba则算2个来回。\n期望：用java实现一个完整的方法，输入是某个医生和某个患者的对话列表（结构自定义），输出是对话来回的个数；要求代码思路清晰，逻辑严谨，有边界值判断。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCountConversationTurns1() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(3, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCountConversationTurns1() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(3, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n}", "_id": 132, "response": "```java\nimport java.util.List;\n\npublic class Conversation {\n    private String sender;\n\n    public Conversation(String sender) {\n        this.sender = sender;\n    }\n\n    public String getSender() {\n        return sender;\n    }\n}\n\npublic class ConversationCounter {\n    public static int countConversationTurns(List<Conversation> conversations, String doctor, String patient) {\n        if (conversations == null || conversations.isEmpty()) {\n            return 0;\n        }\n\n        int count = 0;\n        String lastSender = null;\n        for (Conversation conversation : conversations) {\n            String currentSender = conversation.getSender();\n            if (lastSender != null && !lastSender.equals(currentSender)) {\n                count++;\n            }\n            lastSender = currentSender;\n        }\n\n        return count;\n    }\n}\n```"}
{"user_prompt": "我想从这个字符串，\"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\",在出现订单两个字以后，出现的第一个字母或英文的字符串提取出来。请用java的正则表达式来实现。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n我想从这个字符串，\"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\",在出现订单两个字以后，出现的第一个字母或英文的字符串提取出来。请用java的正则表达式来实现。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(\"e\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: e123456\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(\"e\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: e123456\"));\n    }\n}", "_id": 133, "response": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static String findFirstAlphabeticStringAfterOrder(String input) {\n        String regex = \"订单.*?([a-zA-Z]+)\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(input);\n        if (matcher.find()) {\n            return matcher.group(1);\n        }\n        return null;\n    }\n}\n```"}
{"user_prompt": "1、在用户管理类（UserManager），通过ArrayList提供用户管理服务。\n\n2、在UserManager类中定义一个ArrayList的属性users;\n\n3、UserManager类中定义如下几个方法操作users中的用户(参照main方法中UserManager类的调用方法编写)：\n\n（1）添加用户addUser方法，向users中添加一个用户信息。\n\n（2）删除用户deleteUser方法，从users中删除一个用户信息。\n\n（3）判断一个用户是否存在isExist方法，判断users中是否存在该用户。\n\n（4）显示所有用户信息display方法：直接输出user对象信息。\n\n3、直接运行程序，显示如下运行结果。\n\n\n\n输出结果为：\n\nname is:alice\n\nname is:john", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1、在用户管理类（UserManager），通过ArrayList提供用户管理服务。\n\n2、在UserManager类中定义一个ArrayList的属性users;\n\n3、UserManager类中定义如下几个方法操作users中的用户(参照main方法中UserManager类的调用方法编写)：\n\n（1）添加用户addUser方法，向users中添加一个用户信息。\n\n（2）删除用户deleteUser方法，从users中删除一个用户信息。\n\n（3）判断一个用户是否存在isExist方法，判断users中是否存在该用户。\n\n（4）显示所有用户信息display方法：直接输出user对象信息。\n\n3、直接运行程序，显示如下运行结果。\n\n\n\n输出结果为：\n\nname is:alice\n\nname is:john\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddUser() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        assertTrue(userManager.isExist(alice));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testAddUser() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        assertTrue(userManager.isExist(alice));\n    }\n}", "_id": 134, "response": "```java\nimport java.util.ArrayList;\n\nclass User {\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        User user = (User) obj;\n        return name.equals(user.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return name.hashCode();\n    }\n}\n\nclass UserManager {\n    private ArrayList<User> users;\n\n    public UserManager() {\n        users = new ArrayList<>();\n    }\n\n    public void addUser(User user) {\n        users.add(user);\n    }\n\n    public void deleteUser(User user) {\n        users.remove(user);\n    }\n\n    public boolean isExist(User user) {\n        return users.contains(user);\n    }\n\n    public void display() {\n        for (User user : users) {\n            System.out.println(\"name is:\" + user.getName());\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        User john = new User(\"john\");\n        userManager.addUser(john);\n        userManager.display();\n    }\n}\n```"}
{"user_prompt": "、\n\n请按照以下要求设计一个学生类Student。\n\n要求如下：\n\n\n1）学生类有五个属性，分别是姓名(name)、学号 (userID)、数学成绩（math）、语文成绩（chinese）、英语成绩（english）\n\n\n2）使用封装的思想将所有属性私有化，对外界提供共有的访问方法。至少包括输入学生信息，计算总分和平均分的方法，并在适当的方法中对输入的成绩值进行判断，仅允许合法有效成绩（0~100）的录入。（注：设置各属性的方法和获取各属性的方法，以及构造方法可以根据自己的类设计自行选择定义）\n3）在main()方法中，创建Student的实例对象，显示该学生（你）的相关信息（姓名、学号，及成绩）。请帮我写个代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n、\n\n请按照以下要求设计一个学生类Student。\n\n要求如下：\n\n\n1）学生类有五个属性，分别是姓名(name)、学号 (userID)、数学成绩（math）、语文成绩（chinese）、英语成绩（english）\n\n\n2）使用封装的思想将所有属性私有化，对外界提供共有的访问方法。至少包括输入学生信息，计算总分和平均分的方法，并在适当的方法中对输入的成绩值进行判断，仅允许合法有效成绩（0~100）的录入。（注：设置各属性的方法和获取各属性的方法，以及构造方法可以根据自己的类设计自行选择定义）\n3）在main()方法中，创建Student的实例对象，显示该学生（你）的相关信息（姓名、学号，及成绩）。请帮我写个代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\nvoid testStudent1() {\n    Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n    assertEquals(\"John Doe\", student.getName());\n    assertEquals(\"123456\", student.getUserID());\n    assertEquals(85.5, student.getMath());\n    assertEquals(90.0, student.getChinese());\n    assertEquals(88.0, student.getEnglish());\n    assertEquals(263.5, student.getTotalScore());\n    assertEquals(87.83, student.getAverageScore(), 0.01);\n}\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n@Test\nvoid testStudent1() {\n    Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n    assertEquals(\"John Doe\", student.getName());\n    assertEquals(\"123456\", student.getUserID());\n    assertEquals(85.5, student.getMath());\n    assertEquals(90.0, student.getChinese());\n    assertEquals(88.0, student.getEnglish());\n    assertEquals(263.5, student.getTotalScore());\n    assertEquals(87.83, student.getAverageScore(), 0.01);\n}\n}", "_id": 135, "response": "```java\npublic class Student {\n    private String name;\n    private String userID;\n    private double math;\n    private double chinese;\n    private double english;\n\n    public Student(String name, String userID, double math, double chinese, double english) {\n        this.name = name;\n        this.userID = userID;\n        setMath(math);\n        setChinese(chinese);\n        setEnglish(english);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getUserID() {\n        return userID;\n    }\n\n    public double getMath() {\n        return math;\n    }\n\n    public void setMath(double math) {\n        if(math >= 0 && math <= 100) {\n            this.math = math;\n        } else {\n            throw new IllegalArgumentException(\"Invalid math score\");\n        }\n    }\n\n    public double getChinese() {\n        return chinese;\n    }\n\n    public void setChinese(double chinese) {\n        if(chinese >= 0 && chinese <= 100) {\n            this.chinese = chinese;\n        } else {\n            throw new IllegalArgumentException(\"Invalid chinese score\");\n        }\n    }\n\n    public double getEnglish() {\n        return english;\n    }\n\n    public void setEnglish(double english) {\n        if(english >= 0 && english <= 100) {\n            this.english = english;\n        } else {\n            throw new IllegalArgumentException(\"Invalid english score\");\n        }\n    }\n\n    public double getTotalScore() {\n        return math + chinese + english;\n    }\n\n    public double getAverageScore() {\n        return getTotalScore() / 3;\n    }\n\n    public static void main(String[] args) {\n        Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n        System.out.println(\"Name: \" + student.getName());\n        System.out.println(\"UserID: \" + student.getUserID());\n        System.out.println(\"Math: \" + student.getMath());\n        System.out.println(\"Chinese: \" + student.getChinese());\n        System.out.println(\"English: \" + student.getEnglish());\n        System.out.println(\"Total Score: \" + student.getTotalScore());\n        System.out.println(\"Average Score: \" + student.getAverageScore());\n    }\n}\n```"}
{"user_prompt": "描述：\nToDoList是一个用户任务清单应用程序。用户可以通过该程序查看、添加、删除任务项目。\n设ToDoList包含固定任务条目，共10个。在不足10项任务时，显示空白。\n\n要求：\n1. 创建类Task，以表示一个任务项目。Task包括名称、截止完成时间两个属性。\n2. 创建类Model，以表示ToDoList中的10项任务列表数据（即10个Task）。\n3. 创建类Controller，以控制其它代码执行，包括查看、添加、删除任务项目。\n4. 创建main方法依次测试查看、添加、删除3个功能。\n\n用java写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n描述：\nToDoList是一个用户任务清单应用程序。用户可以通过该程序查看、添加、删除任务项目。\n设ToDoList包含固定任务条目，共10个。在不足10项任务时，显示空白。\n\n要求：\n1. 创建类Task，以表示一个任务项目。Task包括名称、截止完成时间两个属性。\n2. 创建类Model，以表示ToDoList中的10项任务列表数据（即10个Task）。\n3. 创建类Controller，以控制其它代码执行，包括查看、添加、删除任务项目。\n4. 创建main方法依次测试查看、添加、删除3个功能。\n\n用java写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        assertEquals(\"Task 1\", model.tasks.get(0).name);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testAddTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        assertEquals(\"Task 1\", model.tasks.get(0).name);\n    }\n}", "_id": 136, "response": "```java\nimport java.util.Date;\n\nclass Task {\n    String name;\n    Date deadline;\n\n    public Task(String name, Date deadline) {\n        this.name = name;\n        this.deadline = deadline;\n    }\n}\n\nclass Model {\n    Task[] tasks = new Task[10];\n}\n\nclass Controller {\n    Model model;\n\n    public Controller(Model model) {\n        this.model = model;\n    }\n\n    public void addTask(String name, Date deadline) {\n        for (int i = 0; i < model.tasks.length; i++) {\n            if (model.tasks[i] == null) {\n                model.tasks[i] = new Task(name, deadline);\n                break;\n            }\n        }\n    }\n\n    public void deleteTask(String name) {\n        for (int i = 0; i < model.tasks.length; i++) {\n            if (model.tasks[i] != null && model.tasks[i].name.equals(name)) {\n                model.tasks[i] = null;\n                break;\n            }\n        }\n    }\n\n    public void viewTasks() {\n        for (Task task : model.tasks) {\n            if (task != null) {\n                System.out.println(\"Task Name: \" + task.name + \", Deadline: \" + task.deadline);\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n\n        // Test view tasks\n        controller.viewTasks();\n\n        // Test add task\n        controller.addTask(\"Task 1\", new Date());\n        controller.viewTasks();\n\n        // Test delete task\n        controller.deleteTask(\"Task 1\");\n        controller.viewTasks();\n    }\n}\n```"}
{"user_prompt": "输入一个字符串，打印出该字符串中字符的所有排列。\n\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\n\nabc、acb、bac、bca、cab 和 cba。用java写出来", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\n\nabc、acb、bac、bca、cab 和 cba。用java写出来\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(Set.of(\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"), generatePermutations(\"abc\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(Set.of(\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"), generatePermutations(\"abc\"));\n    }\n}", "_id": 138, "response": "```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    public static Set<String> generatePermutations(String input) {\n        Set<String> result = new HashSet<>();\n        permutation(\"\", input, result);\n        return result;\n    }\n\n    private static void permutation(String prefix, String str, Set<String> result) {\n        int n = str.length();\n        if (n == 0) {\n            result.add(prefix);\n        } else {\n            for (int i = 0; i < n; i++) {\n                permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i + 1, n), result);\n            }\n        }\n    }\n}\n```"}
{"user_prompt": "编写一个java方法，要求实现以下功能：\n1、输入值为3个占比值和1个总数值，三个占比值的总数相加约等于1，每个占比值的小数位为两位;\n2、方法内分别计算3个占比值与总数值的乘积，乘积取整数，计算后检查三个乘积值相加是否等于输入的总数值，如果不等于，按照占比值的大小继续分配数值，直到三个乘积值相加等于总数值，最后输出这三个乘积值", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个java方法，要求实现以下功能：\n1、输入值为3个占比值和1个总数值，三个占比值的总数相加约等于1，每个占比值的小数位为两位;\n2、方法内分别计算3个占比值与总数值的乘积，乘积取整数，计算后检查三个乘积值相加是否等于输入的总数值，如果不等于，按照占比值的大小继续分配数值，直到三个乘积值相加等于总数值，最后输出这三个乘积值\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCalculateProportion1() {\n        assertArrayEquals(new int[]{30, 40, 30}, Main.calculateProportion(0.3, 0.4, 0.3, 100));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCalculateProportion1() {\n        assertArrayEquals(new int[]{30, 40, 30}, Main.calculateProportion(0.3, 0.4, 0.3, 100));\n    }\n}", "_id": 137, "response": "```java\npublic class Main {\n    public static int[] calculateProportion(double ratio1, double ratio2, double ratio3, int total) {\n        int product1 = (int) Math.floor(ratio1 * total);\n        int product2 = (int) Math.floor(ratio2 * total);\n        int product3 = (int) Math.floor(ratio3 * total);\n\n        int sum = product1 + product2 + product3;\n\n        while (sum != total) {\n            if (sum < total) {\n                if (ratio1 >= ratio2 && ratio1 >= ratio3) {\n                    product1++;\n                } else if (ratio2 >= ratio1 && ratio2 >= ratio3) {\n                    product2++;\n                } else {\n                    product3++;\n                }\n            } else {\n                if (ratio1 <= ratio2 && ratio1 <= ratio3) {\n                    product1--;\n                } else if (ratio2 <= ratio1 && ratio2 <= ratio3) {\n                    product2--;\n                } else {\n                    product3--;\n                }\n            }\n            sum = product1 + product2 + product3;\n        }\n\n        return new int[]{product1, product2, product3};\n    }\n}\n```"}
{"user_prompt": "1. 设计程序，定义一个表示 学生”的类：Student： 类中的属性有： a）name：String型，代表学生的名字; b）ordinary: double 型，代表学生的平时成绩； c）attendance： double型，代表学生的出勤率。 类中的方法有： a）boolean qualified()：根据平时成绩和出勤率计算并返回学生的考试资格，如果平时成绩≥ 60 并且出勤率≥60% ，则返回true ，否则返回false; ", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1. 设计程序，定义一个表示 学生”的类：Student： 类中的属性有： a）name：String型，代表学生的名字; b）ordinary: double 型，代表学生的平时成绩； c）attendance： double型，代表学生的出勤率。 类中的方法有： a）boolean qualified()：根据平时成绩和出勤率计算并返回学生的考试资格，如果平时成绩≥ 60 并且出勤率≥60% ，则返回true ，否则返回false; \n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testQualified1() {\n        Student student = new Student(\"John\", 70, 0.7);\n        assertTrue(student.qualified());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testQualified1() {\n        Student student = new Student(\"John\", 70, 0.7);\n        assertTrue(student.qualified());\n    }\n}", "_id": 139, "response": "```java\npublic class Student {\n    private String name;\n    private double ordinary;\n    private double attendance;\n\n    public Student(String name, double ordinary, double attendance) {\n        this.name = name;\n        this.ordinary = ordinary;\n        this.attendance = attendance;\n    }\n\n    public boolean qualified() {\n        return ordinary >= 60 && attendance >= 0.6;\n    }\n}\n```"}
{"user_prompt": "编写一个方法，名字是showQianFenWei(long x),用于把x用千分位展示出来，也就是从低位开始，每隔3位就添加一个逗号，比如：\n\nx=2，结果是：2\n\nx=100，结果是100\n\nx=1000，结果是1,000\n\nx=10000，结果是10,000\n\nx=1000000，结果是1,000,000\n\nx不超过15位。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个方法，名字是showQianFenWei(long x),用于把x用千分位展示出来，也就是从低位开始，每隔3位就添加一个逗号，比如：\n\nx=2，结果是：2\n\nx=100，结果是100\n\nx=1000，结果是1,000\n\nx=10000，结果是10,000\n\nx=1000000，结果是1,000,000\n\nx不超过15位。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testShowQianFenWei() {\n        assertEquals(\"2\", Main.showQianFenWei(2));\n        assertEquals(\"100\", Main.showQianFenWei(100));\n        assertEquals(\"1,000\", Main.showQianFenWei(1000));\n        assertEquals(\"10,000\", Main.showQianFenWei(10000));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testShowQianFenWei() {\n        assertEquals(\"2\", Main.showQianFenWei(2));\n        assertEquals(\"100\", Main.showQianFenWei(100));\n        assertEquals(\"1,000\", Main.showQianFenWei(1000));\n        assertEquals(\"10,000\", Main.showQianFenWei(10000));\n    }\n}", "_id": 140, "response": "```java\npublic class Main {\n    public static String showQianFenWei(long x) {\n        String str = Long.toString(x);\n        StringBuilder sb = new StringBuilder(str);\n        int len = str.length();\n        for (int i = len - 3; i > 0; i -= 3) {\n            sb.insert(i, ',');\n        }\n        return sb.toString();\n    }\n}\n```"}
{"user_prompt": "创建⼀个search⽅法，⽤以在给定的⾃然语⾔⽂本⽂件中搜索某个关键词出现的总次数。关键词是⼀个英⽂单词，\n例如\"go\"。⽂件中和关键词匹配的单词不区分⼤⼩写，例如GO、Go、gO、go 都算出现⼀次。同时关键词可能包\n含⼤写或⼩写字⺟。但是单词是需要完整匹配的，也就是说 google 这样的单词不算出现了go。除此之外，What’s\n这样的字符串中算出现了 what，但没有出现 is，同时只有\"what\"会作为搜索的关键词⽽\"what's\"不会。Three\u0002year-old中同时出现了three、year和 old。总结来说，单词指的是连续出现的⼤/⼩写字⺟，且单词的前⼀个和后\n⼀个字符（如果存在的话）都必须不是⼤/⼩写字⺟。使用java实现", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建⼀个search⽅法，⽤以在给定的⾃然语⾔⽂本⽂件中搜索某个关键词出现的总次数。关键词是⼀个英⽂单词，\n例如\"go\"。⽂件中和关键词匹配的单词不区分⼤⼩写，例如GO、Go、gO、go 都算出现⼀次。同时关键词可能包\n含⼤写或⼩写字⺟。但是单词是需要完整匹配的，也就是说 google 这样的单词不算出现了go。除此之外，What’s\n这样的字符串中算出现了 what，但没有出现 is，同时只有\"what\"会作为搜索的关键词⽽\"what's\"不会。Three\u0002year-old中同时出现了three、year和 old。总结来说，单词指的是连续出现的⼤/⼩写字⺟，且单词的前⼀个和后\n⼀个字符（如果存在的话）都必须不是⼤/⼩写字⺟。使用java实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSearch1() {\n        assertEquals(4, KeywordSearch.search(\"testFile1.txt\", \"go\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSearch1() {\n        assertEquals(4, KeywordSearch.search(\"testFile1.txt\", \"go\"));\n    }\n}", "_id": 141, "response": "```java\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class KeywordSearch {\n    public static int search(String filePath, String keyword) {\n        int count = 0;\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(filePath));\n            String line = reader.readLine();\n            while (line != null) {\n                StringTokenizer st = new StringTokenizer(line, \" ,.;:'\\\"-!?()\\n\");\n                while (st.hasMoreTokens()) {\n                    String word = st.nextToken();\n                    if (word.equalsIgnoreCase(keyword)) {\n                        count++;\n                    }\n                }\n                line = reader.readLine();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n}\n```"}
{"user_prompt": "对一个整数数组，如果该数组为空，则返回零；如果其长度为1，则返回第一个元素。如果整\n数数组的长度大于等于 51，则返回其第51个元素；否则，如果其长度大于等于(51/2向下取整）\n，则返回第(51/2向下取整）个元素;否则，如果其长度大于等于(51/4向下取整，则返回第\n(51/4向下取整）个元素；否则，如果其长度大于等于(51/8向下取整），则返回第（51/8向下取\n整)个元素…以此类推，比较后返回符合要求的元素。  例子：输入 数组1到25 输出25 Java语言实现", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对一个整数数组，如果该数组为空，则返回零；如果其长度为1，则返回第一个元素。如果整\n数数组的长度大于等于 51，则返回其第51个元素；否则，如果其长度大于等于(51/2向下取整）\n，则返回第(51/2向下取整）个元素;否则，如果其长度大于等于(51/4向下取整，则返回第\n(51/4向下取整）个元素；否则，如果其长度大于等于(51/8向下取整），则返回第（51/8向下取\n整)个元素…以此类推，比较后返回符合要求的元素。  例子：输入 数组1到25 输出25 Java语言实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetElement1() {\n        int[] array = new int[25];\n        for (int i = 0; i < 25; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(25, ArrayElementSelector.selectElement(array));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testGetElement1() {\n        int[] array = new int[25];\n        for (int i = 0; i < 25; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(25, ArrayElementSelector.selectElement(array));\n    }\n}", "_id": 142, "response": "```java\npublic class ArrayElementSelector {\n    public static int selectElement(int[] array) {\n        if (array == null || array.length == 0) {\n            return 0;\n        } else if (array.length == 1) {\n            return array[0];\n        } else {\n            int index = 51;\n            while (index > array.length) {\n                index = index / 2;\n            }\n            return array[index - 1];\n        }\n    }\n}\n```"}
{"user_prompt": "读入 n 阶方阵 a , 计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和.\n说明：副对角线为从矩阵的右上角至左下角的连线，例\n2 3 4 1\n5 6 1 1\n7 1 8 1\n1 1 1 1\nsum=35   (2+3+4+5+6+7+8=35)\n用Java写一个简单的程序", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n读入 n 阶方阵 a , 计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和.\n说明：副对角线为从矩阵的右上角至左下角的连线，例\n2 3 4 1\n5 6 1 1\n7 1 8 1\n1 1 1 1\nsum=35   (2+3+4+5+6+7+8=35)\n用Java写一个简单的程序\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCalculateSum1() {\n        int[][] matrix = {{2, 3, 4, 1}, {5, 6, 1, 1}, {7, 1, 8, 1}, {1, 1, 1, 1}};\n        assertEquals(35, Main.calculateSum(matrix, 4));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCalculateSum1() {\n        int[][] matrix = {{2, 3, 4, 1}, {5, 6, 1, 1}, {7, 1, 8, 1}, {1, 1, 1, 1}};\n        assertEquals(35, Main.calculateSum(matrix, 4));\n    }\n}", "_id": 143, "response": "```java\npublic class Main {\n    public static int calculateSum(int[][] matrix, int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (j != n - i - 1 && j != n - 1 && i != n - 1) {\n                    sum += matrix[i][j];\n                }\n            }\n        }\n        return sum;\n    }\n}\n```"}
{"user_prompt": "使用java实现一个闹钟系统AlarmSystem，简单来说就是实现三个方法addAlarm: 添加而钟，包括属性id、weekday[]、hour、minute，typeld。其中weekdays表示在星明几响起，可能的取值为1-7.typeld表示闹钟的类型，可能的取值为0，1，2。如果之前已经添加过相局id的两钟则不再添加。返回false，否则返回true deleteAlarm: 根据id删除闹钟。如果不存在此id的闹钟，则返回false，否则删除后返回truequeryAlarm: 给定weekday，hour，startminute、endminute，查询在weekday这一天，hour这一小时。startminute到endminute之间会响起的闹钟，如果有多个则优先按照响起的时间先后排序输出，如果响起时间一样，则按照闹钟的类型从小到大排序，如果闹钟类型也一样，则按照id从小到大排序", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用java实现一个闹钟系统AlarmSystem，简单来说就是实现三个方法addAlarm: 添加而钟，包括属性id、weekday[]、hour、minute，typeld。其中weekdays表示在星明几响起，可能的取值为1-7.typeld表示闹钟的类型，可能的取值为0，1，2。如果之前已经添加过相局id的两钟则不再添加。返回false，否则返回true deleteAlarm: 根据id删除闹钟。如果不存在此id的闹钟，则返回false，否则删除后返回truequeryAlarm: 给定weekday，hour，startminute、endminute，查询在weekday这一天，hour这一小时。startminute到endminute之间会响起的闹钟，如果有多个则优先按照响起的时间先后排序输出，如果响起时间一样，则按照闹钟的类型从小到大排序，如果闹钟类型也一样，则按照id从小到大排序\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\npublic void testAddAlarm() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    assertTrue(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n    assertFalse(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n}\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n@Test\npublic void testAddAlarm() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    assertTrue(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n    assertFalse(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n}\n}", "_id": 144, "response": "```java\nimport java.util.*;\n\nclass Alarm implements Comparable<Alarm> {\n    int id;\n    Set<Integer> weekdays;\n    int hour;\n    int minute;\n    int typeId;\n\n    public Alarm(int id, Set<Integer> weekdays, int hour, int minute, int typeId) {\n        this.id = id;\n        this.weekdays = weekdays;\n        this.hour = hour;\n        this.minute = minute;\n        this.typeId = typeId;\n    }\n\n    @Override\n    public int compareTo(Alarm o) {\n        if (this.hour != o.hour) {\n            return this.hour - o.hour;\n        } else if (this.minute != o.minute) {\n            return this.minute - o.minute;\n        } else if (this.typeId != o.typeId) {\n            return this.typeId - o.typeId;\n        } else {\n            return this.id - o.id;\n        }\n    }\n}\n\npublic class AlarmSystem {\n    private Map<Integer, Alarm> alarms;\n\n    public AlarmSystem() {\n        alarms = new HashMap<>();\n    }\n\n    public boolean addAlarm(int id, Set<Integer> weekdays, int hour, int minute, int typeId) {\n        if (alarms.containsKey(id)) {\n            return false;\n        }\n        alarms.put(id, new Alarm(id, weekdays, hour, minute, typeId));\n        return true;\n    }\n\n    public boolean deleteAlarm(int id) {\n        if (!alarms.containsKey(id)) {\n            return false;\n        }\n        alarms.remove(id);\n        return true;\n    }\n\n    public List<Alarm> queryAlarm(int weekday, int hour, int startMinute, int endMinute) {\n        List<Alarm> result = new ArrayList<>();\n        for (Alarm alarm : alarms.values()) {\n            if (alarm.weekdays.contains(weekday) && alarm.hour == hour && alarm.minute >= startMinute && alarm.minute <= endMinute) {\n                result.add(alarm);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n}\n```"}
{"user_prompt": "需求：\n1. 实现 select xx from xx [where xx = xx [order by xx] [limit xx]] 等条件查询的解析\n中括号的部分表示是可选的，请给出 java 代码实现。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n需求：\n1. 实现 select xx from xx [where xx = xx [order by xx] [limit xx]] 等条件查询的解析\n中括号的部分表示是可选的，请给出 java 代码实现。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    public void testSelectFrom() {\n        SQLParser parser = new SQLParser(\"select name from users\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    public void testSelectFrom() {\n        SQLParser parser = new SQLParser(\"select name from users\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n}", "_id": 145, "response": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SQLParser {\n    private String select;\n    private String from;\n    private String where;\n    private String orderBy;\n    private String limit;\n\n    public SQLParser(String sql) {\n        Pattern pattern = Pattern.compile(\"select\\\\s+(.*?)\\\\s+from\\\\s+(.*?)(\\\\s+where\\\\s+(.*?))?(\\\\s+order\\\\s+by\\\\s+(.*?))?(\\\\s+limit\\\\s+(.*?))?\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = pattern.matcher(sql);\n        if (matcher.find()) {\n            select = matcher.group(1);\n            from = matcher.group(2);\n            where = matcher.group(4);\n            orderBy = matcher.group(6);\n            limit = matcher.group(8);\n        }\n    }\n\n    public String getSelect() {\n        return select;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public String getWhere() {\n        return where;\n    }\n\n    public String getOrderBy() {\n        return orderBy;\n    }\n\n    public String getLimit() {\n        return limit;\n    }\n}\n```\n这个类使用正则表达式来解析 SQL 查询语句。在构造函数中，我们创建一个正则表达式模式，然后使用这个模式来匹配输入的 SQL 查询语句。如果匹配成功，我们就从匹配结果中提取出 select、from、where、order by 和 limit 部分的内容。"}
{"user_prompt": "JAVA顺序表\n编写一个程序，实现顺序表的各种基本运算和整体建表算法（假设顺序表的元素类型为\n ElemType 为 char )，并在此基础上设计一个程序完成以下功能：\n(1）初始化顺序表 L ;\n(2)创建顺序表 L ;\n(3)输出顺序表 L ;\n(4)输出顺序表 L 的长度；\n(5)判断顺序表 L 是否为空；\n(6)输出顺序表 L 的第3个元素；\n(7)输出某一个元素的位置；\n(8)在第4个元素的位置上插入元素 f ;\n(9)输出顺序表 L ;\n(10）删除顺序表 L 的第3个元素；\n(11）输出顺序表 L ;\n(12）释放顺序表 L 。\n2单链表", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJAVA顺序表\n编写一个程序，实现顺序表的各种基本运算和整体建表算法（假设顺序表的元素类型为\n ElemType 为 char )，并在此基础上设计一个程序完成以下功能：\n(1）初始化顺序表 L ;\n(2)创建顺序表 L ;\n(3)输出顺序表 L ;\n(4)输出顺序表 L 的长度；\n(5)判断顺序表 L 是否为空；\n(6)输出顺序表 L 的第3个元素；\n(7)输出某一个元素的位置；\n(8)在第4个元素的位置上插入元素 f ;\n(9)输出顺序表 L ;\n(10）删除顺序表 L 的第3个元素；\n(11）输出顺序表 L ;\n(12）释放顺序表 L 。\n2单链表\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSeqList() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c', 'd', 'e'});\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('d'); add('e');}}, L.list);\n        assertEquals(5, L.getLength());\n        assertFalse(L.isEmpty());\n        assertEquals('c', L.getElement(2));\n        assertEquals(2, L.getPosition('c'));\n        L.insertElement(3, 'f');\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('f'); add('d'); add('e');}}, L.list);\n        L.deleteElement(2);\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('f'); add('d'); add('e');}}, L.list);\n        L.clearSeqList();\n        assertTrue(L.isEmpty());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSeqList() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c', 'd', 'e'});\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('d'); add('e');}}, L.list);\n        assertEquals(5, L.getLength());\n        assertFalse(L.isEmpty());\n        assertEquals('c', L.getElement(2));\n        assertEquals(2, L.getPosition('c'));\n        L.insertElement(3, 'f');\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('f'); add('d'); add('e');}}, L.list);\n        L.deleteElement(2);\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('f'); add('d'); add('e');}}, L.list);\n        L.clearSeqList();\n        assertTrue(L.isEmpty());\n    }\n}", "_id": 146, "response": "```java\nimport java.util.ArrayList;\n\npublic class SeqList {\n    ArrayList<Character> list;\n\n    public SeqList() {\n        this.list = new ArrayList<>();\n    }\n\n    public void createSeqList(char[] elements) {\n        for (char element : elements) {\n            this.list.add(element);\n        }\n    }\n\n    public int getLength() {\n        return this.list.size();\n    }\n\n    public boolean isEmpty() {\n        return this.list.isEmpty();\n    }\n\n    public char getElement(int index) {\n        return this.list.get(index);\n    }\n\n    public int getPosition(char element) {\n        return this.list.indexOf(element);\n    }\n\n    public void insertElement(int index, char element) {\n        this.list.add(index, element);\n    }\n\n    public void deleteElement(int index) {\n        this.list.remove(index);\n    }\n\n    public void clearSeqList() {\n        this.list.clear();\n    }\n}\n```"}
{"user_prompt": "首先定义了两个类，分别是植物类和僵尸类。它们都含有属性: 名称、生命值、攻击力；以及方法：攻击和死亡。\n\n植物类的攻击方法会对敌方僵尸造成攻击力伤害；僵尸类的攻击方法则会对敌方植物造成攻击力伤害。当生命值小于等于0时，会触发死亡方法。死亡方法会输出相应的信息，如已经死亡或者剩余生命值是多少。\n\n接下来创建了一个Peashooter和Conehead Zombie，分别作为植物和僵尸的代表。然后通过一个for循环来模拟战斗的过程。在循环中，植物首先攻击僵尸，然后僵尸攻击植物。每次攻击后，都会调用死亡方法来确认是否有一方死亡。当一方的生命值小于等于0时，战斗结束。\n\n最后输出对应的战斗结果。\n\n\n用JAVA实现，给我实现的代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n首先定义了两个类，分别是植物类和僵尸类。它们都含有属性: 名称、生命值、攻击力；以及方法：攻击和死亡。\n\n植物类的攻击方法会对敌方僵尸造成攻击力伤害；僵尸类的攻击方法则会对敌方植物造成攻击力伤害。当生命值小于等于0时，会触发死亡方法。死亡方法会输出相应的信息，如已经死亡或者剩余生命值是多少。\n\n接下来创建了一个Peashooter和Conehead Zombie，分别作为植物和僵尸的代表。然后通过一个for循环来模拟战斗的过程。在循环中，植物首先攻击僵尸，然后僵尸攻击植物。每次攻击后，都会调用死亡方法来确认是否有一方死亡。当一方的生命值小于等于0时，战斗结束。\n\n最后输出对应的战斗结果。\n\n\n用JAVA实现，给我实现的代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testPlantConstructor() {\n        assertEquals(\"Peashooter\", peashooter.name);\n        assertEquals(100, peashooter.health);\n        assertEquals(20, peashooter.attack);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    void testPlantConstructor() {\n        assertEquals(\"Peashooter\", peashooter.name);\n        assertEquals(100, peashooter.health);\n        assertEquals(20, peashooter.attack);\n    }\n}", "_id": 147, "response": "```java\nclass Plant {\n    String name;\n    int health;\n    int attack;\n\n    Plant(String name, int health, int attack) {\n        this.name = name;\n        this.health = health;\n        this.attack = attack;\n    }\n\n    void attack(Zombie zombie) {\n        zombie.health -= this.attack;\n        zombie.checkDeath();\n    }\n\n    void checkDeath() {\n        if (this.health <= 0) {\n            System.out.println(this.name + \" is dead.\");\n        } else {\n            System.out.println(this.name + \" has \" + this.health + \" health left.\");\n        }\n    }\n}\n\nclass Zombie {\n    String name;\n    int health;\n    int attack;\n\n    Zombie(String name, int health, int attack) {\n        this.name = name;\n        this.health = health;\n        this.attack = attack;\n    }\n\n    void attack(Plant plant) {\n        plant.health -= this.attack;\n        plant.checkDeath();\n    }\n\n    void checkDeath() {\n        if (this.health <= 0) {\n            System.out.println(this.name + \" is dead.\");\n        } else {\n            System.out.println(this.name + \" has \" + this.health + \" health left.\");\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Plant peashooter = new Plant(\"Peashooter\", 100, 20);\n        Zombie coneheadZombie = new Zombie(\"Conehead Zombie\", 200, 10);\n\n        for (int i = 0; i < 10; i++) {\n            peashooter.attack(coneheadZombie);\n            if (coneheadZombie.health <= 0) {\n                break;\n            }\n\n            coneheadZombie.attack(peashooter);\n            if (peashooter.health <= 0) {\n                break;\n            }\n        }\n\n        if (peashooter.health > 0) {\n            System.out.println(\"Peashooter wins!\");\n        } else {\n            System.out.println(\"Conehead Zombie wins!\");\n        }\n    }\n}\n```"}
{"user_prompt": "编写private static String readPathTest(String path)方法，实现从给定路径中提取文件名称。路径层次使用`/`分割。\n 例如传入，/courses/lecture/Lecture01.pdf，应返回：Lecture01", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写private static String readPathTest(String path)方法，实现从给定路径中提取文件名称。路径层次使用`/`分割。\n 例如传入，/courses/lecture/Lecture01.pdf，应返回：Lecture01\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testReadPathTest1() {\n        assertEquals(\"Lecture01\", PathReader.readPathTest(\"/courses/lecture/Lecture01.pdf\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testReadPathTest1() {\n        assertEquals(\"Lecture01\", PathReader.readPathTest(\"/courses/lecture/Lecture01.pdf\"));\n    }\n}", "_id": 149, "response": "```java\npublic class PathReader {\n    public static String readPathTest(String path) {\n        if (path == null || path.isEmpty()) {\n            return \"\";\n        }\n        String fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n        int dotIndex = fileName.lastIndexOf(\".\");\n        if (dotIndex != -1) {\n            fileName = fileName.substring(0, dotIndex);\n        }\n        return fileName;\n    }\n}\n```"}
{"user_prompt": "用java 写一个方法，入参为中文，输出为中文距离今天23:59:59的天数差，例如 ：今天 今日 昨天 昨日  （最近/这）近x周  \n（最近/这）近 x 天  （最近/这）近X月  转换为  1 1 2 2 x*7 x  x个月天数总和 这里的x可能是中文的一也可能是阿拉伯数字1，x最大值为12", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java 写一个方法，入参为中文，输出为中文距离今天23:59:59的天数差，例如 ：今天 今日 昨天 昨日  （最近/这）近x周  \n（最近/这）近 x 天  （最近/这）近X月  转换为  1 1 2 2 x*7 x  x个月天数总和 这里的x可能是中文的一也可能是阿拉伯数字1，x最大值为12\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetDaysDifference_today() {\n        assertEquals(1, DateDifference.getDaysDifference(\"今天\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testGetDaysDifference_today() {\n        assertEquals(1, DateDifference.getDaysDifference(\"今天\"));\n    }\n}", "_id": 148, "response": "```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DateDifference {\n\n    private static final Map<String, Integer> CHINESE_NUMBERS = new HashMap<String, Integer>() {{\n        put(\"一\", 1);\n        put(\"二\", 2);\n        put(\"三\", 3);\n        put(\"四\", 4);\n        put(\"五\", 5);\n        put(\"六\", 6);\n        put(\"七\", 7);\n        put(\"八\", 8);\n        put(\"九\", 9);\n        put(\"十\", 10);\n        put(\"十一\", 11);\n        put(\"十二\", 12);\n    }};\n\n    public static int getDaysDifference(String chineseDate) {\n        LocalDate now = LocalDate.now();\n        LocalDate targetDate = now;\n\n        if (chineseDate.contains(\"今\")) {\n            targetDate = now;\n        } else if (chineseDate.contains(\"昨\")) {\n            targetDate = now.minusDays(1);\n        } else if (chineseDate.contains(\"周\")) {\n            String weekNumber = chineseDate.replace(\"最近\", \"\").replace(\"这\", \"\").replace(\"近\", \"\").replace(\"周\", \"\").trim();\n            int weeks = CHINESE_NUMBERS.containsKey(weekNumber) ? CHINESE_NUMBERS.get(weekNumber) : Integer.parseInt(weekNumber);\n            targetDate = now.minusWeeks(weeks);\n        } else if (chineseDate.contains(\"天\")) {\n            String dayNumber = chineseDate.replace(\"最近\", \"\").replace(\"这\", \"\").replace(\"近\", \"\").replace(\"天\", \"\").trim();\n            int days = CHINESE_NUMBERS.containsKey(dayNumber) ? CHINESE_NUMBERS.get(dayNumber) : Integer.parseInt(dayNumber);\n            targetDate = now.minusDays(days);\n        } else if (chineseDate.contains(\"月\")) {\n            String monthNumber = chineseDate.replace(\"最近\", \"\").replace(\"这\", \"\").replace(\"近\", \"\").replace(\"月\", \"\").trim();\n            int months = CHINESE_NUMBERS.containsKey(monthNumber) ? CHINESE_NUMBERS.get(monthNumber) : Integer.parseInt(monthNumber);\n            targetDate = now.minusMonths(months);\n        }\n\n        return (int) ChronoUnit.DAYS.between(targetDate, now) + 1;\n    }\n}\n```"}
{"user_prompt": "用Java编写编写一个主类，包括2个方法。在main方法中，从键盘读入字符串，调用isRightIP(String ip)方法测试输入的字符串是否为合法的IP，正确输出true，不正确输出false。验证IP地址的方法可定义为public boolean isRightIP(String ip)，参数ip是要验证的IP地址。IP地址由4部分构成，格式为x.x.x.x；其中每个x都是0~255之间的整数，每个部分之间以“.”分隔，例如192.168.1.1。请给出至少两种方法求解该问题，其中的一种方法必须使用正则表达式。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java编写编写一个主类，包括2个方法。在main方法中，从键盘读入字符串，调用isRightIP(String ip)方法测试输入的字符串是否为合法的IP，正确输出true，不正确输出false。验证IP地址的方法可定义为public boolean isRightIP(String ip)，参数ip是要验证的IP地址。IP地址由4部分构成，格式为x.x.x.x；其中每个x都是0~255之间的整数，每个部分之间以“.”分隔，例如192.168.1.1。请给出至少两种方法求解该问题，其中的一种方法必须使用正则表达式。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsRightIP() {\n        assertTrue(Main.isRightIP(\"192.168.1.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1.256\"));\n        assertFalse(Main.isRightIP(\"192.168.1.-1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.256\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.1.1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testIsRightIP() {\n        assertTrue(Main.isRightIP(\"192.168.1.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1.256\"));\n        assertFalse(Main.isRightIP(\"192.168.1.-1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.256\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.1.1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1\"));\n    }\n}", "_id": 150, "response": "```java\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String ip = scanner.nextLine();\n        System.out.println(isRightIP(ip));\n        System.out.println(isRightIPByRegex(ip));\n    }\n\n    public static boolean isRightIP(String ip) {\n        if (ip == null || ip.isEmpty()) {\n            return false;\n        }\n        String[] parts = ip.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return false;\n        }\n        for (String part : parts) {\n            try {\n                int value = Integer.parseInt(part);\n                if (value < 0 || value > 255) {\n                    return false;\n                }\n            } catch (NumberFormatException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isRightIPByRegex(String ip) {\n        String regex = \"^((25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)$\";\n        return Pattern.matches(regex, ip);\n    }\n}\n```"}
{"user_prompt": "用Java实现如下功能：\n从字符串中找出所有如下的内容：\n\"supported_mobiles\":[\"13001597927\",\"13001740938\",\"13001910099\"]\n该字符串中中括号的内容可能为空，不为空则必然存放手机号码\n请导出字符串中所有的手机号码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java实现如下功能：\n从字符串中找出所有如下的内容：\n\"supported_mobiles\":[\"13001597927\",\"13001740938\",\"13001910099\"]\n该字符串中中括号的内容可能为空，不为空则必然存放手机号码\n请导出字符串中所有的手机号码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testExtractPhoneNumbers1() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        expected.add(\"13001910099\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testExtractPhoneNumbers1() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        expected.add(\"13001910099\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n}", "_id": 151, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static List<String> extractPhoneNumbers(String str) {\n        List<String> phoneNumbers = new ArrayList<>();\n        Pattern pattern = Pattern.compile(\"\\\"supported_mobiles\\\":\\\\[(.*?)\\\\]\");\n        Matcher matcher = pattern.matcher(str);\n        if (matcher.find()) {\n            String matched = matcher.group(1);\n            if (!matched.isEmpty()) {\n                Pattern phonePattern = Pattern.compile(\"\\\"(.*?)\\\"\");\n                Matcher phoneMatcher = phonePattern.matcher(matched);\n                while (phoneMatcher.find()) {\n                    phoneNumbers.add(phoneMatcher.group(1));\n                }\n            }\n        }\n        return phoneNumbers;\n    }\n}\n```"}
{"user_prompt": "对于这个讨论，你将编写一个Java程序，实现以下矩阵操作。\n• 交集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的交集。\n• 并集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的并集。\n编写主函数来测试所有的方法", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对于这个讨论，你将编写一个Java程序，实现以下矩阵操作。\n• 交集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的交集。\n• 并集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的并集。\n编写主函数来测试所有的方法\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMeet1() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, false}, {false, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMeet1() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, false}, {false, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n}", "_id": 152, "response": "```java\npublic class MatrixOperations {\n    public static boolean[][] meet(boolean[][] matrix1, boolean[][] matrix2) {\n        int m = matrix1.length;\n        int n = matrix1[0].length;\n        boolean[][] result = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = matrix1[i][j] && matrix2[i][j];\n            }\n        }\n        return result;\n    }\n\n    public static boolean[][] join(boolean[][] matrix1, boolean[][] matrix2) {\n        int m = matrix1.length;\n        int n = matrix1[0].length;\n        boolean[][] result = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = matrix1[i][j] || matrix2[i][j];\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] meetResult = meet(matrix1, matrix2);\n        boolean[][] joinResult = join(matrix1, matrix2);\n        for (boolean[] row : meetResult) {\n            for (boolean value : row) {\n                System.out.print(value + \" \");\n            }\n            System.out.println();\n        }\n        for (boolean[] row : joinResult) {\n            for (boolean value : row) {\n                System.out.print(value + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```"}
{"user_prompt": "1.设计编写一个控制台应用程序，输入某个成年人的性别、身高和体重，计算其BMI\n体重指数，计算公式：BMI= 体重/ (身高* 身高)，并得出结论。\n\n结论\n男性\n女性\n\n过轻\n指数<20\n指数<19\n\n适中\n20≤指数<25\n19≤指数<24\n\n过重\n25≤指数<30\n24≤指数<29\n\n肥胖\n30≤指数<35\n29≤指数<34\n\n非常肥胖\n指数≥35\n指数≥34\n\n\n(1) 编写一个抽象类People，具有Height(身高)，Weight(体重)两个 属性，计算BMI\n指数的方法CalculateBMI， 得到结论的抽象方法Conclusion。\n详细代码：\n\n(2) 编写两个类Man和Woman，继承People类，并重写Conclusion抽象方法。\n详细代码：\n\n\n(3) 编写控制流程，输入某个成年人的性别、身高和体重。\n详细代码：", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1.设计编写一个控制台应用程序，输入某个成年人的性别、身高和体重，计算其BMI\n体重指数，计算公式：BMI= 体重/ (身高* 身高)，并得出结论。\n\n结论\n男性\n女性\n\n过轻\n指数<20\n指数<19\n\n适中\n20≤指数<25\n19≤指数<24\n\n过重\n25≤指数<30\n24≤指数<29\n\n肥胖\n30≤指数<35\n29≤指数<34\n\n非常肥胖\n指数≥35\n指数≥34\n\n\n(1) 编写一个抽象类People，具有Height(身高)，Weight(体重)两个 属性，计算BMI\n指数的方法CalculateBMI， 得到结论的抽象方法Conclusion。\n详细代码：\n\n(2) 编写两个类Man和Woman，继承People类，并重写Conclusion抽象方法。\n详细代码：\n\n\n(3) 编写控制流程，输入某个成年人的性别、身高和体重。\n详细代码：\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\nvoid testManUnderweight() {\n    Man man = new Man(1.8, 60);\n    assertEquals(\"过轻\", man.conclusion());\n}\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n@Test\nvoid testManUnderweight() {\n    Man man = new Man(1.8, 60);\n    assertEquals(\"过轻\", man.conclusion());\n}\n}", "_id": 153, "response": "```java\nimport java.util.Scanner;\n\nabstract class People {\n    protected double height;\n    protected double weight;\n\n    public People(double height, double weight) {\n        this.height = height;\n        this.weight = weight;\n    }\n\n    public double calculateBMI() {\n        return weight / (height * height);\n    }\n\n    public abstract String conclusion();\n}\n\nclass Man extends People {\n    public Man(double height, double weight) {\n        super(height, weight);\n    }\n\n    @Override\n    public String conclusion() {\n        double bmi = calculateBMI();\n        if (bmi < 20) {\n            return \"过轻\";\n        } else if (bmi < 25) {\n            return \"适中\";\n        } else if (bmi < 30) {\n            return \"过重\";\n        } else if (bmi < 35) {\n            return \"肥胖\";\n        } else {\n            return \"非常肥胖\";\n        }\n    }\n}\n\nclass Woman extends People {\n    public Woman(double height, double weight) {\n        super(height, weight);\n    }\n\n    @Override\n    public String conclusion() {\n        double bmi = calculateBMI();\n        if (bmi < 19) {\n            return \"过轻\";\n        } else if (bmi < 24) {\n            return \"适中\";\n        } else if (bmi < 29) {\n            return \"过重\";\n        } else if (bmi < 34) {\n            return \"肥胖\";\n        } else {\n            return \"非常肥胖\";\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入性别（男/女）：\");\n        String gender = scanner.next();\n        System.out.println(\"请输入身高（m）：\");\n        double height = scanner.nextDouble();\n        System.out.println(\"请输入体重（kg）：\");\n        double weight = scanner.nextDouble();\n\n        People people;\n        if (\"男\".equals(gender)) {\n            people = new Man(height, weight);\n        } else {\n            people = new Woman(height, weight);\n        }\n\n        System.out.println(\"BMI指数为：\" + people.calculateBMI());\n        System.out.println(\"结论为：\" + people.conclusion());\n    }\n}\n```"}
{"user_prompt": "给出下面的html代码，怎么用jsoup 获取内容Ihtesham Haider，html代码如下 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div dir=\"ltr\" class=\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\">Ihtesham Haider</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给出下面的html代码，怎么用jsoup 获取内容Ihtesham Haider，html代码如下 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div dir=\"ltr\" class=\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\">Ihtesham Haider</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMain1() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Ihtesham Haider\", content);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMain1() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Ihtesham Haider\", content);\n    }\n}", "_id": 154, "response": "```java\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\npublic class Main {\n    public static void main(String[] args) {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        System.out.println(content);\n    }\n}\n```"}
{"user_prompt": "使用作业系统提交java作业时，需要输入java源代码文件名和自己的邮箱，\n提交前对java文件名及邮箱进行有效性检查。编写程序对输入的java文件名及\n及邮箱进行有效性检查。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用作业系统提交java作业时，需要输入java源代码文件名和自己的邮箱，\n提交前对java文件名及邮箱进行有效性检查。编写程序对输入的java文件名及\n及邮箱进行有效性检查。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsValidJavaFileName1() {\n        assertTrue(Main.isValidJavaFileName(\"Test.java\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testIsValidJavaFileName1() {\n        assertTrue(Main.isValidJavaFileName(\"Test.java\"));\n    }\n}", "_id": 155, "response": "```java\nimport java.util.regex.Pattern;\n\npublic class Main {\n    private static final String JAVA_FILE_NAME_PATTERN = \"^[a-zA-Z_][a-zA-Z0-9_]*\\\\.java$\";\n    private static final String EMAIL_PATTERN = \"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\";\n\n    public static boolean isValidJavaFileName(String fileName) {\n        if (fileName == null) {\n            return false;\n        }\n        return Pattern.matches(JAVA_FILE_NAME_PATTERN, fileName);\n    }\n\n    public static boolean isValidEmail(String email) {\n        if (email == null) {\n            return false;\n        }\n        return Pattern.matches(EMAIL_PATTERN, email);\n    }\n}\n```"}
{"user_prompt": "输入字符串是这种 格式ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\n我需要先通过 ； 分割 再拿到每组最后一个&&右边的值，再去重，再根据是否有枚举类里面的值进行过滤 枚举是\npublic enum RiskRejectCategoryEnum {\n\n    /**\n     * The smaller the value of priority, the higher the priority\n     */\n    black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n    rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n    no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");}", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n输入字符串是这种 格式ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\n我需要先通过 ； 分割 再拿到每组最后一个&&右边的值，再去重，再根据是否有枚举类里面的值进行过滤 枚举是\npublic enum RiskRejectCategoryEnum {\n\n    /**\n     * The smaller the value of priority, the higher the priority\n     */\n    black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n    rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n    no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testFilterValues1() {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\", \"no_email\", \"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testFilterValues1() {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\", \"no_email\", \"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n}", "_id": 157, "response": "```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    public enum RiskRejectCategoryEnum {\n        black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n        rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n        no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");\n\n        private String value;\n\n        RiskRejectCategoryEnum(String value, String s, int i, String s2) {\n            this.value = value;\n        }\n\n        public String getValue() {\n            return value;\n        }\n\n        public static boolean contains(String value) {\n            for (RiskRejectCategoryEnum c : RiskRejectCategoryEnum.values()) {\n                if (c.getValue().equals(value)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    public static Set<String> filterValues(String input) {\n        String[] parts = input.split(\";\");\n        Set<String> values = new HashSet<>();\n        for (String part : parts) {\n            String[] subParts = part.split(\"&&\");\n            String value = subParts[subParts.length - 1];\n            if (RiskRejectCategoryEnum.contains(value)) {\n                values.add(value);\n            }\n        }\n        return values;\n    }\n}\n```"}
{"user_prompt": "如何使用fastjson快速给xAxis中的data以及series赋值，必须使用如下json\n{\n\t\"xAxis\": {\n\t\t\"type\": \"category\",\n\t\t\"data\": [\n\t\t\t\"Mon\",\n\t\t\t\"Tue\",\n\t\t\t\"Wed\",\n\t\t\t\"Thu\",\n\t\t\t\"Fri\",\n\t\t\t\"Sat\",\n\t\t\t\"Sun\"\n\t\t]\n\t},\n\t\"yAxis\": {\n\t\t\"type\": \"value\"\n\t},\n\t\"series\": [{\n\t\t\"data\": [\n\t\t\t150,\n\t\t\t230,\n\t\t\t224,\n\t\t\t218,\n\t\t\t135,\n\t\t\t147,\n\t\t\t260\n\t\t],\n\t\t\"type\": \"line\"\n\t}]\n}", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n如何使用fastjson快速给xAxis中的data以及series赋值，必须使用如下json\n{\n\t\"xAxis\": {\n\t\t\"type\": \"category\",\n\t\t\"data\": [\n\t\t\t\"Mon\",\n\t\t\t\"Tue\",\n\t\t\t\"Wed\",\n\t\t\t\"Thu\",\n\t\t\t\"Fri\",\n\t\t\t\"Sat\",\n\t\t\t\"Sun\"\n\t\t]\n\t},\n\t\"yAxis\": {\n\t\t\"type\": \"value\"\n\t},\n\t\"series\": [{\n\t\t\"data\": [\n\t\t\t150,\n\t\t\t230,\n\t\t\t224,\n\t\t\t218,\n\t\t\t135,\n\t\t\t147,\n\t\t\t260\n\t\t],\n\t\t\"type\": \"line\"\n\t}]\n}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMain1() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n        assertEquals(\"Tue\", xAxisData.getString(1));\n        assertEquals(\"Wed\", xAxisData.getString(2));\n        assertEquals(\"Thu\", xAxisData.getString(3));\n        assertEquals(\"Fri\", xAxisData.getString(4));\n        assertEquals(\"Sat\", xAxisData.getString(5));\n        assertEquals(\"Sun\", xAxisData.getString(6));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        assertEquals(150, data.getInteger(0));\n        assertEquals(230, data.getInteger(1));\n        assertEquals(224, data.getInteger(2));\n        assertEquals(218, data.getInteger(3));\n        assertEquals(135, data.getInteger(4));\n        assertEquals(147, data.getInteger(5));\n        assertEquals(260, data.getInteger(6));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMain1() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n        assertEquals(\"Tue\", xAxisData.getString(1));\n        assertEquals(\"Wed\", xAxisData.getString(2));\n        assertEquals(\"Thu\", xAxisData.getString(3));\n        assertEquals(\"Fri\", xAxisData.getString(4));\n        assertEquals(\"Sat\", xAxisData.getString(5));\n        assertEquals(\"Sun\", xAxisData.getString(6));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        assertEquals(150, data.getInteger(0));\n        assertEquals(230, data.getInteger(1));\n        assertEquals(224, data.getInteger(2));\n        assertEquals(218, data.getInteger(3));\n        assertEquals(135, data.getInteger(4));\n        assertEquals(147, data.getInteger(5));\n        assertEquals(260, data.getInteger(6));\n    }\n}", "_id": 156, "response": "```java\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\n\npublic class Main {\n    public static void main(String[] args) {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        System.out.println(\"xAxis data: \" + xAxisData);\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        System.out.println(\"Series data: \" + data);\n    }\n}\n```"}
{"user_prompt": "（检测密码）编写一个java方法，检测字符串是否是一个有效密码。\n\n密码规则如下：\n\n密码必须至少8位字符\n\n密码仅能包含字母和数字\n\n密码必须包含至少两个数字\n\n编写一个程序，提示用户输入一个密码，如果符合规则，则显示Valid Password，否则显示Invalid Password。\n\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n（检测密码）编写一个java方法，检测字符串是否是一个有效密码。\n\n密码规则如下：\n\n密码必须至少8位字符\n\n密码仅能包含字母和数字\n\n密码必须包含至少两个数字\n\n编写一个程序，提示用户输入一个密码，如果符合规则，则显示Valid Password，否则显示Invalid Password。\n\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(Main.isValidPassword(\"Password123\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(Main.isValidPassword(\"Password123\"));\n    }\n}", "_id": 158, "response": "```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.print(\"Enter a password: \");\n        String password = input.nextLine();\n\n        if (isValidPassword(password)) {\n            System.out.println(\"Valid Password\");\n        } else {\n            System.out.println(\"Invalid Password\");\n        }\n    }\n\n    public static boolean isValidPassword(String password) {\n        if (password.length() < 8) {\n            return false;\n        }\n\n        int numCount = 0;\n        for (int i = 0; i < password.length(); i++) {\n            char ch = password.charAt(i);\n\n            if (!Character.isLetterOrDigit(ch)) {\n                return false;\n            }\n\n            if (Character.isDigit(ch)) {\n                numCount++;\n            }\n        }\n\n        if (numCount < 2) {\n            return false;\n        }\n\n        return true;\n    }\n}\n```"}
{"user_prompt": "使用单例模式的思想实现多例模式，确保系统中某个类的对象只能存在有限个，如3个(Threeleton)。设计并编写Java代码实现该多例模式。然后使用多线程来测试三例模式，并请输出获取到的每个实例的编号（如0,1,2）。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用单例模式的思想实现多例模式，确保系统中某个类的对象只能存在有限个，如3个(Threeleton)。设计并编写Java代码实现该多例模式。然后使用多线程来测试三例模式，并请输出获取到的每个实例的编号（如0,1,2）。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetInstance_MultipleThreads_1() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[1];\n        for (int i = 0; i < 1; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(0, ids[0].get());\n        assertEquals(0, ids[1].get());\n        assertEquals(0, ids[2].get());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testGetInstance_MultipleThreads_1() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[1];\n        for (int i = 0; i < 1; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(0, ids[0].get());\n        assertEquals(0, ids[1].get());\n        assertEquals(0, ids[2].get());\n    }\n}", "_id": 159, "response": "```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Threeleton {\n    private static final int MAX_INSTANCES = 3;\n    private static final Threeleton[] instances = new Threeleton[MAX_INSTANCES];\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n    private final int id;\n\n    static {\n        for (int i = 0; i < MAX_INSTANCES; i++) {\n            instances[i] = new Threeleton(i);\n        }\n    }\n\n    private Threeleton(int id) {\n        this.id = id;\n    }\n\n    public static Threeleton getInstance() {\n        return instances[nextId.getAndIncrement() % MAX_INSTANCES];\n    }\n\n    public int getId() {\n        return id;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[100];\n        for (int i = 0; i < 100; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Instance \" + i + \" was obtained \" + ids[i].get() + \" times\");\n        }\n    }\n}\n```"}
{"user_prompt": "用Java设计一个方法\npublic static void encodeFile(File encodingFile, File encodedFile);\n用如下规则的加密手段，并将给定的encodingFile文本文件中的内容进行加密，然后保存到encodedFile文件中\n加密规则：\n1.数字： 如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4 如果是9的数字，变成0\n2.字母字符： 如果是非z字符，向右移动一个，比如d变成e, G变成H 如果是z，z->a, Z-A。\n   注：字母字符加密的过程不能改变大小写\n3.非数字和字母的字符则保持不变即可，比如汉字和标点符号等都只需要保持不变即可", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java设计一个方法\npublic static void encodeFile(File encodingFile, File encodedFile);\n用如下规则的加密手段，并将给定的encodingFile文本文件中的内容进行加密，然后保存到encodedFile文件中\n加密规则：\n1.数字： 如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4 如果是9的数字，变成0\n2.字母字符： 如果是非z字符，向右移动一个，比如d变成e, G变成H 如果是z，z->a, Z-A。\n   注：字母字符加密的过程不能改变大小写\n3.非数字和字母的字符则保持不变即可，比如汉字和标点符号等都只需要保持不变即可\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileEncoderTest {\n\n\n    @Test\n    void testEncodeDigits() throws IOException {\n        // 测试数字的加密，包括边界情况9\n        File input = new File(\"testEncodeDigits.txt\");\n        File output = new File(\"testEncodeDigitsOutput.txt\");\n        // 假设input文件内容为 \"123456789\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"234567890\", readFileContent(output));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileEncoderTest {\n\n\n    @Test\n    void testEncodeDigits() throws IOException {\n        // 测试数字的加密，包括边界情况9\n        File input = new File(\"testEncodeDigits.txt\");\n        File output = new File(\"testEncodeDigitsOutput.txt\");\n        // 假设input文件内容为 \"123456789\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"234567890\", readFileContent(output));\n    }\n}", "_id": 160, "response": "```java\nimport java.io.*;\n\npublic class FileEncoder {\n    public static void encodeFile(File encodingFile, File encodedFile) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(encodingFile));\n             BufferedWriter writer = new BufferedWriter(new FileWriter(encodedFile))) {\n            int c;\n            while ((c = reader.read()) != -1) {\n                if (Character.isDigit(c)) {\n                    if (c == '9') {\n                        writer.write('0');\n                    } else {\n                        writer.write(c + 1);\n                    }\n                } else if (Character.isLetter(c)) {\n                    if (c == 'z') {\n                        writer.write('a');\n                    } else if (c == 'Z') {\n                        writer.write('A');\n                    } else {\n                        writer.write(c + 1);\n                    }\n                } else {\n                    writer.write(c);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"}
{"user_prompt": "有一种将字母编码成数字的方式：' a '->1' b ->2',...,' z ->26'。\n现在给一串数字，返回有多少种可能的译码结果。\n例如：\"11\"有2种可能的译码结\n果，\" aa \"或\" k \"。\n要求：字符串长度满足0< n ≤90，空间\n复杂度 O ( n )，时间复杂度 O ( n )。用JAVA实现", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n有一种将字母编码成数字的方式：' a '->1' b ->2',...,' z ->26'。\n现在给一串数字，返回有多少种可能的译码结果。\n例如：\"11\"有2种可能的译码结\n果，\" aa \"或\" k \"。\n要求：字符串长度满足0< n ≤90，空间\n复杂度 O ( n )，时间复杂度 O ( n )。用JAVA实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass SolutionTest {\n\n    @Test\n    void testNumDecodings1() {\n        Solution solution = new Solution();\n        assertEquals(2, solution.numDecodings(\"11\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class SolutionTest {\n\n    @Test\n    void testNumDecodings1() {\n        Solution solution = new Solution();\n        assertEquals(2, solution.numDecodings(\"11\"));\n    }\n}", "_id": 162, "response": "```java\npublic class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) != '0' ? 1 : 0;\n        for (int i = 2; i <= n; i++) {\n            int first = Integer.valueOf(s.substring(i - 1, i));\n            int second = Integer.valueOf(s.substring(i - 2, i));\n            if (first >= 1 && first <= 9) {\n                dp[i] += dp[i - 1];\n            }\n            if (second >= 10 && second <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        return dp[n];\n    }\n}\n```"}
{"user_prompt": "在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下\n\nn = 3, m = 3\n1   2   3\n2   4   6\n3   6   9\n\n给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。请用java实现这一代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下\n\nn = 3, m = 3\n1   2   3\n2   4   6\n3   6   9\n\n给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。请用java实现这一代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class KthLargestInMatrixTest {\n\n\n    @Test\n    public void testSimpleCase() {\n        assertEquals(9, finder.findKthLargestValue(3, 3, 1));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class KthLargestInMatrixTest {\n\n\n    @Test\n    public void testSimpleCase() {\n        assertEquals(9, finder.findKthLargestValue(3, 3, 1));\n    }\n}", "_id": 163, "response": "```java\nimport java.util.PriorityQueue;\n\npublic class KthLargestInMatrix {\n    public int findKthLargestValue(int n, int m, int k) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int value = i * j;\n                if (queue.size() < k) {\n                    queue.offer(value);\n                } else if (queue.peek() < value) {\n                    queue.poll();\n                    queue.offer(value);\n                }\n            }\n        }\n        return queue.peek();\n    }\n}\n```"}
{"user_prompt": "用java2.利用Map，完成下面的功能：\n   1.从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。\n如果该年没有举办世界杯，则输出：没有举办世界杯。\n   2.例如，读入“巴西”，应当输出 1958 1962 1970 1994 2002 读入“荷兰”，应当输出 没有获得过世界杯 。\n1930  乌拉圭\n1934意大利\n1938意大利\n1950乌拉圭\n1954西德\n1958巴西\n1962巴西\n1966英格兰\n1970巴西\n1974西德\n1978阿根廷\n1982意大利\n1986阿根廷\n1990西德\n1994巴西\n1998法国\n2002巴西\n2006意大利\n2010西班牙\n2014德国", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java2.利用Map，完成下面的功能：\n   1.从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。\n如果该年没有举办世界杯，则输出：没有举办世界杯。\n   2.例如，读入“巴西”，应当输出 1958 1962 1970 1994 2002 读入“荷兰”，应当输出 没有获得过世界杯 。\n1930  乌拉圭\n1934意大利\n1938意大利\n1950乌拉圭\n1954西德\n1958巴西\n1962巴西\n1966英格兰\n1970巴西\n1974西德\n1978阿根廷\n1982意大利\n1986阿根廷\n1990西德\n1994巴西\n1998法国\n2002巴西\n2006意大利\n2010西班牙\n2014德国\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class WorldCupServiceTest {\n\n\n    @Test\n    public void testGetChampionByYearWithExistingYear() {\n        assertEquals(\"巴西\", worldCupService.getChampionByYear(\"1958\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class WorldCupServiceTest {\n\n\n    @Test\n    public void testGetChampionByYearWithExistingYear() {\n        assertEquals(\"巴西\", worldCupService.getChampionByYear(\"1958\"));\n    }\n}", "_id": 161, "response": "```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class WorldCupService {\n    private Map<String, String> worldCupData;\n\n    public WorldCupService() {\n        worldCupData = new HashMap<>();\n        worldCupData.put(\"1930\", \"乌拉圭\");\n        worldCupData.put(\"1934\", \"意大利\");\n        worldCupData.put(\"1938\", \"意大利\");\n        worldCupData.put(\"1950\", \"乌拉圭\");\n        worldCupData.put(\"1954\", \"西德\");\n        worldCupData.put(\"1958\", \"巴西\");\n        worldCupData.put(\"1962\", \"巴西\");\n        worldCupData.put(\"1966\", \"英格兰\");\n        worldCupData.put(\"1970\", \"巴西\");\n        worldCupData.put(\"1974\", \"西德\");\n        worldCupData.put(\"1978\", \"阿根廷\");\n        worldCupData.put(\"1982\", \"意大利\");\n        worldCupData.put(\"1986\", \"阿根廷\");\n        worldCupData.put(\"1990\", \"西德\");\n        worldCupData.put(\"1994\", \"巴西\");\n        worldCupData.put(\"1998\", \"法国\");\n        worldCupData.put(\"2002\", \"巴西\");\n        worldCupData.put(\"2006\", \"意大利\");\n        worldCupData.put(\"2010\", \"西班牙\");\n        worldCupData.put(\"2014\", \"德国\");\n    }\n\n    public String getChampionByYear(String year) {\n        return worldCupData.getOrDefault(year, \"没有举办世界杯\");\n    }\n\n    public static void main(String[] args) {\n        WorldCupService worldCupService = new WorldCupService();\n        Scanner scanner = new Scanner(System.in);\n        String year = scanner.nextLine();\n        System.out.println(worldCupService.getChampionByYear(year));\n    }\n}\n```"}
{"user_prompt": "给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。 java", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。 java\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TreeNodeTest {\n\n    @Test\n    void testIsValidBST1() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(2);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(3);\n        assertTrue(solution.isValidBST(root));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class TreeNodeTest {\n\n    @Test\n    void testIsValidBST1() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(2);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(3);\n        assertTrue(solution.isValidBST(root));\n    }\n}", "_id": 164, "response": "```java\npublic class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n\n    private boolean isValidBST(TreeNode node, long minVal, long maxVal) {\n        if (node == null) return true;\n        if (node.val >= maxVal || node.val <= minVal) return false;\n        return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {}\n\n    TreeNode(int val) { this.val = val; }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n```"}
{"user_prompt": "编写程序，请用JAVA语言中的switch-case语句来完成：\n从键盘分别输入年、月、日，判断这一天是当年的第几天\n\n提示：判断一年是否是闰年的标准：\n1)可以被4整除，但不可被100整除\n2)可以被400整除", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写程序，请用JAVA语言中的switch-case语句来完成：\n从键盘分别输入年、月、日，判断这一天是当年的第几天\n\n提示：判断一年是否是闰年的标准：\n1)可以被4整除，但不可被100整除\n2)可以被400整除\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DayOfYearCalculatorTest {\n\n\n    @Test\n    public void testCommonYearFebruary() {\n        assertEquals(59, DayOfYearCalculator.dayOfYear(2023, 2, 28));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DayOfYearCalculatorTest {\n\n\n    @Test\n    public void testCommonYearFebruary() {\n        assertEquals(59, DayOfYearCalculator.dayOfYear(2023, 2, 28));\n    }\n}", "_id": 165, "response": "```java\nimport java.util.Scanner;\n\npublic class DayOfYearCalculator {\n    public static int dayOfYear(int year, int month, int day) {\n        int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        if (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) {\n            monthDays[2] = 29;\n        }\n        int totalDays = 0;\n        for (int i = 0; i < month; i++) {\n            totalDays += monthDays[i];\n        }\n        totalDays += day;\n        return totalDays;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter year: \");\n        int year = scanner.nextInt();\n        System.out.println(\"Enter month: \");\n        int month = scanner.nextInt();\n        System.out.println(\"Enter day: \");\n        int day = scanner.nextInt();\n        System.out.println(\"Day of the year: \" + dayOfYear(year, month, day));\n    }\n}\n```"}
{"user_prompt": "java\n\n对一个字符串，按字典序罗列它的全部排列方式。\n\n输入\n一个字符串（其中可能有相同字符，长度不大于12）\n\n输出\n按ASCII码序，每行一个，罗列它的全部排列方式。\n\n最后一行输出全部排列方式的个数。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\njava\n\n对一个字符串，按字典序罗列它的全部排列方式。\n\n输入\n一个字符串（其中可能有相同字符，长度不大于12）\n\n输出\n按ASCII码序，每行一个，罗列它的全部排列方式。\n\n最后一行输出全部排列方式的个数。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringPermutationsTest {\n\n\n\n    @Test\n    public void testSingleCharacter() {\n        assertEquals(\"Should return one permutation for a single character\", 1, permutations.permute(\"A\").size());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringPermutationsTest {\n\n\n\n    @Test\n    public void testSingleCharacter() {\n        assertEquals(\"Should return one permutation for a single character\", 1, permutations.permute(\"A\").size());\n    }\n}", "_id": 167, "response": "```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class StringPermutations {\n    public static List<String> permute(String input) {\n        List<String> result = new ArrayList<>();\n        char[] chars = input.toCharArray();\n        Arrays.sort(chars);\n        String sortedInput = new String(chars);\n        permute(sortedInput, \"\", result);\n        return result;\n    }\n\n    private static void permute(String input, String prefix, List<String> result) {\n        if (input.length() == 0) {\n            result.add(prefix);\n        } else {\n            for (int i = 0; i < input.length(); i++) {\n                if (i > 0 && input.charAt(i) == input.charAt(i - 1)) {\n                    continue;\n                }\n                permute(input.substring(0, i) + input.substring(i + 1), prefix + input.charAt(i), result);\n            }\n        }\n    }\n}\n```"}
{"user_prompt": "小蓝每天都锻炼身体。\n\n正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2千米。\n\n小蓝跑步已经坚持了很长时间，从 2000 年 11 月 11 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？Java写并解释", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n小蓝每天都锻炼身体。\n\n正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2千米。\n\n小蓝跑步已经坚持了很长时间，从 2000 年 11 月 11 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？Java写并解释\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\n\nimport java.time.LocalDate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RunningTrackerTest {\n\n\n    @Test\n    public void testNonLeapYearFebruary() {\n        // 测试非闰年的2月，期望跑步距离考虑了月初和周一\n        assertEquals(\"Expected distance considering Mondays and the beginning of the month\", 32, tracker.calculateTotalDistance(LocalDate.of(2021, 2, 1), LocalDate.of(2021, 2, 28)));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\n\nimport java.time.LocalDate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RunningTrackerTest {\n\n\n    @Test\n    public void testNonLeapYearFebruary() {\n        // 测试非闰年的2月，期望跑步距离考虑了月初和周一\n        assertEquals(\"Expected distance considering Mondays and the beginning of the month\", 32, tracker.calculateTotalDistance(LocalDate.of(2021, 2, 1), LocalDate.of(2021, 2, 28)));\n    }\n}", "_id": 166, "response": "```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class RunningTracker {\n\n    public long calculateTotalDistance(LocalDate startDate, LocalDate endDate) {\n        long totalDays = ChronoUnit.DAYS.between(startDate, endDate) + 1; // +1 to include both start and end date\n        long totalDistance = totalDays; // Initially considering 1 km per day\n\n        LocalDate date = startDate;\n        while (!date.isAfter(endDate)) {\n            if (date.getDayOfMonth() == 1 || date.getDayOfWeek().getValue() == 1) {\n                totalDistance++; // Add extra 1 km for Monday or the first day of the month\n            }\n            date = date.plusDays(1);\n        }\n\n        return totalDistance;\n    }\n\n    public static void main(String[] args) {\n        RunningTracker tracker = new RunningTracker();\n        LocalDate startDate = LocalDate.of(2000, 11, 11);\n        LocalDate endDate = LocalDate.of(2020, 10, 1);\n        System.out.println(\"Total distance run by Xiao Lan: \" + tracker.calculateTotalDistance(startDate, endDate) + \" km\");\n    }\n}\n```\n这段代码定义了一个名为RunningTracker的类，其中包含一个名为calculateTotalDistance的方法，该方法接受两个LocalDate类型的参数，分别表示开始和结束日期。\n\n首先，我们使用ChronoUnit.DAYS.between方法计算两个日期之间的总天数，然后加1以包括开始和结束日期。然后，我们假设小蓝每天跑1千米，所以总距离初始值为总天数。\n\n然后，我们使用一个while循环遍历从开始日期到结束日期的每一天。如果这一天是月初（日期为1）或者是周一（日期的星期值为1），我们就在总距离上加1千米。\n\n最后，我们返回总距离。\n\n在main方法中，我们创建了一个RunningTracker对象，并使用2000年11月11日到2020年10月1日作为开始和结束日期，然后打印出小蓝在这段时间内跑步的总距离。"}
{"user_prompt": "计算正方形的面积和周长\n编程题\n题目描述\n编写程序，输入正方形的边长，计算这个正方形的周长和面积，并将计算结果打印输出。\n输入示例\n10\n输出示例\n边长: 10\n周长: 40\n面积: 100    用Java写出来", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n计算正方形的面积和周长\n编程题\n题目描述\n编写程序，输入正方形的边长，计算这个正方形的周长和面积，并将计算结果打印输出。\n输入示例\n10\n输出示例\n边长: 10\n周长: 40\n面积: 100    用Java写出来\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class SquareTest {\n\n\n    @Test\n    public void testPerimeterWithPositiveSide() {\n        Square square = new Square(10);\n        assertEquals(40, square.getPerimeter(), 0.01);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class SquareTest {\n\n\n    @Test\n    public void testPerimeterWithPositiveSide() {\n        Square square = new Square(10);\n        assertEquals(40, square.getPerimeter(), 0.01);\n    }\n}", "_id": 169, "response": "```java\npublic class Square {\n    private double side;\n\n    public Square(double side) {\n        this.side = side;\n    }\n\n    public double getPerimeter() {\n        return 4 * side;\n    }\n\n    public double getArea() {\n        return side * side;\n    }\n\n    public static void main(String[] args) {\n        double side = 10;\n        Square square = new Square(side);\n        System.out.println(\"边长: \" + side);\n        System.out.println(\"周长: \" + square.getPerimeter());\n        System.out.println(\"面积: \" + square.getArea());\n    }\n}\n```"}
{"user_prompt": "小美最近发现了一种有趣的游戏，给定一个队列q，小美会按照以下规则进行游戏：\n\n每次从队列中取出一个数，如果这个数是当前队列中最小的值，那么小美就会丢掉这个数。否则小美就会把这个数重新加入队列。\n\n小美会一直进行游戏直到队列变空为止，但是小美并没有多少耐心，因此她想知道她最多需要进行多少次操作才能结束游戏。 请用java编程解决", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n小美最近发现了一种有趣的游戏，给定一个队列q，小美会按照以下规则进行游戏：\n\n每次从队列中取出一个数，如果这个数是当前队列中最小的值，那么小美就会丢掉这个数。否则小美就会把这个数重新加入队列。\n\n小美会一直进行游戏直到队列变空为止，但是小美并没有多少耐心，因此她想知道她最多需要进行多少次操作才能结束游戏。 请用java编程解决\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMaxOperations1() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(3, 2, 1, 4, 5));\n        assertEquals(12, Main.maxOperations(queue));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMaxOperations1() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(3, 2, 1, 4, 5));\n        assertEquals(12, Main.maxOperations(queue));\n    }\n}", "_id": 170, "response": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int maxOperations(Queue<Integer> queue) {\n        int operations = 0;\n        while (!queue.isEmpty()) {\n            int min = Collections.min(queue);\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int num = queue.poll();\n                if (num != min) {\n                    queue.offer(num);\n                }\n                operations++;\n            }\n        }\n        return operations;\n    }\n}\n```"}
{"user_prompt": "请用java解决下面问题：某系统的进程可能占有和等待一些资源，现给出在某一时刻dump的这些进程占有和等待的资源信息，请按照如下简化规则分析哪些进程发生了 死锁，请升序返回所有死锁的进程ID列表，或空列表 []。\n简化规则如下：\n•如果某个进程 p 的任一等待资源设占有，则该进程必须等待，直到这些资源被释放：等待期间，该进程不会释放所占有的资源。\n如果进程 P 所等传的资源全部部末被其他进程占有，则该进程必将释放所古有的资源。\n基于上，如果某个进程因为所等待的资源一直被古有而无限等待下去，则认为该进程发生了死锁。\n输入\n第一行为一个整数num，表示进程个数;\n第二行开始的num行，依次表示每个进程占有和等待资源的情况，格式为：\n进程ID（占有资源列表）（等待资源列表）。\n0<=进程D<=100,0<=资源编号 <= 300\n每一行的箱入中不会包含重复的资源编号\n输入保证：每个资源最多只会被一个进程占有。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请用java解决下面问题：某系统的进程可能占有和等待一些资源，现给出在某一时刻dump的这些进程占有和等待的资源信息，请按照如下简化规则分析哪些进程发生了 死锁，请升序返回所有死锁的进程ID列表，或空列表 []。\n简化规则如下：\n•如果某个进程 p 的任一等待资源设占有，则该进程必须等待，直到这些资源被释放：等待期间，该进程不会释放所占有的资源。\n如果进程 P 所等传的资源全部部末被其他进程占有，则该进程必将释放所古有的资源。\n基于上，如果某个进程因为所等待的资源一直被古有而无限等待下去，则认为该进程发生了死锁。\n输入\n第一行为一个整数num，表示进程个数;\n第二行开始的num行，依次表示每个进程占有和等待资源的情况，格式为：\n进程ID（占有资源列表）（等待资源列表）。\n0<=进程D<=100,0<=资源编号 <= 300\n每一行的箱入中不会包含重复的资源编号\n输入保证：每个资源最多只会被一个进程占有。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testFindDeadlocks1() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(2, 3)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2), result);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testFindDeadlocks1() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(2, 3)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2), result);\n    }\n}", "_id": 168, "response": "```java\nimport java.util.*;\n\npublic class Main {\n    public static List<Integer> findDeadlocks(Map<Integer, Set<Integer>> holdMap, Map<Integer, Set<Integer>> waitMap) {\n        List<Integer> deadlocks = new ArrayList<>();\n        for (Integer processId : holdMap.keySet()) {\n            if (isDeadlock(processId, holdMap, waitMap, new HashSet<>())) {\n                deadlocks.add(processId);\n            }\n        }\n        Collections.sort(deadlocks);\n        return deadlocks;\n    }\n\n    private static boolean isDeadlock(Integer processId, Map<Integer, Set<Integer>> holdMap, Map<Integer, Set<Integer>> waitMap, Set<Integer> visited) {\n        if (!visited.add(processId)) {\n            return true;\n        }\n        Set<Integer> waitingResources = waitMap.get(processId);\n        if (waitingResources == null) {\n            return false;\n        }\n        for (Integer resource : waitingResources) {\n            for (Integer otherProcessId : holdMap.keySet()) {\n                if (holdMap.get(otherProcessId).contains(resource) && isDeadlock(otherProcessId, holdMap, waitMap, visited)) {\n                    return true;\n                }\n            }\n        }\n        visited.remove(processId);\n        return false;\n    }\n}\n```"}
{"user_prompt": "long 数据类型最多能表示19位⼗进制整数，那么对于更⼤的整数应该如何描述呢？在包 hugeinteger 中创建功\n能类 HugeInteger ，该类⽤来存放和操作⼀个不超过100位的⼗进制⼤整数。\n1. 2个重载的构造函数，⽀持通过 long 和 String 类型初始化⼀个 HugeInteger 对象。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nlong 数据类型最多能表示19位⼗进制整数，那么对于更⼤的整数应该如何描述呢？在包 hugeinteger 中创建功\n能类 HugeInteger ，该类⽤来存放和操作⼀个不超过100位的⼗进制⼤整数。\n1. 2个重载的构造函数，⽀持通过 long 和 String 类型初始化⼀个 HugeInteger 对象。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass HugeIntegerTest {\n\n    @Test\n    void testConstructorWithLong() {\n        HugeInteger hi = new HugeInteger(1234567890123456789L);\n        assertEquals(\"1234567890123456789\", hi.getValue());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class HugeIntegerTest {\n\n    @Test\n    void testConstructorWithLong() {\n        HugeInteger hi = new HugeInteger(1234567890123456789L);\n        assertEquals(\"1234567890123456789\", hi.getValue());\n    }\n}", "_id": 171, "response": "```java\npackage hugeinteger;\n\npublic class HugeInteger {\n    private String value;\n\n    public HugeInteger(long value) {\n        this.value = Long.toString(value);\n    }\n\n    public HugeInteger(String value) {\n        if (value.length() > 100) {\n            throw new IllegalArgumentException(\"The length of the string value cannot exceed 100.\");\n        }\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```"}
{"user_prompt": "有一个List<Integer>，其内容为 [1,2,3,4,10,12]，如何将其处理为统一用两位数表示的字符串列表，如 1 要变成 01，用java语言操作", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n有一个List<Integer>，其内容为 [1,2,3,4,10,12]，如何将其处理为统一用两位数表示的字符串列表，如 1 要变成 01，用java语言操作\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class NumberFormatterTest {\n\n\n    @Test\n    public void testFormatNumbers() {\n        List<Integer> input = Arrays.asList(1, 2, 3, 4, 10, 12);\n        List<String> expected = Arrays.asList(\"01\", \"02\", \"03\", \"04\", \"10\", \"12\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class NumberFormatterTest {\n\n\n    @Test\n    public void testFormatNumbers() {\n        List<Integer> input = Arrays.asList(1, 2, 3, 4, 10, 12);\n        List<String> expected = Arrays.asList(\"01\", \"02\", \"03\", \"04\", \"10\", \"12\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n}", "_id": 172, "response": "```java\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class NumberFormatter {\n\n    public static List<String> formatNumbers(List<Integer> numbers) {\n        return numbers.stream()\n                .map(i -> String.format(\"%02d\", i))\n                .collect(Collectors.toList());\n    }\n}\n```"}
{"user_prompt": "设计一个表示分数的类Fraction。这个类用两个int类型的变量分别表示分子和分母。注意，在创建和做完运算后应该化简分数为最简形式。如2/4应该被化简为1/2。Java代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n设计一个表示分数的类Fraction。这个类用两个int类型的变量分别表示分子和分母。注意，在创建和做完运算后应该化简分数为最简形式。如2/4应该被化简为1/2。Java代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class FractionTest {\n\n\n    @Test\n    public void testConstruct() {\n        Fraction fraction = new Fraction(2, 4);\n        assertEquals(\"1/2\", fraction.toString());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class FractionTest {\n\n\n    @Test\n    public void testConstruct() {\n        Fraction fraction = new Fraction(2, 4);\n        assertEquals(\"1/2\", fraction.toString());\n    }\n}", "_id": 173, "response": "```java\npublic class Fraction {\n    private int numerator;\n    private int denominator;\n\n    public Fraction(int numerator, int denominator) {\n        int gcd = gcd(numerator, denominator);\n        this.numerator = numerator / gcd;\n        this.denominator = denominator / gcd;\n    }\n\n    private int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return gcd(b, a % b);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return this.numerator + \"/\" + this.denominator;\n    }\n}\n```"}
{"user_prompt": "用java编写代码，实现 给定一个非空字符串 word 和缩写 abbr，返回字符串是否可以和给定的缩写匹配。\n比如一个 “word” 的字符串仅包含以下有效缩写：[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java编写代码，实现 给定一个非空字符串 word 和缩写 abbr，返回字符串是否可以和给定的缩写匹配。\n比如一个 “word” 的字符串仅包含以下有效缩写：[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MainTest {\n\n\n    @Test\n    public void testValidSingleDigitAbbreviation() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"1ord\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MainTest {\n\n\n    @Test\n    public void testValidSingleDigitAbbreviation() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"1ord\"));\n    }\n}", "_id": 174, "response": "```java\npublic class Main {\n    public static boolean validWordAbbreviation(String word, String abbr) {\n        int i = 0, j = 0;\n        while (i < word.length() && j < abbr.length()) {\n            if (word.charAt(i) == abbr.charAt(j)) {\n                ++i;\n                ++j;\n                continue;\n            }\n            if (abbr.charAt(j) <= '0' || abbr.charAt(j) > '9') {\n                return false;\n            }\n            int start = j;\n            while (j < abbr.length() && abbr.charAt(j) >= '0' && abbr.charAt(j) <= '9') {\n                ++j;\n            }\n            int num = Integer.valueOf(abbr.substring(start, j));\n            i += num;\n        }\n        return i == word.length() && j == abbr.length();\n    }\n}\n```"}
{"user_prompt": "请设计一个递归分段求和函数sum（int start,int End）用于计算机Start至End间的整数和，当Start<End时计算Sum＝Start+（Start+1）+……+End;当Start=End时则返回Start;当Start>End时则返回0输入包含多组测试数据，每组数据包含两个整数Start与End,输出每组数据的计算结果，每组测试数据的计算结果占一行", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请设计一个递归分段求和函数sum（int start,int End）用于计算机Start至End间的整数和，当Start<End时计算Sum＝Start+（Start+1）+……+End;当Start=End时则返回Start;当Start>End时则返回0输入包含多组测试数据，每组数据包含两个整数Start与End,输出每组数据的计算结果，每组测试数据的计算结果占一行\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSum1() {\n        assertEquals(0, Main.sum(5, 3));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSum1() {\n        assertEquals(0, Main.sum(5, 3));\n    }\n}", "_id": 175, "response": "```java\npublic class Main {\n    public static int sum(int start, int end) {\n        if (start > end) {\n            return 0;\n        } else if (start == end) {\n            return start;\n        } else {\n            return start + sum(start + 1, end);\n        }\n    }\n}\n```"}
{"user_prompt": "编写一个Java程序，声明两个整数变量x，y，分别初始化为5和7。然后执行以下操作：\n1、使用前缀递增运算符将第一个整数增加1，并将结果赋值给变量a。\n2、使用后缀递减运算符将第二个整数减少1，并将结果赋值给变量b。\n3、输出a和b的最终值。\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个Java程序，声明两个整数变量x，y，分别初始化为5和7。然后执行以下操作：\n1、使用前缀递增运算符将第一个整数增加1，并将结果赋值给变量a。\n2、使用后缀递减运算符将第二个整数减少1，并将结果赋值给变量b。\n3、输出a和b的最终值。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class IncrementDecrementTest {\n\n\n    @Test\n    public void testIncrement() {\n        assertEquals(\"Increment 5 should be 6\", 6, incDec.increment(5));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class IncrementDecrementTest {\n\n\n    @Test\n    public void testIncrement() {\n        assertEquals(\"Increment 5 should be 6\", 6, incDec.increment(5));\n    }\n}", "_id": 177, "response": "```java\npublic class IncrementDecrement {\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 7;\n\n        int a = ++x;\n        int b = y--;\n\n        System.out.println(\"The value of a is: \" + a);\n        System.out.println(\"The value of b is: \" + b);\n    }\n}\n```"}
{"user_prompt": "编写一个方法，计算给定的两个数组之和，格式如下：\r\n6.1.1\r\npublic static int[] sumArray(int[] a, int[] b)\r\n要求返回的数组元素是两个参数数组对应元素之和，不对\r\n应的元素直接赋给相应的位置，例如，{1,2,4} + \r\n{2,4,6,8}={3,6,10,8}。\r\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个方法，计算给定的两个数组之和，格式如下：\r\n6.1.1\r\npublic static int[] sumArray(int[] a, int[] b)\r\n要求返回的数组元素是两个参数数组对应元素之和，不对\r\n应的元素直接赋给相应的位置，例如，{1,2,4} + \r\n{2,4,6,8}={3,6,10,8}。\r\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSumArray1() {\n        assertArrayEquals(new int[]{3,6,10,8}, Main.sumArray(new int[]{1,2,4}, new int[]{2,4,6,8}));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSumArray1() {\n        assertArrayEquals(new int[]{3,6,10,8}, Main.sumArray(new int[]{1,2,4}, new int[]{2,4,6,8}));\n    }\n}", "_id": 178, "response": "```java\npublic class Main {\n    public static int[] sumArray(int[] a, int[] b) {\n        int[] result;\n        if (a.length > b.length) {\n            result = new int[a.length];\n            for (int i = 0; i < b.length; i++) {\n                result[i] = a[i] + b[i];\n            }\n            for (int i = b.length; i < a.length; i++) {\n                result[i] = a[i];\n            }\n        } else {\n            result = new int[b.length];\n            for (int i = 0; i < a.length; i++) {\n                result[i] = a[i] + b[i];\n            }\n            for (int i = a.length; i < b.length; i++) {\n                result[i] = b[i];\n            }\n        }\n        return result;\n    }\n}\n```"}
{"user_prompt": "编写3个基本类： Triangle, Ladder和Circle，分别用来刻画“三角形”、“梯形”和“圆形”类； 1个主类： Compute，负责计算每个形状的面积或周长。\n具体要求：\nTriangle 定义3个变量：边长；和1个求周长的方法。\nLadder  定义3个变量：上底，下底和高；定义1个求面积的方法\nCircle  定义1个变量：半径；定义2个方法：求面积、求周长。\n3个基本类都要定义相应的构造方法，对变量进行初始化。用Java编写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写3个基本类： Triangle, Ladder和Circle，分别用来刻画“三角形”、“梯形”和“圆形”类； 1个主类： Compute，负责计算每个形状的面积或周长。\n具体要求：\nTriangle 定义3个变量：边长；和1个求周长的方法。\nLadder  定义3个变量：上底，下底和高；定义1个求面积的方法\nCircle  定义1个变量：半径；定义2个方法：求面积、求周长。\n3个基本类都要定义相应的构造方法，对变量进行初始化。用Java编写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TriangleTest {\n\n    @Test\n    void calculatePerimeter() {\n        Triangle triangle = new Triangle(5);\n        assertEquals(15, triangle.calculatePerimeter());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class TriangleTest {\n\n    @Test\n    void calculatePerimeter() {\n        Triangle triangle = new Triangle(5);\n        assertEquals(15, triangle.calculatePerimeter());\n    }\n}", "_id": 176, "response": "```java\npublic class Triangle {\n    private double side;\n\n    public Triangle(double side) {\n        this.side = side;\n    }\n\n    public double calculatePerimeter() {\n        return 3 * side;\n    }\n}\n\npublic class Ladder {\n    private double top;\n    private double bottom;\n    private double height;\n\n    public Ladder(double top, double bottom, double height) {\n        this.top = top;\n        this.bottom = bottom;\n        this.height = height;\n    }\n\n    public double calculateArea() {\n        return (top + bottom) * height / 2;\n    }\n}\n\npublic class Circle {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    public double calculateArea() {\n        return Math.PI * Math.pow(radius, 2);\n    }\n\n    public double calculatePerimeter() {\n        return 2 * Math.PI * radius;\n    }\n}\n\npublic class Compute {\n    public static void main(String[] args) {\n        Triangle triangle = new Triangle(5);\n        System.out.println(\"Triangle Perimeter: \" + triangle.calculatePerimeter());\n\n        Ladder ladder = new Ladder(5, 10, 7);\n        System.out.println(\"Ladder Area: \" + ladder.calculateArea());\n\n        Circle circle = new Circle(5);\n        System.out.println(\"Circle Area: \" + circle.calculateArea());\n        System.out.println(\"Circle Perimeter: \" + circle.calculatePerimeter());\n    }\n}\n```"}
{"user_prompt": "请帮我实现一段java代码，实现：输入一段字符串，其中会含有<a>标签 ，输出的是处理过的字符串，要求：1、被<a> </a>所包裹的内容保持不变 2、没有被<a>标签包裹的内容需要被<b>标签包裹", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请帮我实现一段java代码，实现：输入一段字符串，其中会含有<a>标签 ，输出的是处理过的字符串，要求：1、被<a> </a>所包裹的内容保持不变 2、没有被<a>标签包裹的内容需要被<b>标签包裹\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testWrapNonATagContent1() {\n        String input = \"Hello <a>World</a>!\";\n        String expected = \"<b>Hello </b><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testWrapNonATagContent1() {\n        String input = \"Hello <a>World</a>!\";\n        String expected = \"<b>Hello </b><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n}", "_id": 179, "response": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static String wrapNonATagContent(String input) {\n        String[] parts = input.split(\"(?=<a>)|(?<=</a>)\");\n        StringBuilder sb = new StringBuilder();\n        Pattern pattern = Pattern.compile(\"<a>.*</a>\");\n\n        for (String part : parts) {\n            Matcher matcher = pattern.matcher(part);\n            if (!matcher.find()) {\n                sb.append(\"<b>\").append(part).append(\"</b>\");\n            } else {\n                sb.append(part);\n            }\n        }\n\n        return sb.toString();\n    }\n}\n```"}
{"user_prompt": "需求描述:国家实行无偿献血制度，对于献血者的体格检查的部分标准为：年龄为18～55周\n岁，男性体重≥ 50kg，女性本重 ≥45kg，每次献血量为200m1~400ml。用Java编写程序实现输入献血的年龄，性别，体重，判断其是否能进行献血。\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n需求描述:国家实行无偿献血制度，对于献血者的体格检查的部分标准为：年龄为18～55周\n岁，男性体重≥ 50kg，女性本重 ≥45kg，每次献血量为200m1~400ml。用Java编写程序实现输入献血的年龄，性别，体重，判断其是否能进行献血。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class BloodDonationEligibilityTest {\n\n\n    @Test\n    public void testEligibleMale() {\n        assertTrue(\"A male aged 30 weighing 60kg should be eligible\", eligibility.isEligibleForDonation(30, \"male\", 60));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class BloodDonationEligibilityTest {\n\n\n    @Test\n    public void testEligibleMale() {\n        assertTrue(\"A male aged 30 weighing 60kg should be eligible\", eligibility.isEligibleForDonation(30, \"male\", 60));\n    }\n}", "_id": 180, "response": "```java\npublic class BloodDonationEligibility {\n\n    public static boolean isEligibleForDonation(int age, String gender, double weight) {\n        if (age < 18 || age > 55) {\n            return false;\n        }\n        if (gender.equalsIgnoreCase(\"male\") && weight < 50) {\n            return false;\n        }\n        if (gender.equalsIgnoreCase(\"female\") && weight < 45) {\n            return false;\n        }\n        return true;\n    }\n}\n```"}
{"user_prompt": "给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。\n\n如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。\n\n返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。\n\n使用java解答", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。\n\n如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。\n\n返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。\n\n使用java解答\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCountVowelStrings1() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 1, 5));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCountVowelStrings1() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 1, 5));\n    }\n}", "_id": 181, "response": "```java\npublic class Main {\n    public static int countVowelStrings(String[] words, int left, int right) {\n        int count = 0;\n        for (int i = left; i <= right; i++) {\n            if (isVowelString(words[i])) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static boolean isVowelString(String word) {\n        char firstChar = word.charAt(0);\n        char lastChar = word.charAt(word.length() - 1);\n        return isVowel(firstChar) && isVowel(lastChar);\n    }\n\n    private static boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}\n```"}
{"user_prompt": "Java方法重载自定义一个求最大值的类。\n求三个数中最大值的方法，并实现方法重载，要求能够分别比较三个整数中的最大值，三个小数中的最大值，以及任意三个数中的最大值。\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava方法重载自定义一个求最大值的类。\n求三个数中最大值的方法，并实现方法重载，要求能够分别比较三个整数中的最大值，三个小数中的最大值，以及任意三个数中的最大值。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MaxValueTest {\n\n    @Test\n    void testMaxInt() {\n        MaxValue maxValue = new MaxValue();\n        assertEquals(9, maxValue.max(3, 5, 9));\n        assertEquals(0, maxValue.max(0, -1, -2));\n        assertEquals(100, maxValue.max(100, 100, 100));\n        assertEquals(-1, maxValue.max(-1, -2, -3));\n        assertEquals(Integer.MAX_VALUE, maxValue.max(Integer.MAX_VALUE, 0, -1));\n        assertEquals(Integer.MIN_VALUE, maxValue.max(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MaxValueTest {\n\n    @Test\n    void testMaxInt() {\n        MaxValue maxValue = new MaxValue();\n        assertEquals(9, maxValue.max(3, 5, 9));\n        assertEquals(0, maxValue.max(0, -1, -2));\n        assertEquals(100, maxValue.max(100, 100, 100));\n        assertEquals(-1, maxValue.max(-1, -2, -3));\n        assertEquals(Integer.MAX_VALUE, maxValue.max(Integer.MAX_VALUE, 0, -1));\n        assertEquals(Integer.MIN_VALUE, maxValue.max(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}", "_id": 182, "response": "```java\npublic class MaxValue {\n    public int max(int a, int b, int c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    public double max(double a, double b, double c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    public double max(Number a, Number b, Number c) {\n        return Math.max(Math.max(a.doubleValue(), b.doubleValue()), c.doubleValue());\n    }\n}\n```"}
{"user_prompt": "Java中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "_id": 183, "response": "```java\npublic class StringUtils {\n\n    public static String alternateCase(String input) {\n        if (input == null || input.isEmpty()) {\n            return input;\n        }\n\n        char[] chars = input.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (i % 2 == 0) {\n                chars[i] = Character.toUpperCase(chars[i]);\n            } else {\n                chars[i] = Character.toLowerCase(chars[i]);\n            }\n        }\n\n        return new String(chars);\n    }\n}\n```"}
{"user_prompt": "用java编写一个切换java jdk版本的程序，用于切换jdk1.7，1.8以及jdk11,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java编写一个切换java jdk版本的程序，用于切换jdk1.7，1.8以及jdk11,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass CommentRemoverTest {\n\n    @Test\n    void testRemoveCommentsFromFile1() {\n        CommentRemover.removeCommentsFromFile(\"test1/test.java\", \"test1/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test1/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class CommentRemoverTest {\n\n    @Test\n    void testRemoveCommentsFromFile1() {\n        CommentRemover.removeCommentsFromFile(\"test1/test.java\", \"test1/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test1/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "_id": 184, "response": "```java\nimport java.io.IOException;\n\npublic class JDKSwitcher {\n\n    public static void switchJDKVersion(String version) {\n        String jdkPath = \"\";\n        switch (version) {\n            case \"1.7\":\n                jdkPath = \"/path/to/jdk1.7\";\n                break;\n            case \"1.8\":\n                jdkPath = \"/path/to/jdk1.8\";\n                break;\n            case \"11\":\n                jdkPath = \"/path/to/jdk11\";\n                break;\n            default:\n                System.out.println(\"Unsupported JDK version\");\n                return;\n        }\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"cmd.exe\", \"/c\", \"setx\", \"JAVA_HOME\", jdkPath);\n            pb.start();\n            pb = new ProcessBuilder(\"cmd.exe\", \"/c\", \"setx\", \"PATH\", \"%JAVA_HOME%\\\\bin;%PATH%\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        switchJDKVersion(\"1.8\");\n    }\n}\n```\n注意：这个程序只能在Windows系统上运行，并且需要管理员权限。在运行此程序之前，你需要将\"/path/to/jdk1.7\", \"/path/to/jdk1.8\" 和 \"/path/to/jdk11\" 替换为你的实际JDK安装路径。"}
{"user_prompt": "java语言根据图像长宽设定三个阈值进行分类，当长或宽小于阈值100时输出到文件夹folder_1，当长或宽大于阈值100小于阈值200时输出到文件夹folder_2，其它输出到文件夹folder_3,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\njava语言根据图像长宽设定三个阈值进行分类，当长或宽小于阈值100时输出到文件夹folder_1，当长或宽大于阈值100小于阈值200时输出到文件夹folder_2，其它输出到文件夹folder_3,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass DistanceTest {\n\n    @Test\n    void testEuclideanDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(5.196152422706632, Distance.euclideanDistance(pointA, pointB));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class DistanceTest {\n\n    @Test\n    void testEuclideanDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(5.196152422706632, Distance.euclideanDistance(pointA, pointB));\n    }\n}", "_id": 186, "response": "```java\npublic class ImageClassifier {\n\n    public static String classifyImage(int length, int width) {\n        if (length < 100 || width < 100) {\n            return \"folder_1\";\n        } else if ((length > 100 && length < 200) || (width > 100 && width < 200)) {\n            return \"folder_2\";\n        } else {\n            return \"folder_3\";\n        }\n    }\n\n    public static void main(String[] args) {\n        int length = 150;\n        int width = 250;\n        String folder = classifyImage(length, width);\n        System.out.println(\"The image should be saved in \" + folder);\n    }\n}\n```"}
{"user_prompt": "用java语法,读取java文件并去除其中的所有注释，可以使用正则表达式或解析器来实现,输出去除所有注释的文件,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java语法,读取java文件并去除其中的所有注释，可以使用正则表达式或解析器来实现,输出去除所有注释的文件,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ImageClassifierTest {\n\n    @Test\n    public void testClassifyImages_case1() {\n        ImageClassifier.classifyImages(\"test1\", 280, 440);\n        assertTrue((new File(\"test1/folder_1/1.jpg\").exists()));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class ImageClassifierTest {\n\n    @Test\n    public void testClassifyImages_case1() {\n        ImageClassifier.classifyImages(\"test1\", 280, 440);\n        assertTrue((new File(\"test1/folder_1/1.jpg\").exists()));\n    }\n}", "_id": 185, "response": "```java\nimport java.io.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class RemoveComments {\n\n    public static void removeComments(String filePath) {\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(filePath));\n            String line = reader.readLine();\n            StringBuilder sb = new StringBuilder();\n\n            while (line != null) {\n                sb.append(line).append(\"\\n\");\n                line = reader.readLine();\n            }\n            reader.close();\n\n            String noComments = removeCommentsFromString(sb.toString());\n\n            BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));\n            writer.write(noComments);\n            writer.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String removeCommentsFromString(String sourceCode) {\n        String regex = \"(?:/\\\\*(?:[^*]|(?:\\\\*+[^*/]))*\\\\*+/)|(?://.*)\";\n        Pattern commentPattern = Pattern.compile(regex, Pattern.MULTILINE);\n        Matcher m = commentPattern.matcher(sourceCode);\n        return m.replaceAll(\"\");\n    }\n\n    public static void main(String[] args) {\n        removeComments(\"path_to_your_file.java\");\n    }\n}\n```\n这段代码首先读取指定的Java文件，然后使用正则表达式删除所有的注释，最后将结果写回到原文件中。注意，这段代码会删除所有的注释，包括行注释和块注释。"}
{"user_prompt": "用java标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddUser1() {\n        UserManager userManager = new UserManager();\n        // Test case 1: Invalid name\n        assertEquals(\"Name illegal\", userManager.addUser(\"123\", \"M\", \"000100200000\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testAddUser1() {\n        UserManager userManager = new UserManager();\n        // Test case 1: Invalid name\n        assertEquals(\"Name illegal\", userManager.addUser(\"123\", \"M\", \"000100200000\"));\n    }\n}", "_id": 188, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static class Box {\n        public double x1, y1, x2, y2;\n\n        public Box(double x1, double y1, double x2, double y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n\n        public double area() {\n            return (x2 - x1) * (y2 - y1);\n        }\n\n        public Box intersection(Box other) {\n            double x1 = Math.max(this.x1, other.x1);\n            double y1 = Math.max(this.y1, other.y1);\n            double x2 = Math.min(this.x2, other.x2);\n            double y2 = Math.min(this.y2, other.y2);\n\n            if (x1 < x2 && y1 < y2) {\n                return new Box(x1, y1, x2, y2);\n            } else {\n                return null;\n            }\n        }\n\n        public double iou(Box other) {\n            Box intersection = this.intersection(other);\n            if (intersection == null) {\n                return 0.0;\n            } else {\n                double union = this.area() + other.area() - intersection.area();\n                return intersection.area() / union;\n            }\n        }\n    }\n\n    public static class Label {\n        public Box box;\n        public int category;\n\n        public Label(Box box, int category) {\n            this.box = box;\n            this.category = category;\n        }\n    }\n\n    public static List<Label> labelData(List<Box> boxes, Box region) {\n        List<Label> labels = new ArrayList<>();\n        for (Box box : boxes) {\n            if (box.iou(region) > 0.2) {\n                labels.add(new Label(box, 0));\n            }\n        }\n        return labels;\n    }\n\n    public static void main(String[] args) {\n        // Test data\n        List<Box> boxes = new ArrayList<>();\n        boxes.add(new Box(0, 0, 1, 1));\n        boxes.add(new Box(0.5, 0.5, 1.5, 1.5));\n        boxes.add(new Box(1, 1, 2, 2));\n\n        Box region = new Box(0, 0, 1, 1);\n\n        List<Label> labels = labelData(boxes, region);\n        for (Label label : labels) {\n            System.out.println(\"Box: (\" + label.box.x1 + \", \" + label.box.y1 + \", \" + label.box.x2 + \", \" + label.box.y2 + \"), Category: \" + label.category);\n        }\n    }\n}\n```"}
{"user_prompt": "用java函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TestConvertLabels {\n\n\n    @Test\n    void testConvertLabels1(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>1</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class TestConvertLabels {\n\n\n    @Test\n    void testConvertLabels1(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>1</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n}", "_id": 187, "response": "```java\nimport java.util.*;\nimport java.lang.Math;\n\npublic class DistanceCalculator {\n    // Euclidean Distance\n    public static double euclideanDistance(double[] vector1, double[] vector2) {\n        double sum = 0.0;\n        for (int i = 0; i < vector1.length; i++) {\n            sum += Math.pow(vector1[i] - vector2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n\n    // Manhattan Distance\n    public static double manhattanDistance(double[] vector1, double[] vector2) {\n        double sum = 0.0;\n        for (int i = 0; i < vector1.length; i++) {\n            sum += Math.abs(vector1[i] - vector2[i]);\n        }\n        return sum;\n    }\n\n    // Chebyshev Distance\n    public static double chebyshevDistance(double[] vector1, double[] vector2) {\n        double max = 0.0;\n        for (int i = 0; i < vector1.length; i++) {\n            max = Math.max(max, Math.abs(vector1[i] - vector2[i]));\n        }\n        return max;\n    }\n\n    // Minkowski Distance\n    public static double minkowskiDistance(double[] vector1, double[] vector2, int p) {\n        double sum = 0.0;\n        for (int i = 0; i < vector1.length; i++) {\n            sum += Math.pow(Math.abs(vector1[i] - vector2[i]), p);\n        }\n        return Math.pow(sum, 1.0 / p);\n    }\n\n    // Cosine Similarity\n    public static double cosineSimilarity(double[] vector1, double[] vector2) {\n        double dotProduct = 0.0;\n        double normA = 0.0;\n        double normB = 0.0;\n        for (int i = 0; i < vector1.length; i++) {\n            dotProduct += vector1[i] * vector2[i];\n            normA += Math.pow(vector1[i], 2);\n            normB += Math.pow(vector2[i], 2);\n        }\n        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n    }\n\n    // Hamming Distance\n    public static int hammingDistance(String str1, String str2) {\n        int i = 0, count = 0;\n        while (i < str1.length()) {\n            if (str1.charAt(i) != str2.charAt(i))\n                count++;\n            i++;\n        }\n        return count;\n    }\n\n    // Jaccard Similarity\n    public static double jaccardSimilarity(List<String> list1, List<String> list2) {\n        Set<String> set1 = new HashSet<>(list1);\n        Set<String> set2 = new HashSet<>(list2);\n        Set<String> intersection = new HashSet<>(set1);\n        intersection.retainAll(set2);\n        Set<String> union = new HashSet<>(set1);\n        union.addAll(set2);\n        return (double) intersection.size() / union.size();\n    }\n\n    public static void main(String[] args) {\n        double[] vector1 = {1.0, 2.0, 3.0};\n        double[] vector2 = {4.0, 5.0, 6.0};\n        System.out.println(\"Euclidean Distance: \" + euclideanDistance(vector1, vector2));\n        System.out.println(\"Manhattan Distance: \" + manhattanDistance(vector1, vector2));\n        System.out.println(\"Chebyshev Distance: \" + chebyshevDistance(vector1, vector2));\n        System.out.println(\"Minkowski Distance: \" + minkowskiDistance(vector1, vector2, 3));\n        System.out.println(\"Cosine Similarity: \" + cosineSimilarity(vector1, vector2));\n        System.out.println(\"Hamming Distance: \" + hammingDistance(\"101010\", \"100100\"));\n        System.out.println(\"Jaccard Similarity: \" + jaccardSimilarity(Arrays.asList(\"a\", \"b\", \"c\"), Arrays.asList(\"b\", \"c\", \"d\")));\n    }\n}\n```"}
{"user_prompt": "请用java语言为用户设立一个 User 类：\n私有属性至少包括姓名（仅可能由 26 个字母大小写和下划线构成）、性别（字符 M/F/O，分别表示男性/女性/其他）、ID卡号（符合下述合法格式）\nID卡号一共12位，每个用户唯一\n前4位的范围是[0001,1237]\n中间4位的范围为[0020,0460]\n最后四位为生物识别库提供的生物识别码，前三位的范围为[000,100]，最后一位表示持有人的性别，0代表女性，1代表男性，2代表其他。\n合法的ID卡号示例：\n0023 0122 0991\n1000 0072 0000\n不合法的ID卡号示例：\n0000 0122 0991\n0030 0500 1010\n1234 0123 0553\n需要为用户的3种属性提供相应的 getter 和 setter 方法\n实现方法 String toString() 打印用户格式化信息，具体要求如下：\n1.冒号为英文字符 :\n2.不包含多余的空格\n3.所有字符为半角字符\n以 jack，ID卡号 0910 0072 0112 为例：\nName:jack\nSex:O\nID:091000720112 \n实现添加用户方法，命令格式如下：\n选项\t[参数 1]\t[参数 2]\t[参数 3]\t功能描述\naddUser\t姓名\t性别\t卡号\t新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。\n具体要求如下：\n在输入 addUser 命令时，并不保证参数数量严格对应，这也是一种非法情况，需要在终端输出：\nArguments illegal\n如果参数合法，按以下顺序依次进行信息检查\n姓名由 26 个字母和下划线构成，其他情况请输出\nName illegal\n性别必须为 F / M / O，其他情况请输出\nSex illegal\n卡号需满足指定格式，非法（包括尾号和性别不符的情况）请输出\nID number illegal\n一张卡号只能注册一次，若注册卡号已存在请输出\nID number exist\n如果存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n如果输入合法，按 toString() 输出格式打印刚添加的用户信息。如：\naddUser LaoWang M\nArguments illegal\naddUser LaoWang GHS 123123\nSex illegal\naddUser LaoWang M 003005001010\nAadhaar number illegal\naddUser LaoWang M 002301220991\nName:LaoWang\nSex:M\nAadhaar:002301220991\naddUser HaiWang M 002301220991\nAadhaar number exist", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请用java语言为用户设立一个 User 类：\n私有属性至少包括姓名（仅可能由 26 个字母大小写和下划线构成）、性别（字符 M/F/O，分别表示男性/女性/其他）、ID卡号（符合下述合法格式）\nID卡号一共12位，每个用户唯一\n前4位的范围是[0001,1237]\n中间4位的范围为[0020,0460]\n最后四位为生物识别库提供的生物识别码，前三位的范围为[000,100]，最后一位表示持有人的性别，0代表女性，1代表男性，2代表其他。\n合法的ID卡号示例：\n0023 0122 0991\n1000 0072 0000\n不合法的ID卡号示例：\n0000 0122 0991\n0030 0500 1010\n1234 0123 0553\n需要为用户的3种属性提供相应的 getter 和 setter 方法\n实现方法 String toString() 打印用户格式化信息，具体要求如下：\n1.冒号为英文字符 :\n2.不包含多余的空格\n3.所有字符为半角字符\n以 jack，ID卡号 0910 0072 0112 为例：\nName:jack\nSex:O\nID:091000720112 \n实现添加用户方法，命令格式如下：\n选项\t[参数 1]\t[参数 2]\t[参数 3]\t功能描述\naddUser\t姓名\t性别\t卡号\t新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。\n具体要求如下：\n在输入 addUser 命令时，并不保证参数数量严格对应，这也是一种非法情况，需要在终端输出：\nArguments illegal\n如果参数合法，按以下顺序依次进行信息检查\n姓名由 26 个字母和下划线构成，其他情况请输出\nName illegal\n性别必须为 F / M / O，其他情况请输出\nSex illegal\n卡号需满足指定格式，非法（包括尾号和性别不符的情况）请输出\nID number illegal\n一张卡号只能注册一次，若注册卡号已存在请输出\nID number exist\n如果存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n如果输入合法，按 toString() 输出格式打印刚添加的用户信息。如：\naddUser LaoWang M\nArguments illegal\naddUser LaoWang GHS 123123\nSex illegal\naddUser LaoWang M 003005001010\nAadhaar number illegal\naddUser LaoWang M 002301220991\nName:LaoWang\nSex:M\nAadhaar:002301220991\naddUser HaiWang M 002301220991\nAadhaar number exist\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass CopyFileTest {\n\n\n    @Test\n    void testCopyAndMoveFile1() {\n        String sourceFilePath = \"test1/test.txt\";\n        String destinationDirectory = \"test1/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class CopyFileTest {\n\n\n    @Test\n    void testCopyAndMoveFile1() {\n        String sourceFilePath = \"test1/test.txt\";\n        String destinationDirectory = \"test1/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n}", "_id": 189, "response": "```java\nimport java.util.regex.Pattern;\nimport java.util.HashMap;\n\npublic class User {\n    private String name;\n    private char sex;\n    private String id;\n\n    private static HashMap<String, User> users = new HashMap<>();\n\n    public User(String name, char sex, String id) {\n        this.name = name;\n        this.sex = sex;\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public char getSex() {\n        return sex;\n    }\n\n    public void setSex(char sex) {\n        this.sex = sex;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    @Override\n    public String toString() {\n        return \"Name:\" + name + \"\\nSex:\" + sex + \"\\nID:\" + id.replace(\" \", \"\");\n    }\n\n    public static void addUser(String name, char sex, String id) {\n        if (!Pattern.matches(\"^[a-zA-Z_]+$\", name)) {\n            System.out.println(\"Name illegal\");\n            return;\n        }\n        if (sex != 'M' && sex != 'F' && sex != 'O') {\n            System.out.println(\"Sex illegal\");\n            return;\n        }\n        if (!Pattern.matches(\"^([0-9]{4} [0-9]{4} [0-9]{3}[0-2])$\", id)) {\n            System.out.println(\"ID number illegal\");\n            return;\n        }\n        if (users.containsKey(id)) {\n            System.out.println(\"ID number exist\");\n            return;\n        }\n        User user = new User(name, sex, id);\n        users.put(id, user);\n        System.out.println(user);\n    }\n}\n```"}
{"user_prompt": "请使用java完成一个进度条类ProgressBar以展示工程进度。具体要求如下：1.接受一个参数totalTasks，表示总任务数；2.包含taskCompleted()方法，用于标记任务完成；3.updateProgressBar()方法，用于更新进度条的显示。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请使用java完成一个进度条类ProgressBar以展示工程进度。具体要求如下：1.接受一个参数totalTasks，表示总任务数；2.包含taskCompleted()方法，用于标记任务完成；3.updateProgressBar()方法，用于更新进度条的显示。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ValidPasswordTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@123\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class ValidPasswordTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@123\"));\n    }\n}", "_id": 191, "response": "```java\npublic class ProgressBar {\n    private int totalTasks;\n    private int completedTasks;\n\n    public ProgressBar(int totalTasks) {\n        this.totalTasks = totalTasks;\n        this.completedTasks = 0;\n    }\n\n    public void taskCompleted() {\n        if (completedTasks < totalTasks) {\n            completedTasks++;\n            updateProgressBar();\n        }\n    }\n\n    public void updateProgressBar() {\n        int percentage = (completedTasks * 100) / totalTasks;\n        StringBuilder progressBar = new StringBuilder(\"Progress: [\");\n        int i = 0;\n        for (; i <= percentage; i += 2) {\n            progressBar.append(\"=\");\n        }\n        for (; i <= 100; i += 2) {\n            progressBar.append(\" \");\n        }\n        progressBar.append(\"] \" + percentage + \"%\");\n        System.out.println(progressBar.toString());\n    }\n}\n```"}
{"user_prompt": "手动编写数据，使用java语言编写K均值（K-means）聚类算法。计算输出每个数据样本的结果", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n手动编写数据，使用java语言编写K均值（K-means）聚类算法。计算输出每个数据样本的结果\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass LongestPathTest {\n\n    @Test\n    public void testLengthLongestPath1() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class LongestPathTest {\n\n    @Test\n    public void testLengthLongestPath1() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n}", "_id": 190, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class KMeans {\n    private static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    private static class Cluster {\n        Point centroid;\n        List<Point> points;\n\n        Cluster(Point centroid) {\n            this.centroid = centroid;\n            this.points = new ArrayList<>();\n        }\n\n        void updateCentroid() {\n            double totalX = 0, totalY = 0;\n            for (Point point : points) {\n                totalX += point.x;\n                totalY += point.y;\n            }\n            centroid.x = totalX / points.size();\n            centroid.y = totalY / points.size();\n        }\n    }\n\n    public static void kMeans(List<Point> points, int k) {\n        List<Cluster> clusters = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            clusters.add(new Cluster(points.get(i)));\n        }\n\n        boolean convergence = false;\n        while (!convergence) {\n            for (Cluster cluster : clusters) {\n                cluster.points.clear();\n            }\n\n            for (Point point : points) {\n                Cluster closestCluster = null;\n                double closestDistance = Double.MAX_VALUE;\n                for (Cluster cluster : clusters) {\n                    double distance = Math.sqrt(Math.pow(cluster.centroid.x - point.x, 2) + Math.pow(cluster.centroid.y - point.y, 2));\n                    if (distance < closestDistance) {\n                        closestDistance = distance;\n                        closestCluster = cluster;\n                    }\n                }\n                closestCluster.points.add(point);\n            }\n\n            convergence = true;\n            for (Cluster cluster : clusters) {\n                Point oldCentroid = new Point(cluster.centroid.x, cluster.centroid.y);\n                cluster.updateCentroid();\n                if (Math.sqrt(Math.pow(oldCentroid.x - cluster.centroid.x, 2) + Math.pow(oldCentroid.y - cluster.centroid.y, 2)) > 0.0001) {\n                    convergence = false;\n                }\n            }\n        }\n\n        for (int i = 0; i < clusters.size(); i++) {\n            System.out.println(\"Cluster \" + (i + 1) + \":\");\n            for (Point point : clusters.get(i).points) {\n                System.out.println(\"(\" + point.x + \", \" + point.y + \")\");\n            }\n        }\n    }\n}\n```"}
{"user_prompt": "对于java中time包的考察\n编写一个Java程序来计算两个日期之间的间隔。给定两个字符串格式的日期（\"2023-03-15\"和\"2023-04-14\"），计算它们之间的完整天数差。程序应能处理不同年份和闰年。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对于java中time包的考察\n编写一个Java程序来计算两个日期之间的间隔。给定两个字符串格式的日期（\"2023-03-15\"和\"2023-04-14\"），计算它们之间的完整天数差。程序应能处理不同年份和闰年。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass DaysBetweenDatesTest {\n\n    @Test\n    void testCalculateDaysBetweenDates() {\n        assertEquals(30, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-04-14\"));\n        assertEquals(365, DaysBetweenDates.calculateDaysBetweenDates(\"2023-01-01\", \"2024-01-01\"));\n        assertEquals(366, DaysBetweenDates.calculateDaysBetweenDates(\"2024-01-01\", \"2025-01-01\"));\n        assertEquals(0, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-15\"));\n        assertEquals(1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-16\"));\n        assertEquals(-1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-16\", \"2023-03-15\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class DaysBetweenDatesTest {\n\n    @Test\n    void testCalculateDaysBetweenDates() {\n        assertEquals(30, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-04-14\"));\n        assertEquals(365, DaysBetweenDates.calculateDaysBetweenDates(\"2023-01-01\", \"2024-01-01\"));\n        assertEquals(366, DaysBetweenDates.calculateDaysBetweenDates(\"2024-01-01\", \"2025-01-01\"));\n        assertEquals(0, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-15\"));\n        assertEquals(1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-16\"));\n        assertEquals(-1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-16\", \"2023-03-15\"));\n    }\n}", "_id": 193, "response": "```java\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n\n    public static long calculateDaysBetweenDates(String date1, String date2) {\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n        LocalDate startDate = LocalDate.parse(date1, formatter);\n        LocalDate endDate = LocalDate.parse(date2, formatter);\n        return ChronoUnit.DAYS.between(startDate, endDate);\n    }\n}\n```"}
{"user_prompt": "创建一个名为LinearRegressionLoss的java类，编写三个静态方法用于计算线性回归中常用的三种损失函数均方误差，平均绝对误差和Huber损失，并在main方法中手动生成数据，调用这三个方法计算相应的损失，并输出相应的计算结果。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建一个名为LinearRegressionLoss的java类，编写三个静态方法用于计算线性回归中常用的三种损失函数均方误差，平均绝对误差和Huber损失，并在main方法中手动生成数据，调用这三个方法计算相应的损失，并输出相应的计算结果。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass LinearRegressionLossTest {\n\n    @Test\n    public void testCalculateMSE1() {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        assertEquals(0.25, LinearRegressionLoss.calculateMSE(actual, predicted));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class LinearRegressionLossTest {\n\n    @Test\n    public void testCalculateMSE1() {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        assertEquals(0.25, LinearRegressionLoss.calculateMSE(actual, predicted));\n    }\n}", "_id": 192, "response": "```java\npublic class LinearRegressionLoss {\n\n    public static double calculateMSE(double[] actual, double[] predicted) {\n        double sum = 0.0;\n        for (int i = 0; i < actual.length; i++) {\n            sum += Math.pow((predicted[i] - actual[i]), 2);\n        }\n        return sum / actual.length;\n    }\n\n    public static double calculateMAE(double[] actual, double[] predicted) {\n        double sum = 0.0;\n        for (int i = 0; i < actual.length; i++) {\n            sum += Math.abs(predicted[i] - actual[i]);\n        }\n        return sum / actual.length;\n    }\n\n    public static double calculateHuberLoss(double[] actual, double[] predicted, double delta) {\n        double sum = 0.0;\n        for (int i = 0; i < actual.length; i++) {\n            double absError = Math.abs(predicted[i] - actual[i]);\n            if (absError <= delta) {\n                sum += 0.5 * Math.pow(absError, 2);\n            } else {\n                sum += delta * (absError - 0.5 * delta);\n            }\n        }\n        return sum / actual.length;\n    }\n\n    public static void main(String[] args) {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        double delta = 1.0;\n\n        double mse = calculateMSE(actual, predicted);\n        double mae = calculateMAE(actual, predicted);\n        double huberLoss = calculateHuberLoss(actual, predicted, delta);\n\n        System.out.println(\"Mean Squared Error: \" + mse);\n        System.out.println(\"Mean Absolute Error: \" + mae);\n        System.out.println(\"Huber Loss: \" + huberLoss);\n    }\n}\n```"}
{"user_prompt": "创建一个名为 GameItem 的类，包含属性：道具名称、类型、数量。分别是String, String, int类型。\n创建一个名为 Inventory 的类，用于管理游戏道具。它应该能够添加道具、删除道具、查找道具，列出道具。\n函数名分别为：addItem(GameItem item)，removeItem(String itemName)，findItem(String itemName)，listItems()\n在main函数中测试GameItem和Inventory类，比如先新建两个gameitem并添加到inventory里面，然后listItems()，然后去寻找其中一个item，使用findItem函数。随后移除一个gameitem，然后再次listItems()。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建一个名为 GameItem 的类，包含属性：道具名称、类型、数量。分别是String, String, int类型。\n创建一个名为 Inventory 的类，用于管理游戏道具。它应该能够添加道具、删除道具、查找道具，列出道具。\n函数名分别为：addItem(GameItem item)，removeItem(String itemName)，findItem(String itemName)，listItems()\n在main函数中测试GameItem和Inventory类，比如先新建两个gameitem并添加到inventory里面，然后listItems()，然后去寻找其中一个item，使用findItem函数。随后移除一个gameitem，然后再次listItems()。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass q10Test {\n\n    @Test\n    public void testGameItemAndInventory() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        assertEquals(2, inventory.items.size());\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        assertNotNull(foundItem);\n        assertEquals(\"Potion\", foundItem.getName());\n\n        inventory.removeItem(\"Sword\");\n        assertEquals(1, inventory.items.size());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class q10Test {\n\n    @Test\n    public void testGameItemAndInventory() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        assertEquals(2, inventory.items.size());\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        assertNotNull(foundItem);\n        assertEquals(\"Potion\", foundItem.getName());\n\n        inventory.removeItem(\"Sword\");\n        assertEquals(1, inventory.items.size());\n    }\n}", "_id": 194, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass GameItem {\n    private String name;\n    private String type;\n    private int quantity;\n\n    public GameItem(String name, String type, int quantity) {\n        this.name = name;\n        this.type = type;\n        this.quantity = quantity;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public int getQuantity() {\n        return quantity;\n    }\n}\n\nclass Inventory {\n    List<GameItem> items;\n\n    public Inventory() {\n        items = new ArrayList<>();\n    }\n\n    public void addItem(GameItem item) {\n        items.add(item);\n    }\n\n    public void removeItem(String itemName) {\n        items.removeIf(item -> item.getName().equals(itemName));\n    }\n\n    public GameItem findItem(String itemName) {\n        for (GameItem item : items) {\n            if (item.getName().equals(itemName)) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    public void listItems() {\n        for (GameItem item : items) {\n            System.out.println(\"Name: \" + item.getName() + \", Type: \" + item.getType() + \", Quantity: \" + item.getQuantity());\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        inventory.listItems();\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        if (foundItem != null) {\n            System.out.println(\"Found item: \" + foundItem.getName());\n        }\n\n        inventory.removeItem(\"Sword\");\n        inventory.listItems();\n    }\n}\n```"}
{"user_prompt": "商店由N个销售区组成，并且销售区由M个干货架组成，货架上面又须要放置P种货物。请你善用继承分别编写商店、销售区、货架和货物的实体类，并利用泛型随机生成货物。货物包含id、名字和价格三个属性。最后首先按照销售区域号排序，区域号相同的按照货架号排序，打印展示货物", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n商店由N个销售区组成，并且销售区由M个干货架组成，货架上面又须要放置P种货物。请你善用继承分别编写商店、销售区、货架和货物的实体类，并利用泛型随机生成货物。货物包含id、名字和价格三个属性。最后首先按照销售区域号排序，区域号相同的按照货架号排序，打印展示货物\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MaxLCMGCDTest {\n\n\n    @Test\n    public void testWithNEqualTo1() {\n        assertEquals(0, MaxLCMGCD.maxLCMMinusGCD(1));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MaxLCMGCDTest {\n\n\n    @Test\n    public void testWithNEqualTo1() {\n        assertEquals(0, MaxLCMGCD.maxLCMMinusGCD(1));\n    }\n}", "_id": 195, "response": "```java\nimport java.util.*;\n\nclass Product implements Comparable<Product> {\n    int id;\n    String name;\n    double price;\n\n    public Product(int id, String name, double price) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n    }\n\n    @Override\n    public int compareTo(Product o) {\n        return this.id - o.id;\n    }\n}\n\nclass Shelf {\n    int id;\n    List<Product> products;\n\n    public Shelf(int id) {\n        this.id = id;\n        this.products = new ArrayList<>();\n    }\n\n    public void addProduct(Product product) {\n        this.products.add(product);\n    }\n\n    public List<Product> getProducts() {\n        return this.products;\n    }\n}\n\nclass SalesArea {\n    int id;\n    List<Shelf> shelves;\n\n    public SalesArea(int id) {\n        this.id = id;\n        this.shelves = new ArrayList<>();\n    }\n\n    public void addShelf(Shelf shelf) {\n        this.shelves.add(shelf);\n    }\n\n    public List<Shelf> getShelves() {\n        return this.shelves;\n    }\n}\n\nclass Store {\n    List<SalesArea> salesAreas;\n\n    public Store() {\n        this.salesAreas = new ArrayList<>();\n    }\n\n    public void addSalesArea(SalesArea salesArea) {\n        this.salesAreas.add(salesArea);\n    }\n\n    public List<SalesArea> getSalesAreas() {\n        return this.salesAreas;\n    }\n\n    public void printProducts() {\n        this.salesAreas.sort(Comparator.comparingInt(a -> a.id));\n        for (SalesArea area : salesAreas) {\n            area.getShelves().sort(Comparator.comparingInt(s -> s.id));\n            for (Shelf shelf : area.getShelves()) {\n                shelf.getProducts().sort(Comparator.comparingInt(p -> p.id));\n                for (Product product : shelf.getProducts()) {\n                    System.out.println(\"Area: \" + area.id + \", Shelf: \" + shelf.id + \", Product: \" + product.name + \", Price: \" + product.price);\n                }\n            }\n        }\n    }\n}\n```"}
{"user_prompt": "编写一个 Java 函数，使用正则表达式来验证一个字符串是否是有效的电子邮件地址。电子邮件地址的一般格式为 username@domain.com。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个 Java 函数，使用正则表达式来验证一个字符串是否是有效的电子邮件地址。电子邮件地址的一般格式为 username@domain.com。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ValidEmailTest {\n\n    @Test\n    void testIsValidEmail1() {\n        assertTrue(ValidEmail.isValidEmail(\"example@example.com\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class ValidEmailTest {\n\n    @Test\n    void testIsValidEmail1() {\n        assertTrue(ValidEmail.isValidEmail(\"example@example.com\"));\n    }\n}", "_id": 197, "response": "```java\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class ValidEmail {\n\n    public static boolean isValidEmail(String email) {\n        String emailRegex = \"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\";\n        Pattern pattern = Pattern.compile(emailRegex);\n        Matcher matcher = pattern.matcher(email);\n        return matcher.matches();\n    }\n}\n```"}
{"user_prompt": "异常检测的问题：考察对Exception的重写。\n创建一个简单的银行账户类 BankAccount，其中包含一个处理取款操作的方法。这个方法应该能够检测和抛出异常，比如当账户余额不足时。\n\n创建一个名为BankAccount的类，包含属性：账户余额。\n在BankAccount类中，实现一个withdraw方法，该方法接受一个取款金额参数。\n如果取款金额大于账户余额，方法应抛出一个自定义的异常 InsufficientFundsException。\n在 main 函数中，创建一个 BankAccount 对象，先往里面存500，然后取600，看看是否会调用到实现好的InsufficientFundsException并打印其报错信息。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n异常检测的问题：考察对Exception的重写。\n创建一个简单的银行账户类 BankAccount，其中包含一个处理取款操作的方法。这个方法应该能够检测和抛出异常，比如当账户余额不足时。\n\n创建一个名为BankAccount的类，包含属性：账户余额。\n在BankAccount类中，实现一个withdraw方法，该方法接受一个取款金额参数。\n如果取款金额大于账户余额，方法应抛出一个自定义的异常 InsufficientFundsException。\n在 main 函数中，创建一个 BankAccount 对象，先往里面存500，然后取600，看看是否会调用到实现好的InsufficientFundsException并打印其报错信息。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass q13Test {\n\n        @Test\n        void testWithdraw1() {\n            BankAccount account = new BankAccount(500.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(600.0));\n        }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class q13Test {\n\n        @Test\n        void testWithdraw1() {\n            BankAccount account = new BankAccount(500.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(600.0));\n        }\n}", "_id": 198, "response": "```java\nclass BankAccount {\n    private double balance;\n\n    public BankAccount(double balance) {\n        this.balance = balance;\n    }\n\n    public void withdraw(double amount) throws InsufficientFundsException {\n        if (amount > balance) {\n            throw new InsufficientFundsException(\"Insufficient funds in your account.\");\n        }\n        balance -= amount;\n    }\n}\n\nclass InsufficientFundsException extends Exception {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount(500.0);\n        try {\n            account.withdraw(600.0);\n        } catch (InsufficientFundsException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"}
{"user_prompt": "模拟报文的发送端和接收端，在接收到发送端的传输报文后，进行哈夫曼编码压缩，形成编码后报文并发送出去，然后再接收端进行解码，还原内容并打印显示出报文内容", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n模拟报文的发送端和接收端，在接收到发送端的传输报文后，进行哈夫曼编码压缩，形成编码后报文并发送出去，然后再接收端进行解码，还原内容并打印显示出报文内容\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass HuffmanTest {\n\n    @Test\n    void testEncodeAndDecode1() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"hello world\");\n        assertEquals(\"hello world\", huffman.recv());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class HuffmanTest {\n\n    @Test\n    void testEncodeAndDecode1() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"hello world\");\n        assertEquals(\"hello world\", huffman.recv());\n    }\n}", "_id": 196, "response": "```java\nimport java.util.*;\n\npublic class Huffman {\n    private static Map<Character, String> charPrefixHashMap = new HashMap<>();\n    private static Node root;\n\n    private static class Node implements Comparable<Node> {\n        Character ch;\n        Integer freq;\n        Node left = null, right = null;\n\n        Node(Character ch, Integer freq) {\n            this.ch = ch;\n            this.freq = freq;\n        }\n\n        public Node(Character ch, Integer freq, Node left, Node right) {\n            this.ch = ch;\n            this.freq = freq;\n            this.left = left;\n            this.right = right;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return this.freq.compareTo(o.freq);\n        }\n    }\n\n    private static void encode(Node root, String str) {\n        if (root == null) {\n            return;\n        }\n        if (root.left == null && root.right == null) {\n            charPrefixHashMap.put(root.ch, str);\n        }\n        encode(root.left, str + '0');\n        encode(root.right, str + '1');\n    }\n\n    private static void buildHuffmanTree(String text) {\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char c : text.toCharArray()) {\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\n        }\n\n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        for (Map.Entry<Character, Integer> entry : freqMap.entrySet()) {\n            pq.add(new Node(entry.getKey(), entry.getValue()));\n        }\n\n        while (pq.size() != 1) {\n            Node left = pq.poll();\n            Node right = pq.poll();\n            int sum = left.freq + right.freq;\n            pq.add(new Node(null, sum, left, right));\n        }\n\n        root = pq.peek();\n        encode(root, \"\");\n    }\n\n    public String send(String text) {\n        buildHuffmanTree(text);\n        StringBuilder sb = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            sb.append(charPrefixHashMap.get(c));\n        }\n        return sb.toString();\n    }\n\n    private static String decode(Node root, int index, StringBuilder sb) {\n        if (root == null) {\n            return \"\";\n        }\n        if (root.left == null && root.right == null) {\n            return String.valueOf(root.ch);\n        }\n        index++;\n        if (index >= sb.length()) {\n            return \"\";\n        }\n        root = (sb.charAt(index) == '0') ? root.left : root.right;\n        return decode(root, index, sb);\n    }\n\n    public String recv() {\n        StringBuilder sb = new StringBuilder();\n        int index = -1;\n        while (index < root.freq - 2) {\n            String ch = decode(root, index, sb);\n            sb.append(ch);\n            index += ch.length();\n        }\n        return sb.toString();\n    }\n}\n```"}
{"user_prompt": "Java中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "_id": 200, "response": "```java\npublic class StringUtils {\n\n    public static String alternateCase(String input) {\n        if (input == null || input.isEmpty()) {\n            return input;\n        }\n\n        char[] chars = input.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (i % 2 == 0) {\n                chars[i] = Character.toUpperCase(chars[i]);\n            } else {\n                chars[i] = Character.toLowerCase(chars[i]);\n            }\n        }\n\n        return new String(chars);\n    }\n}\n```"}
{"user_prompt": "请使用StringBuilder和StringBuffer，创建一个简单的Markdown解析器，它能够将特定的Markdown语法转换为HTML。你的任务是处理以下Markdown特性：\n\n# 开头的行转换为 <h1> 标签。\n## 开头的行转换为 <h2> 标签。\n* 开头的行（后跟空格）转换为 <li> 标签（列表项）。\n文本行（不符合上述情况）转换为 <p> 标签。\n注意，Markdown语法规定，每个标记（如#，##，*）后必须紧跟一个空格。\n\n输入：\n# Header 1\nThis is a paragraph.\n## Header 2\n* List item 1\n* List item 2\n\n输出：\n<h1>Header 1</h1>\n<p>This is a paragraph.</p>\n<h2>Header 2</h2>\n<ul>\n<li>List item 1</li>\n<li>List item 2</li>\n</ul>", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请使用StringBuilder和StringBuffer，创建一个简单的Markdown解析器，它能够将特定的Markdown语法转换为HTML。你的任务是处理以下Markdown特性：\n\n# 开头的行转换为 <h1> 标签。\n## 开头的行转换为 <h2> 标签。\n* 开头的行（后跟空格）转换为 <li> 标签（列表项）。\n文本行（不符合上述情况）转换为 <p> 标签。\n注意，Markdown语法规定，每个标记（如#，##，*）后必须紧跟一个空格。\n\n输入：\n# Header 1\nThis is a paragraph.\n## Header 2\n* List item 1\n* List item 2\n\n输出：\n<h1>Header 1</h1>\n<p>This is a paragraph.</p>\n<h2>Header 2</h2>\n<ul>\n<li>List item 1</li>\n<li>List item 2</li>\n</ul>\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MarkdownToHTMLTest {\n\n    @Test\n    void testParseMarkdown1() {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\";\n        String expected = \"<h1>Header 1</h1>\\n<p>This is a paragraph.</p>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MarkdownToHTMLTest {\n\n    @Test\n    void testParseMarkdown1() {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\";\n        String expected = \"<h1>Header 1</h1>\\n<p>This is a paragraph.</p>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n}", "_id": 199, "response": "```java\npublic class MarkdownToHTML {\n    public static String parseMarkdown(String markdown) {\n        StringBuilder html = new StringBuilder();\n        String[] lines = markdown.split(\"\\n\");\n        boolean isList = false;\n\n        for (String line : lines) {\n            if (line.startsWith(\"# \")) {\n                if (isList) {\n                    html.append(\"</ul>\\n\");\n                    isList = false;\n                }\n                html.append(\"<h1>\").append(line.substring(2)).append(\"</h1>\\n\");\n            } else if (line.startsWith(\"## \")) {\n                if (isList) {\n                    html.append(\"</ul>\\n\");\n                    isList = false;\n                }\n                html.append(\"<h2>\").append(line.substring(3)).append(\"</h2>\\n\");\n            } else if (line.startsWith(\"* \")) {\n                if (!isList) {\n                    html.append(\"<ul>\\n\");\n                    isList = true;\n                }\n                html.append(\"<li>\").append(line.substring(2)).append(\"</li>\\n\");\n            } else {\n                if (isList) {\n                    html.append(\"</ul>\\n\");\n                    isList = false;\n                }\n                html.append(\"<p>\").append(line).append(\"</p>\\n\");\n            }\n        }\n\n        if (isList) {\n            html.append(\"</ul>\\n\");\n        }\n\n        return html.toString();\n    }\n}\n```"}
