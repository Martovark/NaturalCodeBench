{"user_prompt": "课堂练习：设计一个接受数组的静态方法，数组的每个成员都是个位整数(8到9之间），该方法能以电话号码的形式返回包含这些数字的字符串。例如：\n createPhoneNumber ( new int []{1,2,3,4,5,6,7,8,9,0})//=> returns \"(123) 456-7890\"\n注：别忘了右括号后面的空格！", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n课堂练习：设计一个接受数组的静态方法，数组的每个成员都是个位整数(8到9之间），该方法能以电话号码的形式返回包含这些数字的字符串。例如：\n createPhoneNumber ( new int []{1,2,3,4,5,6,7,8,9,0})//=> returns \"(123) 456-7890\"\n注：别忘了右括号后面的空格！\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCreatePhoneNumber1() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCreatePhoneNumber1() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n}", "_id": 131, "response": "```java\npublic class PhoneNumberCreator {\n\n    public static String createPhoneNumber(int[] numbers) {\n        if (numbers == null || numbers.length != 10) {\n            throw new IllegalArgumentException(\"Array must contain exactly 10 numbers.\");\n        }\n\n        for (int number : numbers) {\n            if (number < 0 || number > 9) {\n                throw new IllegalArgumentException(\"Each number must be a single digit between 0 and 9.\");\n            }\n        }\n\n        return String.format(\"(%d%d%d) %d%d%d-%d%d%d%d\",\n                numbers[0], numbers[1], numbers[2], numbers[3], numbers[4],\n                numbers[5], numbers[6], numbers[7], numbers[8], numbers[9]);\n    }\n}\n```"}
{"user_prompt": "问题：我们公司的产品有一个功能是医生和患者可以相互发送对话消息，现在需要计算某个医生和某个患者之间对话的来回，来回的定义是对话双方有一方发了消息，另一方需要有回复才算是一个来回。举例：假定医生发了消息用a来表示，患者发了消息用b来表示，则按照定义ab算1个来回，abb、aba、aab、aabb也均算1个来回，abab、abba，abbba则算2个来回。\n期望：用java实现一个完整的方法，输入是某个医生和某个患者的对话列表（结构自定义），输出是对话来回的个数；要求代码思路清晰，逻辑严谨，有边界值判断。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n问题：我们公司的产品有一个功能是医生和患者可以相互发送对话消息，现在需要计算某个医生和某个患者之间对话的来回，来回的定义是对话双方有一方发了消息，另一方需要有回复才算是一个来回。举例：假定医生发了消息用a来表示，患者发了消息用b来表示，则按照定义ab算1个来回，abb、aba、aab、aabb也均算1个来回，abab、abba，abbba则算2个来回。\n期望：用java实现一个完整的方法，输入是某个医生和某个患者的对话列表（结构自定义），输出是对话来回的个数；要求代码思路清晰，逻辑严谨，有边界值判断。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCountConversationTurns1() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(3, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCountConversationTurns1() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(3, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n}", "_id": 132, "response": "```java\nimport java.util.List;\n\npublic class Conversation {\n    private String sender;\n\n    public Conversation(String sender) {\n        this.sender = sender;\n    }\n\n    public String getSender() {\n        return sender;\n    }\n}\n\nclass ConversationCounter {\n    public static int countConversationTurns(List<Conversation> conversations, String doctor, String patient) {\n        if (conversations == null || conversations.isEmpty()) {\n            return 0;\n        }\n\n        int turns = 0;\n        String lastSender = null;\n\n        for (Conversation conversation : conversations) {\n            String currentSender = conversation.getSender();\n            // Check if the sender is either doctor or patient and if the last sender is not the same as the current one\n            if ((currentSender.equals(doctor) || currentSender.equals(patient)) && (lastSender == null || !lastSender.equals(currentSender))) {\n                // If the last sender is not null, it means we have a turn\n                if (lastSender != null) {\n                    turns++;\n                }\n                lastSender = currentSender;\n            }\n        }\n\n        // If the last message was not responded to, it does not count as a turn\n        return turns;\n    }\n}\n```"}
{"user_prompt": "我想从这个字符串，\"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\",在出现订单两个字以后，出现的第一个字母或英文的字符串提取出来。请用java的正则表达式来实现。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n我想从这个字符串，\"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\",在出现订单两个字以后，出现的第一个字母或英文的字符串提取出来。请用java的正则表达式来实现。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(\"e\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: e123456\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(\"e\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: e123456\"));\n    }\n}", "_id": 133, "response": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n    public static String findFirstAlphabeticStringAfterOrder(String text) {\n        Pattern pattern = Pattern.compile(\"订单.*?([a-zA-Z]+)\");\n        Matcher matcher = pattern.matcher(text);\n        if (matcher.find()) {\n            return matcher.group(1);\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        String input = \"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\";\n        String result = findFirstAlphabeticStringAfterOrder(input);\n        System.out.println(result); // Should print \"e\"\n    }\n}\n```"}
{"user_prompt": "1、在用户管理类（UserManager），通过ArrayList提供用户管理服务。\n\n2、在UserManager类中定义一个ArrayList的属性users;\n\n3、UserManager类中定义如下几个方法操作users中的用户(参照main方法中UserManager类的调用方法编写)：\n\n（1）添加用户addUser方法，向users中添加一个用户信息。\n\n（2）删除用户deleteUser方法，从users中删除一个用户信息。\n\n（3）判断一个用户是否存在isExist方法，判断users中是否存在该用户。\n\n（4）显示所有用户信息display方法：直接输出user对象信息。\n\n3、直接运行程序，显示如下运行结果。\n\n\n\n输出结果为：\n\nname is:alice\n\nname is:john", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1、在用户管理类（UserManager），通过ArrayList提供用户管理服务。\n\n2、在UserManager类中定义一个ArrayList的属性users;\n\n3、UserManager类中定义如下几个方法操作users中的用户(参照main方法中UserManager类的调用方法编写)：\n\n（1）添加用户addUser方法，向users中添加一个用户信息。\n\n（2）删除用户deleteUser方法，从users中删除一个用户信息。\n\n（3）判断一个用户是否存在isExist方法，判断users中是否存在该用户。\n\n（4）显示所有用户信息display方法：直接输出user对象信息。\n\n3、直接运行程序，显示如下运行结果。\n\n\n\n输出结果为：\n\nname is:alice\n\nname is:john\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddUser() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        assertTrue(userManager.isExist(alice));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testAddUser() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        assertTrue(userManager.isExist(alice));\n    }\n}", "_id": 134, "response": "```java\nimport java.util.ArrayList;\n\nclass User {\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return \"name is:\" + name;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        User user = (User) obj;\n        return name != null ? name.equals(user.name) : user.name == null;\n    }\n\n    @Override\n    public int hashCode() {\n        return name != null ? name.hashCode() : 0;\n    }\n}\n\nclass UserManager {\n    private ArrayList<User> users;\n\n    public UserManager() {\n        users = new ArrayList<>();\n    }\n\n    public void addUser(User user) {\n        users.add(user);\n    }\n\n    public void deleteUser(User user) {\n        users.remove(user);\n    }\n\n    public boolean isExist(User user) {\n        return users.contains(user);\n    }\n\n    public void display() {\n        for (User user : users) {\n            System.out.println(user);\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        User john = new User(\"john\");\n\n        userManager.addUser(alice);\n        userManager.addUser(john);\n        userManager.display();\n\n        userManager.deleteUser(alice);\n        userManager.addUser(alice);\n        userManager.display();\n    }\n}\n```"}
{"user_prompt": "、\n\n请按照以下要求设计一个学生类Student。\n\n要求如下：\n\n\n1）学生类有五个属性，分别是姓名(name)、学号 (userID)、数学成绩（math）、语文成绩（chinese）、英语成绩（english）\n\n\n2）使用封装的思想将所有属性私有化，对外界提供共有的访问方法。至少包括输入学生信息，计算总分和平均分的方法，并在适当的方法中对输入的成绩值进行判断，仅允许合法有效成绩（0~100）的录入。（注：设置各属性的方法和获取各属性的方法，以及构造方法可以根据自己的类设计自行选择定义）\n3）在main()方法中，创建Student的实例对象，显示该学生（你）的相关信息（姓名、学号，及成绩）。请帮我写个代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n、\n\n请按照以下要求设计一个学生类Student。\n\n要求如下：\n\n\n1）学生类有五个属性，分别是姓名(name)、学号 (userID)、数学成绩（math）、语文成绩（chinese）、英语成绩（english）\n\n\n2）使用封装的思想将所有属性私有化，对外界提供共有的访问方法。至少包括输入学生信息，计算总分和平均分的方法，并在适当的方法中对输入的成绩值进行判断，仅允许合法有效成绩（0~100）的录入。（注：设置各属性的方法和获取各属性的方法，以及构造方法可以根据自己的类设计自行选择定义）\n3）在main()方法中，创建Student的实例对象，显示该学生（你）的相关信息（姓名、学号，及成绩）。请帮我写个代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\nvoid testStudent1() {\n    Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n    assertEquals(\"John Doe\", student.getName());\n    assertEquals(\"123456\", student.getUserID());\n    assertEquals(85.5, student.getMath());\n    assertEquals(90.0, student.getChinese());\n    assertEquals(88.0, student.getEnglish());\n    assertEquals(263.5, student.getTotalScore());\n    assertEquals(87.83, student.getAverageScore(), 0.01);\n}\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n@Test\nvoid testStudent1() {\n    Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n    assertEquals(\"John Doe\", student.getName());\n    assertEquals(\"123456\", student.getUserID());\n    assertEquals(85.5, student.getMath());\n    assertEquals(90.0, student.getChinese());\n    assertEquals(88.0, student.getEnglish());\n    assertEquals(263.5, student.getTotalScore());\n    assertEquals(87.83, student.getAverageScore(), 0.01);\n}\n}", "_id": 135, "response": "```java\npublic class Student {\n    private String name;\n    private String userID;\n    private double math;\n    private double chinese;\n    private double english;\n\n    public Student(String name, String userID, double math, double chinese, double english) {\n        this.name = name;\n        this.userID = userID;\n        setMath(math);\n        setChinese(chinese);\n        setEnglish(english);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getUserID() {\n        return userID;\n    }\n\n    public double getMath() {\n        return math;\n    }\n\n    public void setMath(double math) {\n        if (isValidScore(math)) {\n            this.math = math;\n        } else {\n            throw new IllegalArgumentException(\"Invalid math score\");\n        }\n    }\n\n    public double getChinese() {\n        return chinese;\n    }\n\n    public void setChinese(double chinese) {\n        if (isValidScore(chinese)) {\n            this.chinese = chinese;\n        } else {\n            throw new IllegalArgumentException(\"Invalid chinese score\");\n        }\n    }\n\n    public double getEnglish() {\n        return english;\n    }\n\n    public void setEnglish(double english) {\n        if (isValidScore(english)) {\n            this.english = english;\n        } else {\n            throw new IllegalArgumentException(\"Invalid english score\");\n        }\n    }\n\n    public double getTotalScore() {\n        return math + chinese + english;\n    }\n\n    public double getAverageScore() {\n        return getTotalScore() / 3;\n    }\n\n    private boolean isValidScore(double score) {\n        return score >= 0 && score <= 100;\n    }\n\n    public static void main(String[] args) {\n        Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n        System.out.println(\"Name: \" + student.getName());\n        System.out.println(\"UserID: \" + student.getUserID());\n        System.out.println(\"Math Score: \" + student.getMath());\n        System.out.println(\"Chinese Score: \" + student.getChinese());\n        System.out.println(\"English Score: \" + student.getEnglish());\n        System.out.println(\"Total Score: \" + student.getTotalScore());\n        System.out.printf(\"Average Score: %.2f\\n\", student.getAverageScore());\n    }\n}\n```"}
{"user_prompt": "编写一个java方法，要求实现以下功能：\n1、输入值为3个占比值和1个总数值，三个占比值的总数相加约等于1，每个占比值的小数位为两位;\n2、方法内分别计算3个占比值与总数值的乘积，乘积取整数，计算后检查三个乘积值相加是否等于输入的总数值，如果不等于，按照占比值的大小继续分配数值，直到三个乘积值相加等于总数值，最后输出这三个乘积值", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个java方法，要求实现以下功能：\n1、输入值为3个占比值和1个总数值，三个占比值的总数相加约等于1，每个占比值的小数位为两位;\n2、方法内分别计算3个占比值与总数值的乘积，乘积取整数，计算后检查三个乘积值相加是否等于输入的总数值，如果不等于，按照占比值的大小继续分配数值，直到三个乘积值相加等于总数值，最后输出这三个乘积值\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCalculateProportion1() {\n        assertArrayEquals(new int[]{30, 40, 30}, Main.calculateProportion(0.3, 0.4, 0.3, 100));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCalculateProportion1() {\n        assertArrayEquals(new int[]{30, 40, 30}, Main.calculateProportion(0.3, 0.4, 0.3, 100));\n    }\n}", "_id": 137, "response": "```java\npublic class Main {\n\n    public static int[] calculateProportion(double proportion1, double proportion2, double proportion3, int total) {\n        int[] products = new int[3];\n        products[0] = (int) Math.floor(proportion1 * total);\n        products[1] = (int) Math.floor(proportion2 * total);\n        products[2] = (int) Math.floor(proportion3 * total);\n\n        int sumOfProducts = products[0] + products[1] + products[2];\n        int remainder = total - sumOfProducts;\n\n        while (remainder > 0) {\n            if (proportion1 >= proportion2 && proportion1 >= proportion3) {\n                products[0]++;\n            } else if (proportion2 >= proportion1 && proportion2 >= proportion3) {\n                products[1]++;\n            } else {\n                products[2]++;\n            }\n            remainder--;\n        }\n\n        return products;\n    }\n\n    public static void main(String[] args) {\n        int[] result = calculateProportion(0.3, 0.4, 0.3, 100);\n        for (int value : result) {\n            System.out.println(value);\n        }\n    }\n}\n```"}
{"user_prompt": "描述：\nToDoList是一个用户任务清单应用程序。用户可以通过该程序查看、添加、删除任务项目。\n设ToDoList包含固定任务条目，共10个。在不足10项任务时，显示空白。\n\n要求：\n1. 创建类Task，以表示一个任务项目。Task包括名称、截止完成时间两个属性。\n2. 创建类Model，以表示ToDoList中的10项任务列表数据（即10个Task）。\n3. 创建类Controller，以控制其它代码执行，包括查看、添加、删除任务项目。\n4. 创建main方法依次测试查看、添加、删除3个功能。\n\n用java写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n描述：\nToDoList是一个用户任务清单应用程序。用户可以通过该程序查看、添加、删除任务项目。\n设ToDoList包含固定任务条目，共10个。在不足10项任务时，显示空白。\n\n要求：\n1. 创建类Task，以表示一个任务项目。Task包括名称、截止完成时间两个属性。\n2. 创建类Model，以表示ToDoList中的10项任务列表数据（即10个Task）。\n3. 创建类Controller，以控制其它代码执行，包括查看、添加、删除任务项目。\n4. 创建main方法依次测试查看、添加、删除3个功能。\n\n用java写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        assertEquals(\"Task 1\", model.tasks.get(0).name);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testAddTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        assertEquals(\"Task 1\", model.tasks.get(0).name);\n    }\n}", "_id": 136, "response": "```java\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\nclass Task {\n    String name;\n    Date deadline;\n\n    public Task(String name, Date deadline) {\n        this.name = name;\n        this.deadline = deadline;\n    }\n}\n\nclass Model {\n    List<Task> tasks;\n\n    public Model() {\n        tasks = new ArrayList<>(10);\n        for (int i = 0; i < 10; i++) {\n            tasks.add(null); // Initialize with null to represent empty tasks\n        }\n    }\n\n    public void addTask(Task task) {\n        for (int i = 0; i < 10; i++) {\n            if (tasks.get(i) == null) {\n                tasks.set(i, task);\n                return;\n            }\n        }\n    }\n\n    public void deleteTask(String taskName) {\n        for (int i = 0; i < 10; i++) {\n            Task task = tasks.get(i);\n            if (task != null && task.name.equals(taskName)) {\n                tasks.set(i, null);\n                return;\n            }\n        }\n    }\n\n    public List<Task> getTasks() {\n        return tasks;\n    }\n}\n\nclass Controller {\n    Model model;\n\n    public Controller(Model model) {\n        this.model = model;\n    }\n\n    public void addTask(String name, Date deadline) {\n        Task task = new Task(name, deadline);\n        model.addTask(task);\n    }\n\n    public void deleteTask(String name) {\n        model.deleteTask(name);\n    }\n\n    public void viewTasks() {\n        List<Task> tasks = model.getTasks();\n        for (Task task : tasks) {\n            if (task != null) {\n                System.out.println(\"Task: \" + task.name + \" - Deadline: \" + task.deadline);\n            } else {\n                System.out.println(\"Empty task slot.\");\n            }\n        }\n    }\n}\n\npublic class ToDoListApp {\n    public static void main(String[] args) {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n\n        // View tasks (initially all empty)\n        controller.viewTasks();\n\n        // Add tasks\n        controller.addTask(\"Task 1\", new Date());\n        controller.addTask(\"Task 2\", new Date());\n\n        // View tasks after adding\n        controller.viewTasks();\n\n        // Delete a task\n        controller.deleteTask(\"Task 1\");\n\n        // View tasks after deletion\n        controller.viewTasks();\n    }\n}\n```"}
{"user_prompt": "输入一个字符串，打印出该字符串中字符的所有排列。\n\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\n\nabc、acb、bac、bca、cab 和 cba。用java写出来", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\n\nabc、acb、bac、bca、cab 和 cba。用java写出来\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(Set.of(\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"), generatePermutations(\"abc\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(Set.of(\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"), generatePermutations(\"abc\"));\n    }\n}", "_id": 138, "response": "```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        String input = \"abc\";\n        Set<String> permutations = generatePermutations(input);\n        for (String permutation : permutations) {\n            System.out.println(permutation);\n        }\n    }\n\n    public static Set<String> generatePermutations(String str) {\n        Set<String> result = new HashSet<>();\n        permute(str, 0, str.length() - 1, result);\n        return result;\n    }\n\n    private static void permute(String str, int left, int right, Set<String> result) {\n        if (left == right) {\n            result.add(str);\n        } else {\n            for (int i = left; i <= right; i++) {\n                str = swap(str, left, i);\n                permute(str, left + 1, right, result);\n                str = swap(str, left, i); // backtrack\n            }\n        }\n    }\n\n    private static String swap(String a, int i, int j) {\n        char[] charArray = a.toCharArray();\n        char temp = charArray[i];\n        charArray[i] = charArray[j];\n        charArray[j] = temp;\n        return String.valueOf(charArray);\n    }\n}\n```"}
{"user_prompt": "1. 设计程序，定义一个表示 学生”的类：Student： 类中的属性有： a）name：String型，代表学生的名字; b）ordinary: double 型，代表学生的平时成绩； c）attendance： double型，代表学生的出勤率。 类中的方法有： a）boolean qualified()：根据平时成绩和出勤率计算并返回学生的考试资格，如果平时成绩≥ 60 并且出勤率≥60% ，则返回true ，否则返回false; ", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1. 设计程序，定义一个表示 学生”的类：Student： 类中的属性有： a）name：String型，代表学生的名字; b）ordinary: double 型，代表学生的平时成绩； c）attendance： double型，代表学生的出勤率。 类中的方法有： a）boolean qualified()：根据平时成绩和出勤率计算并返回学生的考试资格，如果平时成绩≥ 60 并且出勤率≥60% ，则返回true ，否则返回false; \n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testQualified1() {\n        Student student = new Student(\"John\", 70, 0.7);\n        assertTrue(student.qualified());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testQualified1() {\n        Student student = new Student(\"John\", 70, 0.7);\n        assertTrue(student.qualified());\n    }\n}", "_id": 139, "response": "```java\npublic class Student {\n    private String name;\n    private double ordinary;\n    private double attendance;\n\n    public Student(String name, double ordinary, double attendance) {\n        this.name = name;\n        this.ordinary = ordinary;\n        this.attendance = attendance;\n    }\n\n    public boolean qualified() {\n        return ordinary >= 60 && attendance >= 0.6;\n    }\n\n    // Getters and Setters for name, ordinary, and attendance if needed\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getOrdinary() {\n        return ordinary;\n    }\n\n    public void setOrdinary(double ordinary) {\n        this.ordinary = ordinary;\n    }\n\n    public double getAttendance() {\n        return attendance;\n    }\n\n    public void setAttendance(double attendance) {\n        this.attendance = attendance;\n    }\n}\n```"}
{"user_prompt": "编写一个方法，名字是showQianFenWei(long x),用于把x用千分位展示出来，也就是从低位开始，每隔3位就添加一个逗号，比如：\n\nx=2，结果是：2\n\nx=100，结果是100\n\nx=1000，结果是1,000\n\nx=10000，结果是10,000\n\nx=1000000，结果是1,000,000\n\nx不超过15位。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个方法，名字是showQianFenWei(long x),用于把x用千分位展示出来，也就是从低位开始，每隔3位就添加一个逗号，比如：\n\nx=2，结果是：2\n\nx=100，结果是100\n\nx=1000，结果是1,000\n\nx=10000，结果是10,000\n\nx=1000000，结果是1,000,000\n\nx不超过15位。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testShowQianFenWei() {\n        assertEquals(\"2\", Main.showQianFenWei(2));\n        assertEquals(\"100\", Main.showQianFenWei(100));\n        assertEquals(\"1,000\", Main.showQianFenWei(1000));\n        assertEquals(\"10,000\", Main.showQianFenWei(10000));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testShowQianFenWei() {\n        assertEquals(\"2\", Main.showQianFenWei(2));\n        assertEquals(\"100\", Main.showQianFenWei(100));\n        assertEquals(\"1,000\", Main.showQianFenWei(1000));\n        assertEquals(\"10,000\", Main.showQianFenWei(10000));\n    }\n}", "_id": 140, "response": "```java\npublic class Main {\n    public static String showQianFenWei(long x) {\n        if (x < 0) {\n            return \"-\" + showQianFenWei(-x);\n        }\n        String result = Long.toString(x);\n        StringBuilder sb = new StringBuilder();\n        int length = result.length();\n        for (int i = 0; i < length; i++) {\n            if (i > 0 && (length - i) % 3 == 0) {\n                sb.append(\",\");\n            }\n            sb.append(result.charAt(i));\n        }\n        return sb.toString();\n    }\n}\n```"}
{"user_prompt": "创建⼀个search⽅法，⽤以在给定的⾃然语⾔⽂本⽂件中搜索某个关键词出现的总次数。关键词是⼀个英⽂单词，\n例如\"go\"。⽂件中和关键词匹配的单词不区分⼤⼩写，例如GO、Go、gO、go 都算出现⼀次。同时关键词可能包\n含⼤写或⼩写字⺟。但是单词是需要完整匹配的，也就是说 google 这样的单词不算出现了go。除此之外，What’s\n这样的字符串中算出现了 what，但没有出现 is，同时只有\"what\"会作为搜索的关键词⽽\"what's\"不会。Three\u0002year-old中同时出现了three、year和 old。总结来说，单词指的是连续出现的⼤/⼩写字⺟，且单词的前⼀个和后\n⼀个字符（如果存在的话）都必须不是⼤/⼩写字⺟。使用java实现", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建⼀个search⽅法，⽤以在给定的⾃然语⾔⽂本⽂件中搜索某个关键词出现的总次数。关键词是⼀个英⽂单词，\n例如\"go\"。⽂件中和关键词匹配的单词不区分⼤⼩写，例如GO、Go、gO、go 都算出现⼀次。同时关键词可能包\n含⼤写或⼩写字⺟。但是单词是需要完整匹配的，也就是说 google 这样的单词不算出现了go。除此之外，What’s\n这样的字符串中算出现了 what，但没有出现 is，同时只有\"what\"会作为搜索的关键词⽽\"what's\"不会。Three\u0002year-old中同时出现了three、year和 old。总结来说，单词指的是连续出现的⼤/⼩写字⺟，且单词的前⼀个和后\n⼀个字符（如果存在的话）都必须不是⼤/⼩写字⺟。使用java实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSearch1() {\n        assertEquals(4, KeywordSearch.search(\"testFile1.txt\", \"go\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSearch1() {\n        assertEquals(4, KeywordSearch.search(\"testFile1.txt\", \"go\"));\n    }\n}", "_id": 141, "response": "```java\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class KeywordSearch {\n\n    public static int search(String filePath, String keyword) {\n        int count = 0;\n        Pattern pattern = Pattern.compile(\"\\\\b\" + Pattern.quote(keyword) + \"\\\\b\", Pattern.CASE_INSENSITIVE);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                Matcher matcher = pattern.matcher(line);\n                while (matcher.find()) {\n                    count++;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return count;\n    }\n}\n```"}
{"user_prompt": "对一个整数数组，如果该数组为空，则返回零；如果其长度为1，则返回第一个元素。如果整\n数数组的长度大于等于 51，则返回其第51个元素；否则，如果其长度大于等于(51/2向下取整）\n，则返回第(51/2向下取整）个元素;否则，如果其长度大于等于(51/4向下取整，则返回第\n(51/4向下取整）个元素；否则，如果其长度大于等于(51/8向下取整），则返回第（51/8向下取\n整)个元素…以此类推，比较后返回符合要求的元素。  例子：输入 数组1到25 输出25 Java语言实现", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对一个整数数组，如果该数组为空，则返回零；如果其长度为1，则返回第一个元素。如果整\n数数组的长度大于等于 51，则返回其第51个元素；否则，如果其长度大于等于(51/2向下取整）\n，则返回第(51/2向下取整）个元素;否则，如果其长度大于等于(51/4向下取整，则返回第\n(51/4向下取整）个元素；否则，如果其长度大于等于(51/8向下取整），则返回第（51/8向下取\n整)个元素…以此类推，比较后返回符合要求的元素。  例子：输入 数组1到25 输出25 Java语言实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetElement1() {\n        int[] array = new int[25];\n        for (int i = 0; i < 25; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(25, ArrayElementSelector.selectElement(array));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testGetElement1() {\n        int[] array = new int[25];\n        for (int i = 0; i < 25; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(25, ArrayElementSelector.selectElement(array));\n    }\n}", "_id": 142, "response": "```java\npublic class ArrayElementSelector {\n    public static int selectElement(int[] array) {\n        if (array == null || array.length == 0) {\n            return 0;\n        } else if (array.length == 1) {\n            return array[0];\n        } else {\n            int threshold = 51;\n            while (threshold > array.length && threshold > 1) {\n                threshold /= 2;\n            }\n            return array[threshold - 1];\n        }\n    }\n}\n```"}
{"user_prompt": "读入 n 阶方阵 a , 计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和.\n说明：副对角线为从矩阵的右上角至左下角的连线，例\n2 3 4 1\n5 6 1 1\n7 1 8 1\n1 1 1 1\nsum=35   (2+3+4+5+6+7+8=35)\n用Java写一个简单的程序", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n读入 n 阶方阵 a , 计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和.\n说明：副对角线为从矩阵的右上角至左下角的连线，例\n2 3 4 1\n5 6 1 1\n7 1 8 1\n1 1 1 1\nsum=35   (2+3+4+5+6+7+8=35)\n用Java写一个简单的程序\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCalculateSum1() {\n        int[][] matrix = {{2, 3, 4, 1}, {5, 6, 1, 1}, {7, 1, 8, 1}, {1, 1, 1, 1}};\n        assertEquals(35, Main.calculateSum(matrix, 4));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCalculateSum1() {\n        int[][] matrix = {{2, 3, 4, 1}, {5, 6, 1, 1}, {7, 1, 8, 1}, {1, 1, 1, 1}};\n        assertEquals(35, Main.calculateSum(matrix, 4));\n    }\n}", "_id": 143, "response": "```java\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] matrix = new int[n][n];\n\n        // Read the matrix from input\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = scanner.nextInt();\n            }\n        }\n\n        // Calculate the sum\n        int sum = calculateSum(matrix, n);\n        System.out.println(sum);\n    }\n\n    public static int calculateSum(int[][] matrix, int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                // Exclude the last row, last column, and the anti-diagonal\n                if (i != n - 1 && j != n - 1 && i + j != n - 1) {\n                    sum += matrix[i][j];\n                }\n            }\n        }\n        return sum;\n    }\n}\n```"}
{"user_prompt": "使用java实现一个闹钟系统AlarmSystem，简单来说就是实现三个方法addAlarm: 添加而钟，包括属性id、weekday[]、hour、minute，typeld。其中weekdays表示在星明几响起，可能的取值为1-7.typeld表示闹钟的类型，可能的取值为0，1，2。如果之前已经添加过相局id的两钟则不再添加。返回false，否则返回true deleteAlarm: 根据id删除闹钟。如果不存在此id的闹钟，则返回false，否则删除后返回truequeryAlarm: 给定weekday，hour，startminute、endminute，查询在weekday这一天，hour这一小时。startminute到endminute之间会响起的闹钟，如果有多个则优先按照响起的时间先后排序输出，如果响起时间一样，则按照闹钟的类型从小到大排序，如果闹钟类型也一样，则按照id从小到大排序", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用java实现一个闹钟系统AlarmSystem，简单来说就是实现三个方法addAlarm: 添加而钟，包括属性id、weekday[]、hour、minute，typeld。其中weekdays表示在星明几响起，可能的取值为1-7.typeld表示闹钟的类型，可能的取值为0，1，2。如果之前已经添加过相局id的两钟则不再添加。返回false，否则返回true deleteAlarm: 根据id删除闹钟。如果不存在此id的闹钟，则返回false，否则删除后返回truequeryAlarm: 给定weekday，hour，startminute、endminute，查询在weekday这一天，hour这一小时。startminute到endminute之间会响起的闹钟，如果有多个则优先按照响起的时间先后排序输出，如果响起时间一样，则按照闹钟的类型从小到大排序，如果闹钟类型也一样，则按照id从小到大排序\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\npublic void testAddAlarm() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    assertTrue(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n    assertFalse(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n}\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n@Test\npublic void testAddAlarm() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    assertTrue(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n    assertFalse(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n}\n}", "_id": 144, "response": "```java\nimport java.util.*;\n\nclass Alarm {\n    int id;\n    Set<Integer> weekdays;\n    int hour;\n    int minute;\n    int typeId;\n\n    public Alarm(int id, Set<Integer> weekdays, int hour, int minute, int typeId) {\n        this.id = id;\n        this.weekdays = weekdays;\n        this.hour = hour;\n        this.minute = minute;\n        this.typeId = typeId;\n    }\n}\n\nclass AlarmSystem {\n    private final Map<Integer, Alarm> alarms;\n\n    public AlarmSystem() {\n        alarms = new HashMap<>();\n    }\n\n    public boolean addAlarm(int id, Set<Integer> weekdays, int hour, int minute, int typeId) {\n        if (alarms.containsKey(id)) {\n            return false;\n        }\n        Alarm alarm = new Alarm(id, weekdays, hour, minute, typeId);\n        alarms.put(id, alarm);\n        return true;\n    }\n\n    public boolean deleteAlarm(int id) {\n        if (!alarms.containsKey(id)) {\n            return false;\n        }\n        alarms.remove(id);\n        return true;\n    }\n\n    public List<Alarm> queryAlarm(int weekday, int hour, int startMinute, int endMinute) {\n        List<Alarm> result = new ArrayList<>();\n        for (Alarm alarm : alarms.values()) {\n            if (alarm.weekdays.contains(weekday) && alarm.hour == hour && alarm.minute >= startMinute && alarm.minute <= endMinute) {\n                result.add(alarm);\n            }\n        }\n        result.sort((a1, a2) -> {\n            if (a1.minute != a2.minute) {\n                return Integer.compare(a1.minute, a2.minute);\n            } else if (a1.typeId != a2.typeId) {\n                return Integer.compare(a1.typeId, a2.typeId);\n            } else {\n                return Integer.compare(a1.id, a2.id);\n            }\n        });\n        return result;\n    }\n}\n```"}
{"user_prompt": "需求：\n1. 实现 select xx from xx [where xx = xx [order by xx] [limit xx]] 等条件查询的解析\n中括号的部分表示是可选的，请给出 java 代码实现。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n需求：\n1. 实现 select xx from xx [where xx = xx [order by xx] [limit xx]] 等条件查询的解析\n中括号的部分表示是可选的，请给出 java 代码实现。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    public void testSelectFrom() {\n        SQLParser parser = new SQLParser(\"select name from users\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    public void testSelectFrom() {\n        SQLParser parser = new SQLParser(\"select name from users\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n}", "_id": 145, "response": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SQLParser {\n    private String select;\n    private String from;\n    private String where;\n    private String orderBy;\n    private Integer limit;\n\n    private static final Pattern QUERY_PATTERN = Pattern.compile(\n            \"select\\\\s+(?<select>[\\\\w*,\\\\s]+)\\\\s+\" +\n            \"from\\\\s+(?<from>\\\\w+)\" +\n            \"(?:\\\\s+where\\\\s+(?<where>\\\\w+\\\\s*=\\\\s*\\\\w+))?\" +\n            \"(?:\\\\s+order by\\\\s+(?<orderBy>\\\\w+))?\" +\n            \"(?:\\\\s+limit\\\\s+(?<limit>\\\\d+))?\",\n            Pattern.CASE_INSENSITIVE\n    );\n\n    public SQLParser(String query) {\n        Matcher matcher = QUERY_PATTERN.matcher(query);\n        if (matcher.find()) {\n            this.select = matcher.group(\"select\").trim();\n            this.from = matcher.group(\"from\").trim();\n            this.where = matcher.group(\"where\") != null ? matcher.group(\"where\").trim() : null;\n            this.orderBy = matcher.group(\"orderBy\") != null ? matcher.group(\"orderBy\").trim() : null;\n            this.limit = matcher.group(\"limit\") != null ? Integer.parseInt(matcher.group(\"limit\").trim()) : null;\n        }\n    }\n\n    public String getSelect() {\n        return select;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public String getWhere() {\n        return where;\n    }\n\n    public String getOrderBy() {\n        return orderBy;\n    }\n\n    public Integer getLimit() {\n        return limit;\n    }\n}\n```"}
{"user_prompt": "JAVA顺序表\n编写一个程序，实现顺序表的各种基本运算和整体建表算法（假设顺序表的元素类型为\n ElemType 为 char )，并在此基础上设计一个程序完成以下功能：\n(1）初始化顺序表 L ;\n(2)创建顺序表 L ;\n(3)输出顺序表 L ;\n(4)输出顺序表 L 的长度；\n(5)判断顺序表 L 是否为空；\n(6)输出顺序表 L 的第3个元素；\n(7)输出某一个元素的位置；\n(8)在第4个元素的位置上插入元素 f ;\n(9)输出顺序表 L ;\n(10）删除顺序表 L 的第3个元素；\n(11）输出顺序表 L ;\n(12）释放顺序表 L 。\n2单链表", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJAVA顺序表\n编写一个程序，实现顺序表的各种基本运算和整体建表算法（假设顺序表的元素类型为\n ElemType 为 char )，并在此基础上设计一个程序完成以下功能：\n(1）初始化顺序表 L ;\n(2)创建顺序表 L ;\n(3)输出顺序表 L ;\n(4)输出顺序表 L 的长度；\n(5)判断顺序表 L 是否为空；\n(6)输出顺序表 L 的第3个元素；\n(7)输出某一个元素的位置；\n(8)在第4个元素的位置上插入元素 f ;\n(9)输出顺序表 L ;\n(10）删除顺序表 L 的第3个元素；\n(11）输出顺序表 L ;\n(12）释放顺序表 L 。\n2单链表\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSeqList() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c', 'd', 'e'});\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('d'); add('e');}}, L.list);\n        assertEquals(5, L.getLength());\n        assertFalse(L.isEmpty());\n        assertEquals('c', L.getElement(2));\n        assertEquals(2, L.getPosition('c'));\n        L.insertElement(3, 'f');\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('f'); add('d'); add('e');}}, L.list);\n        L.deleteElement(2);\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('f'); add('d'); add('e');}}, L.list);\n        L.clearSeqList();\n        assertTrue(L.isEmpty());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSeqList() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c', 'd', 'e'});\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('d'); add('e');}}, L.list);\n        assertEquals(5, L.getLength());\n        assertFalse(L.isEmpty());\n        assertEquals('c', L.getElement(2));\n        assertEquals(2, L.getPosition('c'));\n        L.insertElement(3, 'f');\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('f'); add('d'); add('e');}}, L.list);\n        L.deleteElement(2);\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('f'); add('d'); add('e');}}, L.list);\n        L.clearSeqList();\n        assertTrue(L.isEmpty());\n    }\n}", "_id": 146, "response": "```java\nimport java.util.ArrayList;\n\nclass SeqList {\n    ArrayList<Character> list;\n\n    public SeqList() {\n        list = new ArrayList<>();\n    }\n\n    public void createSeqList(char[] elements) {\n        for (char element : elements) {\n            list.add(element);\n        }\n    }\n\n    public int getLength() {\n        return list.size();\n    }\n\n    public boolean isEmpty() {\n        return list.isEmpty();\n    }\n\n    public char getElement(int index) {\n        if (index >= 0 && index < list.size()) {\n            return list.get(index);\n        } else {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + list.size());\n        }\n    }\n\n    public int getPosition(char element) {\n        return list.indexOf(element);\n    }\n\n    public void insertElement(int index, char element) {\n        if (index >= 0 && index <= list.size()) {\n            list.add(index, element);\n        } else {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + list.size());\n        }\n    }\n\n    public void deleteElement(int index) {\n        if (index >= 0 && index < list.size()) {\n            list.remove(index);\n        } else {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + list.size());\n        }\n    }\n\n    public void clearSeqList() {\n        list.clear();\n    }\n}\n```"}
{"user_prompt": "首先定义了两个类，分别是植物类和僵尸类。它们都含有属性: 名称、生命值、攻击力；以及方法：攻击和死亡。\n\n植物类的攻击方法会对敌方僵尸造成攻击力伤害；僵尸类的攻击方法则会对敌方植物造成攻击力伤害。当生命值小于等于0时，会触发死亡方法。死亡方法会输出相应的信息，如已经死亡或者剩余生命值是多少。\n\n接下来创建了一个Peashooter和Conehead Zombie，分别作为植物和僵尸的代表。然后通过一个for循环来模拟战斗的过程。在循环中，植物首先攻击僵尸，然后僵尸攻击植物。每次攻击后，都会调用死亡方法来确认是否有一方死亡。当一方的生命值小于等于0时，战斗结束。\n\n最后输出对应的战斗结果。\n\n\n用JAVA实现，给我实现的代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n首先定义了两个类，分别是植物类和僵尸类。它们都含有属性: 名称、生命值、攻击力；以及方法：攻击和死亡。\n\n植物类的攻击方法会对敌方僵尸造成攻击力伤害；僵尸类的攻击方法则会对敌方植物造成攻击力伤害。当生命值小于等于0时，会触发死亡方法。死亡方法会输出相应的信息，如已经死亡或者剩余生命值是多少。\n\n接下来创建了一个Peashooter和Conehead Zombie，分别作为植物和僵尸的代表。然后通过一个for循环来模拟战斗的过程。在循环中，植物首先攻击僵尸，然后僵尸攻击植物。每次攻击后，都会调用死亡方法来确认是否有一方死亡。当一方的生命值小于等于0时，战斗结束。\n\n最后输出对应的战斗结果。\n\n\n用JAVA实现，给我实现的代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testPlantConstructor() {\n        assertEquals(\"Peashooter\", peashooter.name);\n        assertEquals(100, peashooter.health);\n        assertEquals(20, peashooter.attack);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n\n    @Test\n    void testPlantConstructor() {\n        assertEquals(\"Peashooter\", peashooter.name);\n        assertEquals(100, peashooter.health);\n        assertEquals(20, peashooter.attack);\n    }\n}", "_id": 147, "response": "```java\nclass Plant {\n    String name;\n    int health;\n    int attack;\n\n    public Plant(String name, int health, int attack) {\n        this.name = name;\n        this.health = health;\n        this.attack = attack;\n    }\n\n    public void attack(Zombie zombie) {\n        zombie.health -= this.attack;\n        zombie.checkDeath();\n    }\n\n    public void checkDeath() {\n        if (this.health <= 0) {\n            System.out.println(this.name + \" has died.\");\n        } else {\n            System.out.println(this.name + \" remaining health: \" + this.health);\n        }\n    }\n}\n\nclass Zombie {\n    String name;\n    int health;\n    int attack;\n\n    public Zombie(String name, int health, int attack) {\n        this.name = name;\n        this.health = health;\n        this.attack = attack;\n    }\n\n    public void attack(Plant plant) {\n        plant.health -= this.attack;\n        plant.checkDeath();\n    }\n\n    public void checkDeath() {\n        if (this.health <= 0) {\n            System.out.println(this.name + \" has died.\");\n        } else {\n            System.out.println(this.name + \" remaining health: \" + this.health);\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Plant peashooter = new Plant(\"Peashooter\", 100, 20);\n        Zombie coneheadZombie = new Zombie(\"Conehead Zombie\", 200, 10);\n\n        while (peashooter.health > 0 && coneheadZombie.health > 0) {\n            peashooter.attack(coneheadZombie);\n            if (coneheadZombie.health > 0) {\n                coneheadZombie.attack(peashooter);\n            }\n        }\n\n        if (peashooter.health <= 0) {\n            System.out.println(\"Zombie wins!\");\n        } else {\n            System.out.println(\"Plant wins!\");\n        }\n    }\n}\n```"}
{"user_prompt": "编写private static String readPathTest(String path)方法，实现从给定路径中提取文件名称。路径层次使用`/`分割。\n 例如传入，/courses/lecture/Lecture01.pdf，应返回：Lecture01", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写private static String readPathTest(String path)方法，实现从给定路径中提取文件名称。路径层次使用`/`分割。\n 例如传入，/courses/lecture/Lecture01.pdf，应返回：Lecture01\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testReadPathTest1() {\n        assertEquals(\"Lecture01\", PathReader.readPathTest(\"/courses/lecture/Lecture01.pdf\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testReadPathTest1() {\n        assertEquals(\"Lecture01\", PathReader.readPathTest(\"/courses/lecture/Lecture01.pdf\"));\n    }\n}", "_id": 149, "response": "```java\npublic class PathReader {\n\n    public static void main(String[] args) {\n        // Example usage of the method\n        String path = \"/courses/lecture/Lecture01.pdf\";\n        String fileName = readPathTest(path);\n        System.out.println(fileName); // Should print \"Lecture01\"\n    }\n\n    private static String readPathTest(String path) {\n        if (path == null || path.isEmpty()) {\n            return \"\";\n        }\n        // Extract the file name with extension\n        String fileNameWithExtension = path.substring(path.lastIndexOf('/') + 1);\n        // Remove the extension\n        int dotIndex = fileNameWithExtension.lastIndexOf('.');\n        return (dotIndex == -1) ? fileNameWithExtension : fileNameWithExtension.substring(0, dotIndex);\n    }\n}\n```"}
{"user_prompt": "用java 写一个方法，入参为中文，输出为中文距离今天23:59:59的天数差，例如 ：今天 今日 昨天 昨日  （最近/这）近x周  \n（最近/这）近 x 天  （最近/这）近X月  转换为  1 1 2 2 x*7 x  x个月天数总和 这里的x可能是中文的一也可能是阿拉伯数字1，x最大值为12", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java 写一个方法，入参为中文，输出为中文距离今天23:59:59的天数差，例如 ：今天 今日 昨天 昨日  （最近/这）近x周  \n（最近/这）近 x 天  （最近/这）近X月  转换为  1 1 2 2 x*7 x  x个月天数总和 这里的x可能是中文的一也可能是阿拉伯数字1，x最大值为12\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetDaysDifference_today() {\n        assertEquals(1, DateDifference.getDaysDifference(\"今天\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testGetDaysDifference_today() {\n        assertEquals(1, DateDifference.getDaysDifference(\"今天\"));\n    }\n}", "_id": 148, "response": "```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DateDifference {\n\n    private static final Map<String, Integer> CHINESE_NUMBERS = new HashMap<>();\n    static {\n        CHINESE_NUMBERS.put(\"一\", 1);\n        CHINESE_NUMBERS.put(\"二\", 2);\n        CHINESE_NUMBERS.put(\"三\", 3);\n        CHINESE_NUMBERS.put(\"四\", 4);\n        CHINESE_NUMBERS.put(\"五\", 5);\n        CHINESE_NUMBERS.put(\"六\", 6);\n        CHINESE_NUMBERS.put(\"七\", 7);\n        CHINESE_NUMBERS.put(\"八\", 8);\n        CHINESE_NUMBERS.put(\"九\", 9);\n        CHINESE_NUMBERS.put(\"十\", 10);\n        CHINESE_NUMBERS.put(\"十一\", 11);\n        CHINESE_NUMBERS.put(\"十二\", 12);\n    }\n\n    public static int getDaysDifference(String chineseDate) {\n        LocalDate today = LocalDate.now();\n        LocalDate targetDate = today;\n        int daysDifference = 0;\n\n        if (chineseDate.equals(\"今天\") || chineseDate.equals(\"今日\")) {\n            daysDifference = 1;\n        } else if (chineseDate.equals(\"昨天\") || chineseDate.equals(\"昨日\")) {\n            daysDifference = 2;\n        } else if (chineseDate.contains(\"近\") || chineseDate.contains(\"这\")) {\n            int number;\n            if (Character.isDigit(chineseDate.charAt(chineseDate.length() - 2))) {\n                number = Integer.parseInt(chineseDate.substring(chineseDate.length() - 2, chineseDate.length() - 1));\n            } else {\n                String chineseNumber = chineseDate.substring(chineseDate.length() - 2, chineseDate.length() - 1);\n                number = CHINESE_NUMBERS.getOrDefault(chineseNumber, 0);\n            }\n\n            if (chineseDate.contains(\"周\")) {\n                daysDifference = number * 7;\n            } else if (chineseDate.contains(\"天\")) {\n                daysDifference = number;\n            } else if (chineseDate.contains(\"月\")) {\n                for (int i = 0; i < number; i++) {\n                    targetDate = targetDate.minusMonths(1);\n                    daysDifference += targetDate.lengthOfMonth();\n                }\n            }\n        }\n\n        return daysDifference;\n    }\n}\n```"}
{"user_prompt": "用Java实现如下功能：\n从字符串中找出所有如下的内容：\n\"supported_mobiles\":[\"13001597927\",\"13001740938\",\"13001910099\"]\n该字符串中中括号的内容可能为空，不为空则必然存放手机号码\n请导出字符串中所有的手机号码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java实现如下功能：\n从字符串中找出所有如下的内容：\n\"supported_mobiles\":[\"13001597927\",\"13001740938\",\"13001910099\"]\n该字符串中中括号的内容可能为空，不为空则必然存放手机号码\n请导出字符串中所有的手机号码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testExtractPhoneNumbers1() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        expected.add(\"13001910099\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testExtractPhoneNumbers1() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        expected.add(\"13001910099\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n}", "_id": 151, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n    public static List<String> extractPhoneNumbers(String input) {\n        List<String> phoneNumbers = new ArrayList<>();\n        Pattern pattern = Pattern.compile(\"\\\"supported_mobiles\\\":\\\\[\\\"(.*?)\\\"]\");\n        Matcher matcher = pattern.matcher(input);\n\n        if (matcher.find()) {\n            String phones = matcher.group(1);\n            if (!phones.isEmpty()) {\n                String[] numbers = phones.split(\"\\\",\\\"\");\n                for (String number : numbers) {\n                    phoneNumbers.add(number);\n                }\n            }\n        }\n\n        return phoneNumbers;\n    }\n\n    public static void main(String[] args) {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\"]\";\n        List<String> phoneNumbers = extractPhoneNumbers(str);\n        for (String number : phoneNumbers) {\n            System.out.println(number);\n        }\n    }\n}\n```"}
{"user_prompt": "用Java编写编写一个主类，包括2个方法。在main方法中，从键盘读入字符串，调用isRightIP(String ip)方法测试输入的字符串是否为合法的IP，正确输出true，不正确输出false。验证IP地址的方法可定义为public boolean isRightIP(String ip)，参数ip是要验证的IP地址。IP地址由4部分构成，格式为x.x.x.x；其中每个x都是0~255之间的整数，每个部分之间以“.”分隔，例如192.168.1.1。请给出至少两种方法求解该问题，其中的一种方法必须使用正则表达式。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java编写编写一个主类，包括2个方法。在main方法中，从键盘读入字符串，调用isRightIP(String ip)方法测试输入的字符串是否为合法的IP，正确输出true，不正确输出false。验证IP地址的方法可定义为public boolean isRightIP(String ip)，参数ip是要验证的IP地址。IP地址由4部分构成，格式为x.x.x.x；其中每个x都是0~255之间的整数，每个部分之间以“.”分隔，例如192.168.1.1。请给出至少两种方法求解该问题，其中的一种方法必须使用正则表达式。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsRightIP() {\n        assertTrue(Main.isRightIP(\"192.168.1.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1.256\"));\n        assertFalse(Main.isRightIP(\"192.168.1.-1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.256\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.1.1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testIsRightIP() {\n        assertTrue(Main.isRightIP(\"192.168.1.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1.256\"));\n        assertFalse(Main.isRightIP(\"192.168.1.-1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.256\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.1.1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1\"));\n    }\n}", "_id": 150, "response": "```java\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter an IP address: \");\n        String ip = scanner.nextLine();\n        scanner.close();\n\n        System.out.println(isRightIP(ip) ? \"true\" : \"false\");\n        System.out.println(isRightIPByRegex(ip) ? \"true\" : \"false\");\n    }\n\n    public static boolean isRightIP(String ip) {\n        String[] parts = ip.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return false;\n        }\n        for (String part : parts) {\n            try {\n                int intPart = Integer.parseInt(part);\n                if (intPart < 0 || intPart > 255) {\n                    return false;\n                }\n            } catch (NumberFormatException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isRightIPByRegex(String ip) {\n        String ipRegex = \"^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.\"\n                       + \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.\"\n                       + \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.\"\n                       + \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\";\n        Pattern pattern = Pattern.compile(ipRegex);\n        Matcher matcher = pattern.matcher(ip);\n        return matcher.matches();\n    }\n}\n```"}
{"user_prompt": "1.设计编写一个控制台应用程序，输入某个成年人的性别、身高和体重，计算其BMI\n体重指数，计算公式：BMI= 体重/ (身高* 身高)，并得出结论。\n\n结论\n男性\n女性\n\n过轻\n指数<20\n指数<19\n\n适中\n20≤指数<25\n19≤指数<24\n\n过重\n25≤指数<30\n24≤指数<29\n\n肥胖\n30≤指数<35\n29≤指数<34\n\n非常肥胖\n指数≥35\n指数≥34\n\n\n(1) 编写一个抽象类People，具有Height(身高)，Weight(体重)两个 属性，计算BMI\n指数的方法CalculateBMI， 得到结论的抽象方法Conclusion。\n详细代码：\n\n(2) 编写两个类Man和Woman，继承People类，并重写Conclusion抽象方法。\n详细代码：\n\n\n(3) 编写控制流程，输入某个成年人的性别、身高和体重。\n详细代码：", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1.设计编写一个控制台应用程序，输入某个成年人的性别、身高和体重，计算其BMI\n体重指数，计算公式：BMI= 体重/ (身高* 身高)，并得出结论。\n\n结论\n男性\n女性\n\n过轻\n指数<20\n指数<19\n\n适中\n20≤指数<25\n19≤指数<24\n\n过重\n25≤指数<30\n24≤指数<29\n\n肥胖\n30≤指数<35\n29≤指数<34\n\n非常肥胖\n指数≥35\n指数≥34\n\n\n(1) 编写一个抽象类People，具有Height(身高)，Weight(体重)两个 属性，计算BMI\n指数的方法CalculateBMI， 得到结论的抽象方法Conclusion。\n详细代码：\n\n(2) 编写两个类Man和Woman，继承People类，并重写Conclusion抽象方法。\n详细代码：\n\n\n(3) 编写控制流程，输入某个成年人的性别、身高和体重。\n详细代码：\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\nvoid testManUnderweight() {\n    Man man = new Man(1.8, 60);\n    assertEquals(\"过轻\", man.conclusion());\n}\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n@Test\nvoid testManUnderweight() {\n    Man man = new Man(1.8, 60);\n    assertEquals(\"过轻\", man.conclusion());\n}\n}", "_id": 153, "response": "```java\nimport java.util.Scanner;\n\nabstract class People {\n    protected double height;\n    protected double weight;\n\n    public People(double height, double weight) {\n        this.height = height;\n        this.weight = weight;\n    }\n\n    public double calculateBMI() {\n        return weight / (height * height);\n    }\n\n    public abstract String conclusion();\n}\n\nclass Man extends People {\n    public Man(double height, double weight) {\n        super(height, weight);\n    }\n\n    @Override\n    public String conclusion() {\n        double bmi = calculateBMI();\n        if (bmi < 20) return \"过轻\";\n        else if (bmi < 25) return \"适中\";\n        else if (bmi < 30) return \"过重\";\n        else if (bmi < 35) return \"肥胖\";\n        else return \"非常肥胖\";\n    }\n}\n\nclass Woman extends People {\n    public Woman(double height, double weight) {\n        super(height, weight);\n    }\n\n    @Override\n    public String conclusion() {\n        double bmi = calculateBMI();\n        if (bmi < 19) return \"过轻\";\n        else if (bmi < 24) return \"适中\";\n        else if (bmi < 29) return \"过重\";\n        else if (bmi < 34) return \"肥胖\";\n        else return \"非常肥胖\";\n    }\n}\n\npublic class BMICalculator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入性别（男/女）：\");\n        String gender = scanner.next();\n        System.out.println(\"请输入身高（米）：\");\n        double height = scanner.nextDouble();\n        System.out.println(\"请输入体重（公斤）：\");\n        double weight = scanner.nextDouble();\n\n        People person;\n        if (\"男\".equals(gender)) {\n            person = new Man(height, weight);\n        } else if (\"女\".equals(gender)) {\n            person = new Woman(height, weight);\n        } else {\n            System.out.println(\"性别输入错误！\");\n            scanner.close();\n            return;\n        }\n\n        System.out.println(\"BMI指数为：\" + person.calculateBMI());\n        System.out.println(\"结论：\" + person.conclusion());\n\n        scanner.close();\n    }\n}\n```"}
{"user_prompt": "给出下面的html代码，怎么用jsoup 获取内容Ihtesham Haider，html代码如下 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div dir=\"ltr\" class=\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\">Ihtesham Haider</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给出下面的html代码，怎么用jsoup 获取内容Ihtesham Haider，html代码如下 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div dir=\"ltr\" class=\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\">Ihtesham Haider</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMain1() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Ihtesham Haider\", content);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMain1() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Ihtesham Haider\", content);\n    }\n}", "_id": 154, "response": "```java\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\npublic class Main {\n    public static void main(String[] args) {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        System.out.println(content);\n    }\n}\n```"}
{"user_prompt": "对于这个讨论，你将编写一个Java程序，实现以下矩阵操作。\n• 交集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的交集。\n• 并集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的并集。\n编写主函数来测试所有的方法", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对于这个讨论，你将编写一个Java程序，实现以下矩阵操作。\n• 交集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的交集。\n• 并集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的并集。\n编写主函数来测试所有的方法\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMeet1() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, false}, {false, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMeet1() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, false}, {false, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n}", "_id": 152, "response": "```java\npublic class MatrixOperations {\n\n    public static boolean[][] meet(boolean[][] matrix1, boolean[][] matrix2) {\n        if (matrix1.length == 0 || matrix2.length == 0 || matrix1.length != matrix2.length || matrix1[0].length != matrix2[0].length) {\n            throw new IllegalArgumentException(\"Matrices must be non-empty and of the same dimensions.\");\n        }\n\n        int m = matrix1.length;\n        int n = matrix1[0].length;\n        boolean[][] intersection = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                intersection[i][j] = matrix1[i][j] && matrix2[i][j];\n            }\n        }\n\n        return intersection;\n    }\n\n    public static boolean[][] join(boolean[][] matrix1, boolean[][] matrix2) {\n        if (matrix1.length == 0 || matrix2.length == 0 || matrix1.length != matrix2.length || matrix1[0].length != matrix2[0].length) {\n            throw new IllegalArgumentException(\"Matrices must be non-empty and of the same dimensions.\");\n        }\n\n        int m = matrix1.length;\n        int n = matrix1[0].length;\n        boolean[][] union = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                union[i][j] = matrix1[i][j] || matrix2[i][j];\n            }\n        }\n\n        return union;\n    }\n\n    public static void main(String[] args) {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n\n        boolean[][] intersection = meet(matrix1, matrix2);\n        boolean[][] union = join(matrix1, matrix2);\n\n        System.out.println(\"Intersection:\");\n        printMatrix(intersection);\n\n        System.out.println(\"Union:\");\n        printMatrix(union);\n    }\n\n    private static void printMatrix(boolean[][] matrix) {\n        for (boolean[] row : matrix) {\n            for (boolean value : row) {\n                System.out.print(value ? \"1 \" : \"0 \");\n            }\n            System.out.println();\n        }\n    }\n}\n```"}
{"user_prompt": "使用作业系统提交java作业时，需要输入java源代码文件名和自己的邮箱，\n提交前对java文件名及邮箱进行有效性检查。编写程序对输入的java文件名及\n及邮箱进行有效性检查。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用作业系统提交java作业时，需要输入java源代码文件名和自己的邮箱，\n提交前对java文件名及邮箱进行有效性检查。编写程序对输入的java文件名及\n及邮箱进行有效性检查。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsValidJavaFileName1() {\n        assertTrue(Main.isValidJavaFileName(\"Test.java\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testIsValidJavaFileName1() {\n        assertTrue(Main.isValidJavaFileName(\"Test.java\"));\n    }\n}", "_id": 155, "response": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // Example usage:\n        String javaFileName = \"Test.java\";\n        String email = \"example@example.com\";\n        \n        if (isValidJavaFileName(javaFileName) && isValidEmail(email)) {\n            System.out.println(\"Both the Java file name and email are valid.\");\n        } else {\n            System.out.println(\"Invalid Java file name or email.\");\n        }\n    }\n\n    public static boolean isValidJavaFileName(String fileName) {\n        // Java file name must end with .java and must have characters before the extension\n        return fileName.matches(\"^.+\\\\.java$\");\n    }\n\n    public static boolean isValidEmail(String email) {\n        // Simple regex for email validation\n        String emailRegex = \"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\";\n        Pattern pattern = Pattern.compile(emailRegex);\n        Matcher matcher = pattern.matcher(email);\n        return matcher.matches();\n    }\n}\n```"}
{"user_prompt": "输入字符串是这种 格式ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\n我需要先通过 ； 分割 再拿到每组最后一个&&右边的值，再去重，再根据是否有枚举类里面的值进行过滤 枚举是\npublic enum RiskRejectCategoryEnum {\n\n    /**\n     * The smaller the value of priority, the higher the priority\n     */\n    black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n    rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n    no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");}", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n输入字符串是这种 格式ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\n我需要先通过 ； 分割 再拿到每组最后一个&&右边的值，再去重，再根据是否有枚举类里面的值进行过滤 枚举是\npublic enum RiskRejectCategoryEnum {\n\n    /**\n     * The smaller the value of priority, the higher the priority\n     */\n    black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n    rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n    no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testFilterValues1() {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\", \"no_email\", \"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testFilterValues1() {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\", \"no_email\", \"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n}", "_id": 157, "response": "```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // Example usage of the filterValues method\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\";\n        Set<String> result = filterValues(input);\n        System.out.println(result);\n    }\n\n    public static Set<String> filterValues(String input) {\n        Set<String> values = Arrays.stream(input.split(\";\"))\n                .map(s -> s.substring(s.lastIndexOf(\"&&\") + 2))\n                .collect(Collectors.toSet());\n\n        Set<String> enumValues = Arrays.stream(RiskRejectCategoryEnum.values())\n                .map(RiskRejectCategoryEnum::getCode)\n                .collect(Collectors.toSet());\n\n        values.retainAll(enumValues);\n\n        return values;\n    }\n\n    public enum RiskRejectCategoryEnum {\n        black_email(\"black_email\", \"GREYLIST\", 1, \"灰名单\"),\n        rule_email(\"rule_email\", \"NON_GREYLIST\", 2, \"非灰名单\"),\n        no_email(\"no_email\", \"NO_EMAIL\", 99, \"不需要发邮箱\");\n\n        private final String code;\n        private final String type;\n        private final int priority;\n        private final String description;\n\n        RiskRejectCategoryEnum(String code, String type, int priority, String description) {\n            this.code = code;\n            this.type = type;\n            this.priority = priority;\n            this.description = description;\n        }\n\n        public String getCode() {\n            return code;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public int getPriority() {\n            return priority;\n        }\n\n        public String getDescription() {\n            return description;\n        }\n    }\n}\n```"}
{"user_prompt": "如何使用fastjson快速给xAxis中的data以及series赋值，必须使用如下json\n{\n\t\"xAxis\": {\n\t\t\"type\": \"category\",\n\t\t\"data\": [\n\t\t\t\"Mon\",\n\t\t\t\"Tue\",\n\t\t\t\"Wed\",\n\t\t\t\"Thu\",\n\t\t\t\"Fri\",\n\t\t\t\"Sat\",\n\t\t\t\"Sun\"\n\t\t]\n\t},\n\t\"yAxis\": {\n\t\t\"type\": \"value\"\n\t},\n\t\"series\": [{\n\t\t\"data\": [\n\t\t\t150,\n\t\t\t230,\n\t\t\t224,\n\t\t\t218,\n\t\t\t135,\n\t\t\t147,\n\t\t\t260\n\t\t],\n\t\t\"type\": \"line\"\n\t}]\n}", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n如何使用fastjson快速给xAxis中的data以及series赋值，必须使用如下json\n{\n\t\"xAxis\": {\n\t\t\"type\": \"category\",\n\t\t\"data\": [\n\t\t\t\"Mon\",\n\t\t\t\"Tue\",\n\t\t\t\"Wed\",\n\t\t\t\"Thu\",\n\t\t\t\"Fri\",\n\t\t\t\"Sat\",\n\t\t\t\"Sun\"\n\t\t]\n\t},\n\t\"yAxis\": {\n\t\t\"type\": \"value\"\n\t},\n\t\"series\": [{\n\t\t\"data\": [\n\t\t\t150,\n\t\t\t230,\n\t\t\t224,\n\t\t\t218,\n\t\t\t135,\n\t\t\t147,\n\t\t\t260\n\t\t],\n\t\t\"type\": \"line\"\n\t}]\n}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMain1() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n        assertEquals(\"Tue\", xAxisData.getString(1));\n        assertEquals(\"Wed\", xAxisData.getString(2));\n        assertEquals(\"Thu\", xAxisData.getString(3));\n        assertEquals(\"Fri\", xAxisData.getString(4));\n        assertEquals(\"Sat\", xAxisData.getString(5));\n        assertEquals(\"Sun\", xAxisData.getString(6));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        assertEquals(150, data.getInteger(0));\n        assertEquals(230, data.getInteger(1));\n        assertEquals(224, data.getInteger(2));\n        assertEquals(218, data.getInteger(3));\n        assertEquals(135, data.getInteger(4));\n        assertEquals(147, data.getInteger(5));\n        assertEquals(260, data.getInteger(6));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMain1() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n        assertEquals(\"Tue\", xAxisData.getString(1));\n        assertEquals(\"Wed\", xAxisData.getString(2));\n        assertEquals(\"Thu\", xAxisData.getString(3));\n        assertEquals(\"Fri\", xAxisData.getString(4));\n        assertEquals(\"Sat\", xAxisData.getString(5));\n        assertEquals(\"Sun\", xAxisData.getString(6));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        assertEquals(150, data.getInteger(0));\n        assertEquals(230, data.getInteger(1));\n        assertEquals(224, data.getInteger(2));\n        assertEquals(218, data.getInteger(3));\n        assertEquals(135, data.getInteger(4));\n        assertEquals(147, data.getInteger(5));\n        assertEquals(260, data.getInteger(6));\n    }\n}", "_id": 156, "response": "```java\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\n\npublic class Main {\n    public static void main(String[] args) {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        System.out.println(xAxisData); // Output the xAxis data\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        System.out.println(data); // Output the series data\n    }\n}\n```"}
{"user_prompt": "（检测密码）编写一个java方法，检测字符串是否是一个有效密码。\n\n密码规则如下：\n\n密码必须至少8位字符\n\n密码仅能包含字母和数字\n\n密码必须包含至少两个数字\n\n编写一个程序，提示用户输入一个密码，如果符合规则，则显示Valid Password，否则显示Invalid Password。\n\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n（检测密码）编写一个java方法，检测字符串是否是一个有效密码。\n\n密码规则如下：\n\n密码必须至少8位字符\n\n密码仅能包含字母和数字\n\n密码必须包含至少两个数字\n\n编写一个程序，提示用户输入一个密码，如果符合规则，则显示Valid Password，否则显示Invalid Password。\n\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(Main.isValidPassword(\"Password123\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(Main.isValidPassword(\"Password123\"));\n    }\n}", "_id": 158, "response": "```java\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter a password: \");\n        String password = scanner.nextLine();\n        if (isValidPassword(password)) {\n            System.out.println(\"Valid Password\");\n        } else {\n            System.out.println(\"Invalid Password\");\n        }\n        scanner.close();\n    }\n\n    public static boolean isValidPassword(String password) {\n        if (password.length() < 8) {\n            return false;\n        }\n\n        int digitCount = 0;\n        for (int i = 0; i < password.length(); i++) {\n            char ch = password.charAt(i);\n            if (!Character.isLetterOrDigit(ch)) {\n                return false;\n            }\n            if (Character.isDigit(ch)) {\n                digitCount++;\n            }\n        }\n\n        return digitCount >= 2;\n    }\n}\n```"}
{"user_prompt": "用Java设计一个方法\npublic static void encodeFile(File encodingFile, File encodedFile);\n用如下规则的加密手段，并将给定的encodingFile文本文件中的内容进行加密，然后保存到encodedFile文件中\n加密规则：\n1.数字： 如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4 如果是9的数字，变成0\n2.字母字符： 如果是非z字符，向右移动一个，比如d变成e, G变成H 如果是z，z->a, Z-A。\n   注：字母字符加密的过程不能改变大小写\n3.非数字和字母的字符则保持不变即可，比如汉字和标点符号等都只需要保持不变即可", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java设计一个方法\npublic static void encodeFile(File encodingFile, File encodedFile);\n用如下规则的加密手段，并将给定的encodingFile文本文件中的内容进行加密，然后保存到encodedFile文件中\n加密规则：\n1.数字： 如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4 如果是9的数字，变成0\n2.字母字符： 如果是非z字符，向右移动一个，比如d变成e, G变成H 如果是z，z->a, Z-A。\n   注：字母字符加密的过程不能改变大小写\n3.非数字和字母的字符则保持不变即可，比如汉字和标点符号等都只需要保持不变即可\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileEncoderTest {\n\n\n    @Test\n    void testEncodeDigits() throws IOException {\n        // 测试数字的加密，包括边界情况9\n        File input = new File(\"testEncodeDigits.txt\");\n        File output = new File(\"testEncodeDigitsOutput.txt\");\n        // 假设input文件内容为 \"123456789\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"234567890\", readFileContent(output));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileEncoderTest {\n\n\n    @Test\n    void testEncodeDigits() throws IOException {\n        // 测试数字的加密，包括边界情况9\n        File input = new File(\"testEncodeDigits.txt\");\n        File output = new File(\"testEncodeDigitsOutput.txt\");\n        // 假设input文件内容为 \"123456789\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"234567890\", readFileContent(output));\n    }\n}", "_id": 160, "response": "```java\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileEncoder {\n\n    public static void encodeFile(File encodingFile, File encodedFile) {\n        try (FileReader fileReader = new FileReader(encodingFile);\n             FileWriter fileWriter = new FileWriter(encodedFile)) {\n            int c;\n            while ((c = fileReader.read()) != -1) {\n                char character = (char) c;\n                if (Character.isDigit(character)) {\n                    character = character == '9' ? '0' : (char) (character + 1);\n                } else if (Character.isLetter(character)) {\n                    if (character == 'z') {\n                        character = 'a';\n                    } else if (character == 'Z') {\n                        character = 'A';\n                    } else {\n                        character = (char) (character + 1);\n                    }\n                }\n                fileWriter.write(character);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"}
{"user_prompt": "使用单例模式的思想实现多例模式，确保系统中某个类的对象只能存在有限个，如3个(Threeleton)。设计并编写Java代码实现该多例模式。然后使用多线程来测试三例模式，并请输出获取到的每个实例的编号（如0,1,2）。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用单例模式的思想实现多例模式，确保系统中某个类的对象只能存在有限个，如3个(Threeleton)。设计并编写Java代码实现该多例模式。然后使用多线程来测试三例模式，并请输出获取到的每个实例的编号（如0,1,2）。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetInstance_MultipleThreads_1() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[1];\n        for (int i = 0; i < 1; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(0, ids[0].get());\n        assertEquals(0, ids[1].get());\n        assertEquals(0, ids[2].get());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testGetInstance_MultipleThreads_1() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[1];\n        for (int i = 0; i < 1; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(0, ids[0].get());\n        assertEquals(0, ids[1].get());\n        assertEquals(0, ids[2].get());\n    }\n}", "_id": 159, "response": "```java\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Threeleton {\n    private static final Threeleton[] instances = new Threeleton[3];\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n    private static final Lock lock = new ReentrantLock();\n    private final int id;\n\n    static {\n        for (int i = 0; i < instances.length; i++) {\n            instances[i] = new Threeleton(i);\n        }\n    }\n\n    private Threeleton(int id) {\n        this.id = id;\n    }\n\n    public static Threeleton getInstance() {\n        lock.lock();\n        try {\n            int id = nextId.getAndUpdate(i -> (i + 1) % instances.length);\n            return instances[id];\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    // Test method to simulate multiple threads accessing the Threeleton instances\n    public static void main(String[] args) throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[100];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        // Output the number of times each instance was obtained\n        for (int i = 0; i < ids.length; i++) {\n            System.out.println(\"Instance \" + i + \" was obtained \" + ids[i].get() + \" times.\");\n        }\n    }\n}\n```\n\nPlease note that the test case provided in the question seems to be incorrect because it expects all counts to be zero after running the threads, which is not possible if the threads are actually obtaining instances of `Threeleton`. The provided `main` method in the code above is a corrected version that simulates multiple threads accessing the `Threeleton` instances and outputs the number of times each instance was obtained."}
{"user_prompt": "用java2.利用Map，完成下面的功能：\n   1.从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。\n如果该年没有举办世界杯，则输出：没有举办世界杯。\n   2.例如，读入“巴西”，应当输出 1958 1962 1970 1994 2002 读入“荷兰”，应当输出 没有获得过世界杯 。\n1930  乌拉圭\n1934意大利\n1938意大利\n1950乌拉圭\n1954西德\n1958巴西\n1962巴西\n1966英格兰\n1970巴西\n1974西德\n1978阿根廷\n1982意大利\n1986阿根廷\n1990西德\n1994巴西\n1998法国\n2002巴西\n2006意大利\n2010西班牙\n2014德国", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java2.利用Map，完成下面的功能：\n   1.从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。\n如果该年没有举办世界杯，则输出：没有举办世界杯。\n   2.例如，读入“巴西”，应当输出 1958 1962 1970 1994 2002 读入“荷兰”，应当输出 没有获得过世界杯 。\n1930  乌拉圭\n1934意大利\n1938意大利\n1950乌拉圭\n1954西德\n1958巴西\n1962巴西\n1966英格兰\n1970巴西\n1974西德\n1978阿根廷\n1982意大利\n1986阿根廷\n1990西德\n1994巴西\n1998法国\n2002巴西\n2006意大利\n2010西班牙\n2014德国\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class WorldCupServiceTest {\n\n\n    @Test\n    public void testGetChampionByYearWithExistingYear() {\n        assertEquals(\"巴西\", worldCupService.getChampionByYear(\"1958\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class WorldCupServiceTest {\n\n\n    @Test\n    public void testGetChampionByYearWithExistingYear() {\n        assertEquals(\"巴西\", worldCupService.getChampionByYear(\"1958\"));\n    }\n}", "_id": 161, "response": "```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class WorldCupService {\n\n    private Map<String, String> worldCupChampions;\n\n    public WorldCupService() {\n        worldCupChampions = new HashMap<>();\n        worldCupChampions.put(\"1930\", \"乌拉圭\");\n        worldCupChampions.put(\"1934\", \"意大利\");\n        worldCupChampions.put(\"1938\", \"意大利\");\n        worldCupChampions.put(\"1950\", \"乌拉圭\");\n        worldCupChampions.put(\"1954\", \"西德\");\n        worldCupChampions.put(\"1958\", \"巴西\");\n        worldCupChampions.put(\"1962\", \"巴西\");\n        worldCupChampions.put(\"1966\", \"英格兰\");\n        worldCupChampions.put(\"1970\", \"巴西\");\n        worldCupChampions.put(\"1974\", \"西德\");\n        worldCupChampions.put(\"1978\", \"阿根廷\");\n        worldCupChampions.put(\"1982\", \"意大利\");\n        worldCupChampions.put(\"1986\", \"阿根廷\");\n        worldCupChampions.put(\"1990\", \"西德\");\n        worldCupChampions.put(\"1994\", \"巴西\");\n        worldCupChampions.put(\"1998\", \"法国\");\n        worldCupChampions.put(\"2002\", \"巴西\");\n        worldCupChampions.put(\"2006\", \"意大利\");\n        worldCupChampions.put(\"2010\", \"西班牙\");\n        worldCupChampions.put(\"2014\", \"德国\");\n    }\n\n    public String getChampionByYear(String year) {\n        return worldCupChampions.getOrDefault(year, \"没有举办世界杯\");\n    }\n\n    public void printChampionByCountry(String country) {\n        StringBuilder years = new StringBuilder();\n        for (Map.Entry<String, String> entry : worldCupChampions.entrySet()) {\n            if (entry.getValue().equals(country)) {\n                years.append(entry.getKey()).append(\" \");\n            }\n        }\n        if (years.length() > 0) {\n            System.out.println(years.toString().trim());\n        } else {\n            System.out.println(\"没有获得过世界杯\");\n        }\n    }\n\n    public static void main(String[] args) {\n        WorldCupService worldCupService = new WorldCupService();\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        try {\n            Integer.parseInt(input); // Check if input is a year\n            System.out.println(worldCupService.getChampionByYear(input));\n        } catch (NumberFormatException e) {\n            worldCupService.printChampionByCountry(input);\n        }\n    }\n}\n```"}
{"user_prompt": "在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下\n\nn = 3, m = 3\n1   2   3\n2   4   6\n3   6   9\n\n给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。请用java实现这一代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下\n\nn = 3, m = 3\n1   2   3\n2   4   6\n3   6   9\n\n给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。请用java实现这一代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class KthLargestInMatrixTest {\n\n\n    @Test\n    public void testSimpleCase() {\n        assertEquals(9, finder.findKthLargestValue(3, 3, 1));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class KthLargestInMatrixTest {\n\n\n    @Test\n    public void testSimpleCase() {\n        assertEquals(9, finder.findKthLargestValue(3, 3, 1));\n    }\n}", "_id": 163, "response": "```java\npublic class KthLargestInMatrix {\n\n    public int findKthLargestValue(int n, int m, int k) {\n        int low = 1, high = n * m;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            int count = getCountLessOrEqual(mid, n, m);\n            if (count < k) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    private int getCountLessOrEqual(int x, int n, int m) {\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            count += Math.min(x / i, m);\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        KthLargestInMatrix finder = new KthLargestInMatrix();\n        System.out.println(finder.findKthLargestValue(3, 3, 1)); // Should print 9\n    }\n}\n```"}
{"user_prompt": "有一种将字母编码成数字的方式：' a '->1' b ->2',...,' z ->26'。\n现在给一串数字，返回有多少种可能的译码结果。\n例如：\"11\"有2种可能的译码结\n果，\" aa \"或\" k \"。\n要求：字符串长度满足0< n ≤90，空间\n复杂度 O ( n )，时间复杂度 O ( n )。用JAVA实现", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n有一种将字母编码成数字的方式：' a '->1' b ->2',...,' z ->26'。\n现在给一串数字，返回有多少种可能的译码结果。\n例如：\"11\"有2种可能的译码结\n果，\" aa \"或\" k \"。\n要求：字符串长度满足0< n ≤90，空间\n复杂度 O ( n )，时间复杂度 O ( n )。用JAVA实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass SolutionTest {\n\n    @Test\n    void testNumDecodings1() {\n        Solution solution = new Solution();\n        assertEquals(2, solution.numDecodings(\"11\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class SolutionTest {\n\n    @Test\n    void testNumDecodings1() {\n        Solution solution = new Solution();\n        assertEquals(2, solution.numDecodings(\"11\"));\n    }\n}", "_id": 162, "response": "```java\npublic class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0 || s.charAt(0) == '0') {\n            return 0;\n        }\n\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Empty string has one way to decode\n        dp[1] = s.charAt(0) != '0' ? 1 : 0; // One character string can be decoded only if it's not '0'\n\n        for (int i = 2; i <= n; i++) {\n            int firstDigit = Integer.parseInt(s.substring(i - 1, i)); // Last one digit\n            int secondDigit = Integer.parseInt(s.substring(i - 2, i)); // Last two digits\n\n            if (firstDigit >= 1 && firstDigit <= 9) {\n                dp[i] += dp[i - 1]; // If the last digit is not '0', it can be decoded as a single digit\n            }\n\n            if (secondDigit >= 10 && secondDigit <= 26) {\n                dp[i] += dp[i - 2]; // If the last two digits form a number between 10 and 26, it can be decoded as a double digit\n            }\n        }\n\n        return dp[n];\n    }\n}\n```"}
{"user_prompt": "给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。 java", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。 java\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TreeNodeTest {\n\n    @Test\n    void testIsValidBST1() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(2);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(3);\n        assertTrue(solution.isValidBST(root));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class TreeNodeTest {\n\n    @Test\n    void testIsValidBST1() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(2);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(3);\n        assertTrue(solution.isValidBST(root));\n    }\n}", "_id": 164, "response": "```java\n// Definition for a binary tree node.\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    private boolean isValidBST(TreeNode node, long lower, long upper) {\n        if (node == null) {\n            return true;\n        }\n        if (node.val <= lower || node.val >= upper) {\n            return false;\n        }\n        return isValidBST(node.left, lower, node.val) && isValidBST(node.right, node.val, upper);\n    }\n}\n```"}
{"user_prompt": "编写程序，请用JAVA语言中的switch-case语句来完成：\n从键盘分别输入年、月、日，判断这一天是当年的第几天\n\n提示：判断一年是否是闰年的标准：\n1)可以被4整除，但不可被100整除\n2)可以被400整除", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写程序，请用JAVA语言中的switch-case语句来完成：\n从键盘分别输入年、月、日，判断这一天是当年的第几天\n\n提示：判断一年是否是闰年的标准：\n1)可以被4整除，但不可被100整除\n2)可以被400整除\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DayOfYearCalculatorTest {\n\n\n    @Test\n    public void testCommonYearFebruary() {\n        assertEquals(59, DayOfYearCalculator.dayOfYear(2023, 2, 28));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DayOfYearCalculatorTest {\n\n\n    @Test\n    public void testCommonYearFebruary() {\n        assertEquals(59, DayOfYearCalculator.dayOfYear(2023, 2, 28));\n    }\n}", "_id": 165, "response": "```java\nimport java.util.Scanner;\n\npublic class DayOfYearCalculator {\n\n    public static int dayOfYear(int year, int month, int day) {\n        int[] daysInMonth = {\n            31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n        };\n        \n        int dayOfYear = 0;\n        for (int i = 0; i < month - 1; i++) {\n            dayOfYear += daysInMonth[i];\n        }\n        dayOfYear += day;\n\n        return dayOfYear;\n    }\n\n    private static boolean isLeapYear(int year) {\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter year: \");\n        int year = scanner.nextInt();\n        System.out.print(\"Enter month: \");\n        int month = scanner.nextInt();\n        System.out.print(\"Enter day: \");\n        int day = scanner.nextInt();\n        scanner.close();\n\n        int dayOfYear = dayOfYear(year, month, day);\n        System.out.println(\"The day is the \" + dayOfYear + \"th day of the year.\");\n    }\n}\n```"}
{"user_prompt": "小蓝每天都锻炼身体。\n\n正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2千米。\n\n小蓝跑步已经坚持了很长时间，从 2000 年 11 月 11 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？Java写并解释", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n小蓝每天都锻炼身体。\n\n正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2千米。\n\n小蓝跑步已经坚持了很长时间，从 2000 年 11 月 11 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？Java写并解释\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\n\nimport java.time.LocalDate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RunningTrackerTest {\n\n\n    @Test\n    public void testNonLeapYearFebruary() {\n        // 测试非闰年的2月，期望跑步距离考虑了月初和周一\n        assertEquals(\"Expected distance considering Mondays and the beginning of the month\", 32, tracker.calculateTotalDistance(LocalDate.of(2021, 2, 1), LocalDate.of(2021, 2, 28)));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\n\nimport java.time.LocalDate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RunningTrackerTest {\n\n\n    @Test\n    public void testNonLeapYearFebruary() {\n        // 测试非闰年的2月，期望跑步距离考虑了月初和周一\n        assertEquals(\"Expected distance considering Mondays and the beginning of the month\", 32, tracker.calculateTotalDistance(LocalDate.of(2021, 2, 1), LocalDate.of(2021, 2, 28)));\n    }\n}", "_id": 166, "response": "```java\nimport java.time.DayOfWeek;\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class RunningTracker {\n\n    public long calculateTotalDistance(LocalDate startDate, LocalDate endDate) {\n        long totalDistance = 0;\n        LocalDate currentDate = startDate;\n\n        while (!currentDate.isAfter(endDate)) {\n            int distance = 1; // Default distance\n            if (currentDate.getDayOfWeek() == DayOfWeek.MONDAY || currentDate.getDayOfMonth() == 1) {\n                distance = 2; // Increased distance for Monday or the first day of the month\n            }\n            totalDistance += distance;\n            currentDate = currentDate.plusDays(1); // Move to the next day\n        }\n\n        return totalDistance;\n    }\n\n    public static void main(String[] args) {\n        RunningTracker tracker = new RunningTracker();\n        LocalDate startDate = LocalDate.of(2000, 11, 11);\n        LocalDate endDate = LocalDate.of(2020, 10, 1);\n        long totalKm = tracker.calculateTotalDistance(startDate, endDate);\n        System.out.println(\"Total kilometers run by Xiao Lan from \" + startDate + \" to \" + endDate + \" is: \" + totalKm);\n    }\n}\n```"}
{"user_prompt": "请用java解决下面问题：某系统的进程可能占有和等待一些资源，现给出在某一时刻dump的这些进程占有和等待的资源信息，请按照如下简化规则分析哪些进程发生了 死锁，请升序返回所有死锁的进程ID列表，或空列表 []。\n简化规则如下：\n•如果某个进程 p 的任一等待资源设占有，则该进程必须等待，直到这些资源被释放：等待期间，该进程不会释放所占有的资源。\n如果进程 P 所等传的资源全部部末被其他进程占有，则该进程必将释放所古有的资源。\n基于上，如果某个进程因为所等待的资源一直被古有而无限等待下去，则认为该进程发生了死锁。\n输入\n第一行为一个整数num，表示进程个数;\n第二行开始的num行，依次表示每个进程占有和等待资源的情况，格式为：\n进程ID（占有资源列表）（等待资源列表）。\n0<=进程D<=100,0<=资源编号 <= 300\n每一行的箱入中不会包含重复的资源编号\n输入保证：每个资源最多只会被一个进程占有。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请用java解决下面问题：某系统的进程可能占有和等待一些资源，现给出在某一时刻dump的这些进程占有和等待的资源信息，请按照如下简化规则分析哪些进程发生了 死锁，请升序返回所有死锁的进程ID列表，或空列表 []。\n简化规则如下：\n•如果某个进程 p 的任一等待资源设占有，则该进程必须等待，直到这些资源被释放：等待期间，该进程不会释放所占有的资源。\n如果进程 P 所等传的资源全部部末被其他进程占有，则该进程必将释放所古有的资源。\n基于上，如果某个进程因为所等待的资源一直被古有而无限等待下去，则认为该进程发生了死锁。\n输入\n第一行为一个整数num，表示进程个数;\n第二行开始的num行，依次表示每个进程占有和等待资源的情况，格式为：\n进程ID（占有资源列表）（等待资源列表）。\n0<=进程D<=100,0<=资源编号 <= 300\n每一行的箱入中不会包含重复的资源编号\n输入保证：每个资源最多只会被一个进程占有。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testFindDeadlocks1() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(2, 3)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2), result);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testFindDeadlocks1() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(2, 3)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2), result);\n    }\n}", "_id": 168, "response": "```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Main {\n\n    public static List<Integer> findDeadlocks(Map<Integer, Set<Integer>> holdMap, Map<Integer, Set<Integer>> waitMap) {\n        Set<Integer> deadlockedProcesses = new HashSet<>();\n        Set<Integer> visited = new HashSet<>();\n        \n        for (Integer process : holdMap.keySet()) {\n            if (!visited.contains(process) && isDeadlocked(process, holdMap, waitMap, visited, new HashSet<>())) {\n                deadlockedProcesses.add(process);\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>(deadlockedProcesses);\n        result.sort(Integer::compareTo);\n        return result;\n    }\n\n    private static boolean isDeadlocked(Integer currentProcess, Map<Integer, Set<Integer>> holdMap, Map<Integer, Set<Integer>> waitMap, Set<Integer> visited, Set<Integer> recursionStack) {\n        visited.add(currentProcess);\n        recursionStack.add(currentProcess);\n        \n        Set<Integer> waitingResources = waitMap.getOrDefault(currentProcess, new HashSet<>());\n        for (Integer resource : waitingResources) {\n            for (Integer process : holdMap.keySet()) {\n                if (process.equals(currentProcess)) {\n                    continue;\n                }\n                if (holdMap.get(process).contains(resource)) {\n                    if (!visited.contains(process) && isDeadlocked(process, holdMap, waitMap, visited, recursionStack)) {\n                        return true;\n                    } else if (recursionStack.contains(process)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        recursionStack.remove(currentProcess);\n        return false;\n    }\n}\n```"}
{"user_prompt": "java\n\n对一个字符串，按字典序罗列它的全部排列方式。\n\n输入\n一个字符串（其中可能有相同字符，长度不大于12）\n\n输出\n按ASCII码序，每行一个，罗列它的全部排列方式。\n\n最后一行输出全部排列方式的个数。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\njava\n\n对一个字符串，按字典序罗列它的全部排列方式。\n\n输入\n一个字符串（其中可能有相同字符，长度不大于12）\n\n输出\n按ASCII码序，每行一个，罗列它的全部排列方式。\n\n最后一行输出全部排列方式的个数。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringPermutationsTest {\n\n\n\n    @Test\n    public void testSingleCharacter() {\n        assertEquals(\"Should return one permutation for a single character\", 1, permutations.permute(\"A\").size());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringPermutationsTest {\n\n\n\n    @Test\n    public void testSingleCharacter() {\n        assertEquals(\"Should return one permutation for a single character\", 1, permutations.permute(\"A\").size());\n    }\n}", "_id": 167, "response": "```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class StringPermutations {\n\n    public static List<String> permute(String input) {\n        List<String> results = new ArrayList<>();\n        // Convert the input string to a character array for easy manipulation\n        char[] characters = input.toCharArray();\n        // Sort the characters to ensure the permutations are generated in lexicographic order\n        Arrays.sort(characters);\n        // Generate permutations using a recursive helper function\n        permuteHelper(characters, 0, results);\n        // Print the permutations\n        for (String permutation : results) {\n            System.out.println(permutation);\n        }\n        // Print the total number of permutations\n        System.out.println(results.size());\n        return results;\n    }\n\n    private static void permuteHelper(char[] characters, int index, List<String> results) {\n        if (index == characters.length - 1) {\n            results.add(new String(characters));\n            return;\n        }\n        for (int i = index; i < characters.length; i++) {\n            if (i != index && characters[i] == characters[index]) {\n                continue; // Skip duplicates\n            }\n            swap(characters, index, i);\n            permuteHelper(characters, index + 1, results);\n            swap(characters, index, i); // Backtrack\n        }\n    }\n\n    private static void swap(char[] array, int i, int j) {\n        char temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        // The input string can be passed as a command line argument\n        if (args.length > 0) {\n            permute(args[0]);\n        }\n    }\n}\n```"}
{"user_prompt": "计算正方形的面积和周长\n编程题\n题目描述\n编写程序，输入正方形的边长，计算这个正方形的周长和面积，并将计算结果打印输出。\n输入示例\n10\n输出示例\n边长: 10\n周长: 40\n面积: 100    用Java写出来", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n计算正方形的面积和周长\n编程题\n题目描述\n编写程序，输入正方形的边长，计算这个正方形的周长和面积，并将计算结果打印输出。\n输入示例\n10\n输出示例\n边长: 10\n周长: 40\n面积: 100    用Java写出来\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class SquareTest {\n\n\n    @Test\n    public void testPerimeterWithPositiveSide() {\n        Square square = new Square(10);\n        assertEquals(40, square.getPerimeter(), 0.01);\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class SquareTest {\n\n\n    @Test\n    public void testPerimeterWithPositiveSide() {\n        Square square = new Square(10);\n        assertEquals(40, square.getPerimeter(), 0.01);\n    }\n}", "_id": 169, "response": "```java\nimport java.util.Scanner;\n\npublic class Square {\n    private double sideLength;\n\n    public Square(double sideLength) {\n        this.sideLength = sideLength;\n    }\n\n    public double getPerimeter() {\n        return 4 * sideLength;\n    }\n\n    public double getArea() {\n        return sideLength * sideLength;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"请输入正方形的边长: \");\n        double sideLength = scanner.nextDouble();\n        Square square = new Square(sideLength);\n        System.out.println(\"边长: \" + sideLength);\n        System.out.println(\"周长: \" + square.getPerimeter());\n        System.out.println(\"面积: \" + square.getArea());\n        scanner.close();\n    }\n}\n```"}
{"user_prompt": "long 数据类型最多能表示19位⼗进制整数，那么对于更⼤的整数应该如何描述呢？在包 hugeinteger 中创建功\n能类 HugeInteger ，该类⽤来存放和操作⼀个不超过100位的⼗进制⼤整数。\n1. 2个重载的构造函数，⽀持通过 long 和 String 类型初始化⼀个 HugeInteger 对象。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nlong 数据类型最多能表示19位⼗进制整数，那么对于更⼤的整数应该如何描述呢？在包 hugeinteger 中创建功\n能类 HugeInteger ，该类⽤来存放和操作⼀个不超过100位的⼗进制⼤整数。\n1. 2个重载的构造函数，⽀持通过 long 和 String 类型初始化⼀个 HugeInteger 对象。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass HugeIntegerTest {\n\n    @Test\n    void testConstructorWithLong() {\n        HugeInteger hi = new HugeInteger(1234567890123456789L);\n        assertEquals(\"1234567890123456789\", hi.getValue());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class HugeIntegerTest {\n\n    @Test\n    void testConstructorWithLong() {\n        HugeInteger hi = new HugeInteger(1234567890123456789L);\n        assertEquals(\"1234567890123456789\", hi.getValue());\n    }\n}", "_id": 171, "response": "```java\npackage hugeinteger;\n\nimport java.math.BigInteger;\n\npublic class HugeInteger {\n    private BigInteger value;\n\n    // Constructor using a long value\n    public HugeInteger(long value) {\n        this.value = BigInteger.valueOf(value);\n    }\n\n    // Constructor using a String value\n    public HugeInteger(String value) {\n        this.value = new BigInteger(value);\n    }\n\n    // Method to get the value as a String\n    public String getValue() {\n        return value.toString();\n    }\n\n    // Additional methods for HugeInteger operations can be added here\n    // For example: add, subtract, multiply, divide, etc.\n}\n```"}
{"user_prompt": "小美最近发现了一种有趣的游戏，给定一个队列q，小美会按照以下规则进行游戏：\n\n每次从队列中取出一个数，如果这个数是当前队列中最小的值，那么小美就会丢掉这个数。否则小美就会把这个数重新加入队列。\n\n小美会一直进行游戏直到队列变空为止，但是小美并没有多少耐心，因此她想知道她最多需要进行多少次操作才能结束游戏。 请用java编程解决", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n小美最近发现了一种有趣的游戏，给定一个队列q，小美会按照以下规则进行游戏：\n\n每次从队列中取出一个数，如果这个数是当前队列中最小的值，那么小美就会丢掉这个数。否则小美就会把这个数重新加入队列。\n\n小美会一直进行游戏直到队列变空为止，但是小美并没有多少耐心，因此她想知道她最多需要进行多少次操作才能结束游戏。 请用java编程解决\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMaxOperations1() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(3, 2, 1, 4, 5));\n        assertEquals(12, Main.maxOperations(queue));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testMaxOperations1() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(3, 2, 1, 4, 5));\n        assertEquals(12, Main.maxOperations(queue));\n    }\n}", "_id": 170, "response": "```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n\n    public static int maxOperations(Queue<Integer> queue) {\n        int operations = 0;\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            operations++;\n            for (Integer num : queue) {\n                if (num < current) {\n                    queue.offer(current);\n                    break;\n                }\n            }\n        }\n        return operations;\n    }\n\n    public static void main(String[] args) {\n        Queue<Integer> queue = new LinkedList<>();\n        // Example usage:\n        queue.add(3);\n        queue.add(2);\n        queue.add(1);\n        queue.add(4);\n        queue.add(5);\n        System.out.println(\"Maximum operations needed: \" + maxOperations(queue));\n    }\n}\n```"}
{"user_prompt": "有一个List<Integer>，其内容为 [1,2,3,4,10,12]，如何将其处理为统一用两位数表示的字符串列表，如 1 要变成 01，用java语言操作", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n有一个List<Integer>，其内容为 [1,2,3,4,10,12]，如何将其处理为统一用两位数表示的字符串列表，如 1 要变成 01，用java语言操作\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class NumberFormatterTest {\n\n\n    @Test\n    public void testFormatNumbers() {\n        List<Integer> input = Arrays.asList(1, 2, 3, 4, 10, 12);\n        List<String> expected = Arrays.asList(\"01\", \"02\", \"03\", \"04\", \"10\", \"12\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class NumberFormatterTest {\n\n\n    @Test\n    public void testFormatNumbers() {\n        List<Integer> input = Arrays.asList(1, 2, 3, 4, 10, 12);\n        List<String> expected = Arrays.asList(\"01\", \"02\", \"03\", \"04\", \"10\", \"12\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n}", "_id": 172, "response": "```java\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class NumberFormatter {\n\n    public static List<String> formatNumbers(List<Integer> numbers) {\n        return numbers.stream()\n                .map(number -> String.format(\"%02d\", number))\n                .collect(Collectors.toList());\n    }\n}\n```"}
{"user_prompt": "设计一个表示分数的类Fraction。这个类用两个int类型的变量分别表示分子和分母。注意，在创建和做完运算后应该化简分数为最简形式。如2/4应该被化简为1/2。Java代码", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n设计一个表示分数的类Fraction。这个类用两个int类型的变量分别表示分子和分母。注意，在创建和做完运算后应该化简分数为最简形式。如2/4应该被化简为1/2。Java代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class FractionTest {\n\n\n    @Test\n    public void testConstruct() {\n        Fraction fraction = new Fraction(2, 4);\n        assertEquals(\"1/2\", fraction.toString());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class FractionTest {\n\n\n    @Test\n    public void testConstruct() {\n        Fraction fraction = new Fraction(2, 4);\n        assertEquals(\"1/2\", fraction.toString());\n    }\n}", "_id": 173, "response": "```java\npublic class Fraction {\n    private int numerator;\n    private int denominator;\n\n    public Fraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be zero.\");\n        }\n        int gcd = gcd(numerator, denominator);\n        this.numerator = numerator / gcd;\n        this.denominator = denominator / gcd;\n        if (this.denominator < 0) {\n            this.numerator = -this.numerator;\n            this.denominator = -this.denominator;\n        }\n    }\n\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    @Override\n    public String toString() {\n        return numerator + \"/\" + denominator;\n    }\n\n    // Additional methods for arithmetic operations can be added here\n    // For example: add, subtract, multiply, divide\n}\n```"}
{"user_prompt": "用java编写代码，实现 给定一个非空字符串 word 和缩写 abbr，返回字符串是否可以和给定的缩写匹配。\n比如一个 “word” 的字符串仅包含以下有效缩写：[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java编写代码，实现 给定一个非空字符串 word 和缩写 abbr，返回字符串是否可以和给定的缩写匹配。\n比如一个 “word” 的字符串仅包含以下有效缩写：[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MainTest {\n\n\n    @Test\n    public void testValidSingleDigitAbbreviation() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"1ord\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MainTest {\n\n\n    @Test\n    public void testValidSingleDigitAbbreviation() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"1ord\"));\n    }\n}", "_id": 174, "response": "```java\npublic class Main {\n\n    public static boolean validWordAbbreviation(String word, String abbr) {\n        int wordIndex = 0, abbrIndex = 0;\n        while (wordIndex < word.length() && abbrIndex < abbr.length()) {\n            if (Character.isDigit(abbr.charAt(abbrIndex))) {\n                if (abbr.charAt(abbrIndex) == '0') {\n                    return false; // Leading zeros are not allowed\n                }\n                int start = abbrIndex;\n                while (abbrIndex < abbr.length() && Character.isDigit(abbr.charAt(abbrIndex))) {\n                    abbrIndex++;\n                }\n                int num = Integer.parseInt(abbr.substring(start, abbrIndex));\n                wordIndex += num;\n            } else {\n                if (word.charAt(wordIndex) != abbr.charAt(abbrIndex)) {\n                    return false;\n                }\n                wordIndex++;\n                abbrIndex++;\n            }\n        }\n        return wordIndex == word.length() && abbrIndex == abbr.length();\n    }\n\n    public static void main(String[] args) {\n        // Example test case\n        System.out.println(validWordAbbreviation(\"word\", \"1ord\")); // Should return true\n    }\n}\n```"}
{"user_prompt": "请设计一个递归分段求和函数sum（int start,int End）用于计算机Start至End间的整数和，当Start<End时计算Sum＝Start+（Start+1）+……+End;当Start=End时则返回Start;当Start>End时则返回0输入包含多组测试数据，每组数据包含两个整数Start与End,输出每组数据的计算结果，每组测试数据的计算结果占一行", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请设计一个递归分段求和函数sum（int start,int End）用于计算机Start至End间的整数和，当Start<End时计算Sum＝Start+（Start+1）+……+End;当Start=End时则返回Start;当Start>End时则返回0输入包含多组测试数据，每组数据包含两个整数Start与End,输出每组数据的计算结果，每组测试数据的计算结果占一行\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSum1() {\n        assertEquals(0, Main.sum(5, 3));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSum1() {\n        assertEquals(0, Main.sum(5, 3));\n    }\n}", "_id": 175, "response": "```java\npublic class Main {\n\n    public static void main(String[] args) {\n        // 示例输入\n        int[][] testCases = {\n            {5, 3},\n            {1, 5},\n            {10, 10},\n            {0, 0},\n            {-1, 2}\n        };\n\n        // 对每组测试数据调用sum函数并打印结果\n        for (int[] testCase : testCases) {\n            int start = testCase[0];\n            int end = testCase[1];\n            System.out.println(sum(start, end));\n        }\n    }\n\n    public static int sum(int start, int end) {\n        if (start > end) {\n            return 0;\n        } else if (start == end) {\n            return start;\n        } else {\n            return start + sum(start + 1, end);\n        }\n    }\n}\n```"}
{"user_prompt": "编写一个Java程序，声明两个整数变量x，y，分别初始化为5和7。然后执行以下操作：\n1、使用前缀递增运算符将第一个整数增加1，并将结果赋值给变量a。\n2、使用后缀递减运算符将第二个整数减少1，并将结果赋值给变量b。\n3、输出a和b的最终值。\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个Java程序，声明两个整数变量x，y，分别初始化为5和7。然后执行以下操作：\n1、使用前缀递增运算符将第一个整数增加1，并将结果赋值给变量a。\n2、使用后缀递减运算符将第二个整数减少1，并将结果赋值给变量b。\n3、输出a和b的最终值。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class IncrementDecrementTest {\n\n\n    @Test\n    public void testIncrement() {\n        assertEquals(\"Increment 5 should be 6\", 6, incDec.increment(5));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class IncrementDecrementTest {\n\n\n    @Test\n    public void testIncrement() {\n        assertEquals(\"Increment 5 should be 6\", 6, incDec.increment(5));\n    }\n}", "_id": 177, "response": "```java\npublic class IncrementDecrement {\n\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 7;\n        int a = ++x; // Prefix increment of x\n        int b = y--; // Postfix decrement of y\n\n        System.out.println(\"The value of a: \" + a);\n        System.out.println(\"The value of b: \" + b);\n    }\n\n    public int increment(int value) {\n        return ++value;\n    }\n}\n```"}
{"user_prompt": "编写3个基本类： Triangle, Ladder和Circle，分别用来刻画“三角形”、“梯形”和“圆形”类； 1个主类： Compute，负责计算每个形状的面积或周长。\n具体要求：\nTriangle 定义3个变量：边长；和1个求周长的方法。\nLadder  定义3个变量：上底，下底和高；定义1个求面积的方法\nCircle  定义1个变量：半径；定义2个方法：求面积、求周长。\n3个基本类都要定义相应的构造方法，对变量进行初始化。用Java编写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写3个基本类： Triangle, Ladder和Circle，分别用来刻画“三角形”、“梯形”和“圆形”类； 1个主类： Compute，负责计算每个形状的面积或周长。\n具体要求：\nTriangle 定义3个变量：边长；和1个求周长的方法。\nLadder  定义3个变量：上底，下底和高；定义1个求面积的方法\nCircle  定义1个变量：半径；定义2个方法：求面积、求周长。\n3个基本类都要定义相应的构造方法，对变量进行初始化。用Java编写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TriangleTest {\n\n    @Test\n    void calculatePerimeter() {\n        Triangle triangle = new Triangle(5);\n        assertEquals(15, triangle.calculatePerimeter());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class TriangleTest {\n\n    @Test\n    void calculatePerimeter() {\n        Triangle triangle = new Triangle(5);\n        assertEquals(15, triangle.calculatePerimeter());\n    }\n}", "_id": 176, "response": "```java\nclass Triangle {\n    private double side;\n\n    public Triangle(double side) {\n        this.side = side;\n    }\n\n    public double calculatePerimeter() {\n        return 3 * side;\n    }\n}\n\nclass Ladder {\n    private double topWidth;\n    private double bottomWidth;\n    private double height;\n\n    public Ladder(double topWidth, double bottomWidth, double height) {\n        this.topWidth = topWidth;\n        this.bottomWidth = bottomWidth;\n        this.height = height;\n    }\n\n    public double calculateArea() {\n        return (topWidth + bottomWidth) * height / 2;\n    }\n}\n\nclass Circle {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n\n    public double calculatePerimeter() {\n        return 2 * Math.PI * radius;\n    }\n}\n\nclass Compute {\n    public static void main(String[] args) {\n        Triangle triangle = new Triangle(5);\n        Ladder ladder = new Ladder(3, 4, 5);\n        Circle circle = new Circle(2);\n\n        double trianglePerimeter = triangle.calculatePerimeter();\n        double ladderArea = ladder.calculateArea();\n        double circleArea = circle.calculateArea();\n        double circlePerimeter = circle.calculatePerimeter();\n\n        System.out.println(\"Triangle perimeter: \" + trianglePerimeter);\n        System.out.println(\"Ladder area: \" + ladderArea);\n        System.out.println(\"Circle area: \" + circleArea);\n        System.out.println(\"Circle perimeter: \" + circlePerimeter);\n    }\n}\n```"}
{"user_prompt": "编写一个方法，计算给定的两个数组之和，格式如下：\r\n6.1.1\r\npublic static int[] sumArray(int[] a, int[] b)\r\n要求返回的数组元素是两个参数数组对应元素之和，不对\r\n应的元素直接赋给相应的位置，例如，{1,2,4} + \r\n{2,4,6,8}={3,6,10,8}。\r\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个方法，计算给定的两个数组之和，格式如下：\r\n6.1.1\r\npublic static int[] sumArray(int[] a, int[] b)\r\n要求返回的数组元素是两个参数数组对应元素之和，不对\r\n应的元素直接赋给相应的位置，例如，{1,2,4} + \r\n{2,4,6,8}={3,6,10,8}。\r\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSumArray1() {\n        assertArrayEquals(new int[]{3,6,10,8}, Main.sumArray(new int[]{1,2,4}, new int[]{2,4,6,8}));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testSumArray1() {\n        assertArrayEquals(new int[]{3,6,10,8}, Main.sumArray(new int[]{1,2,4}, new int[]{2,4,6,8}));\n    }\n}", "_id": 178, "response": "```java\npublic class Main {\n\n    public static int[] sumArray(int[] a, int[] b) {\n        int maxLength = Math.max(a.length, b.length);\n        int[] result = new int[maxLength];\n\n        for (int i = 0; i < maxLength; i++) {\n            int aValue = (i < a.length) ? a[i] : 0;\n            int bValue = (i < b.length) ? b[i] : 0;\n            result[i] = aValue + bValue;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example usage of the sumArray method\n        int[] array1 = {1, 2, 4};\n        int[] array2 = {2, 4, 6, 8};\n        int[] sum = sumArray(array1, array2);\n\n        // Output the result\n        for (int value : sum) {\n            System.out.print(value + \" \");\n        }\n    }\n}\n```"}
{"user_prompt": "需求描述:国家实行无偿献血制度，对于献血者的体格检查的部分标准为：年龄为18～55周\n岁，男性体重≥ 50kg，女性本重 ≥45kg，每次献血量为200m1~400ml。用Java编写程序实现输入献血的年龄，性别，体重，判断其是否能进行献血。\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n需求描述:国家实行无偿献血制度，对于献血者的体格检查的部分标准为：年龄为18～55周\n岁，男性体重≥ 50kg，女性本重 ≥45kg，每次献血量为200m1~400ml。用Java编写程序实现输入献血的年龄，性别，体重，判断其是否能进行献血。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class BloodDonationEligibilityTest {\n\n\n    @Test\n    public void testEligibleMale() {\n        assertTrue(\"A male aged 30 weighing 60kg should be eligible\", eligibility.isEligibleForDonation(30, \"male\", 60));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class BloodDonationEligibilityTest {\n\n\n    @Test\n    public void testEligibleMale() {\n        assertTrue(\"A male aged 30 weighing 60kg should be eligible\", eligibility.isEligibleForDonation(30, \"male\", 60));\n    }\n}", "_id": 180, "response": "```java\npublic class BloodDonationEligibility {\n\n    public static boolean isEligibleForDonation(int age, String gender, double weight) {\n        if (age < 18 || age > 55) {\n            return false;\n        }\n        if (\"male\".equalsIgnoreCase(gender) && weight >= 50) {\n            return true;\n        }\n        if (\"female\".equalsIgnoreCase(gender) && weight >= 45) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        boolean isEligible = isEligibleForDonation(30, \"male\", 60);\n        System.out.println(\"Is the person eligible for donation? \" + isEligible);\n    }\n}\n```"}
{"user_prompt": "请帮我实现一段java代码，实现：输入一段字符串，其中会含有<a>标签 ，输出的是处理过的字符串，要求：1、被<a> </a>所包裹的内容保持不变 2、没有被<a>标签包裹的内容需要被<b>标签包裹", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请帮我实现一段java代码，实现：输入一段字符串，其中会含有<a>标签 ，输出的是处理过的字符串，要求：1、被<a> </a>所包裹的内容保持不变 2、没有被<a>标签包裹的内容需要被<b>标签包裹\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testWrapNonATagContent1() {\n        String input = \"Hello <a>World</a>!\";\n        String expected = \"<b>Hello </b><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testWrapNonATagContent1() {\n        String input = \"Hello <a>World</a>!\";\n        String expected = \"<b>Hello </b><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n}", "_id": 179, "response": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n    public static String wrapNonATagContent(String input) {\n        StringBuilder output = new StringBuilder();\n        Pattern pattern = Pattern.compile(\"(.*?)<a>(.*?)</a>\", Pattern.DOTALL);\n        Matcher matcher = pattern.matcher(input);\n        int lastEnd = 0;\n\n        while (matcher.find()) {\n            String beforeATag = matcher.group(1);\n            String aTagContent = matcher.group(0); // includes <a>...</a>\n            if (!beforeATag.isEmpty()) {\n                output.append(\"<b>\").append(beforeATag).append(\"</b>\");\n            }\n            output.append(aTagContent);\n            lastEnd = matcher.end();\n        }\n\n        if (lastEnd < input.length()) {\n            output.append(\"<b>\").append(input.substring(lastEnd)).append(\"</b>\");\n        }\n\n        return output.toString();\n    }\n\n    public static void main(String[] args) {\n        String input = \"Hello <a>World</a>!\";\n        String result = wrapNonATagContent(input);\n        System.out.println(result);\n    }\n}\n```"}
{"user_prompt": "Java方法重载自定义一个求最大值的类。\n求三个数中最大值的方法，并实现方法重载，要求能够分别比较三个整数中的最大值，三个小数中的最大值，以及任意三个数中的最大值。\n", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava方法重载自定义一个求最大值的类。\n求三个数中最大值的方法，并实现方法重载，要求能够分别比较三个整数中的最大值，三个小数中的最大值，以及任意三个数中的最大值。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MaxValueTest {\n\n    @Test\n    void testMaxInt() {\n        MaxValue maxValue = new MaxValue();\n        assertEquals(9, maxValue.max(3, 5, 9));\n        assertEquals(0, maxValue.max(0, -1, -2));\n        assertEquals(100, maxValue.max(100, 100, 100));\n        assertEquals(-1, maxValue.max(-1, -2, -3));\n        assertEquals(Integer.MAX_VALUE, maxValue.max(Integer.MAX_VALUE, 0, -1));\n        assertEquals(Integer.MIN_VALUE, maxValue.max(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MaxValueTest {\n\n    @Test\n    void testMaxInt() {\n        MaxValue maxValue = new MaxValue();\n        assertEquals(9, maxValue.max(3, 5, 9));\n        assertEquals(0, maxValue.max(0, -1, -2));\n        assertEquals(100, maxValue.max(100, 100, 100));\n        assertEquals(-1, maxValue.max(-1, -2, -3));\n        assertEquals(Integer.MAX_VALUE, maxValue.max(Integer.MAX_VALUE, 0, -1));\n        assertEquals(Integer.MIN_VALUE, maxValue.max(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}", "_id": 182, "response": "```java\npublic class MaxValue {\n\n    // Method to find the maximum of three integers\n    public int max(int a, int b, int c) {\n        return Math.max(a, Math.max(b, c));\n    }\n\n    // Method to find the maximum of three doubles\n    public double max(double a, double b, double c) {\n        return Math.max(a, Math.max(b, c));\n    }\n\n    // Method to find the maximum of three numbers using generics\n    public <T extends Comparable<T>> T max(T a, T b, T c) {\n        T maxVal = a;\n        if (b.compareTo(maxVal) > 0) {\n            maxVal = b;\n        }\n        if (c.compareTo(maxVal) > 0) {\n            maxVal = c;\n        }\n        return maxVal;\n    }\n}\n```"}
{"user_prompt": "Java中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "_id": 183, "response": "```java\npublic class StringUtils {\n\n    public static String alternateCase(String input) {\n        StringBuilder sb = new StringBuilder(input.length());\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (i % 2 == 0) {\n                sb.append(Character.toUpperCase(c));\n            } else {\n                sb.append(Character.toLowerCase(c));\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(alternateCase(\"legendary\"));\n    }\n}\n```"}
{"user_prompt": "给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。\n\n如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。\n\n返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。\n\n使用java解答", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。\n\n如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。\n\n返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。\n\n使用java解答\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCountVowelStrings1() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 1, 5));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testCountVowelStrings1() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 1, 5));\n    }\n}", "_id": 181, "response": "```java\npublic class Main {\n\n    public static void main(String[] args) {\n        // Example usage of the countVowelStrings method\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        int count = countVowelStrings(words, 1, 5);\n        System.out.println(\"Number of vowel strings: \" + count);\n    }\n\n    public static int countVowelStrings(String[] words, int left, int right) {\n        int vowelStringsCount = 0;\n        for (int i = left; i <= right && i < words.length; i++) {\n            String word = words[i].toLowerCase();\n            if (isVowel(word.charAt(0)) && isVowel(word.charAt(word.length() - 1))) {\n                vowelStringsCount++;\n            }\n        }\n        return vowelStringsCount;\n    }\n\n    private static boolean isVowel(char c) {\n        return \"aeiou\".indexOf(c) != -1;\n    }\n}\n```"}
{"user_prompt": "用java编写一个切换java jdk版本的程序，用于切换jdk1.7，1.8以及jdk11,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java编写一个切换java jdk版本的程序，用于切换jdk1.7，1.8以及jdk11,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass CommentRemoverTest {\n\n    @Test\n    void testRemoveCommentsFromFile1() {\n        CommentRemover.removeCommentsFromFile(\"test1/test.java\", \"test1/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test1/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class CommentRemoverTest {\n\n    @Test\n    void testRemoveCommentsFromFile1() {\n        CommentRemover.removeCommentsFromFile(\"test1/test.java\", \"test1/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test1/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "_id": 184, "response": "```java\nimport java.io.*;\n\npublic class JDKSwitcher {\n\n    private static final String JAVA_HOME = \"JAVA_HOME\";\n    private static final String PATH = \"Path\";\n\n    public static void switchJDK(String version) {\n        String jdkPath = getJDKPathByVersion(version);\n        if (jdkPath == null) {\n            System.out.println(\"JDK version \" + version + \" is not supported or not configured.\");\n            return;\n        }\n\n        setEnvironmentVariable(JAVA_HOME, jdkPath);\n        updateSystemPath(jdkPath);\n        System.out.println(\"Switched to JDK \" + version);\n    }\n\n    private static String getJDKPathByVersion(String version) {\n        // These paths should be configured according to the actual installation directories of the JDKs\n        switch (version) {\n            case \"1.7\":\n                return \"C:\\\\path\\\\to\\\\jdk1.7\";\n            case \"1.8\":\n                return \"C:\\\\path\\\\to\\\\jdk1.8\";\n            case \"11\":\n                return \"C:\\\\path\\\\to\\\\jdk11\";\n            default:\n                return null;\n        }\n    }\n\n    private static void setEnvironmentVariable(String variableName, String value) {\n        // This is a simplified way to set an environment variable for the current process.\n        // It does not change the system-wide environment variable.\n        System.setProperty(variableName, value);\n    }\n\n    private static void updateSystemPath(String jdkBinPath) {\n        // This is a simplified way to update the system path for the current process.\n        // It does not change the system-wide PATH environment variable.\n        String currentPath = System.getProperty(PATH);\n        String jdkBin = jdkBinPath + File.separator + \"bin\";\n        if (currentPath != null && !currentPath.contains(jdkBin)) {\n            String updatedPath = jdkBin + File.pathSeparator + currentPath;\n            System.setProperty(PATH, updatedPath);\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: JDKSwitcher <version>\");\n            return;\n        }\n        switchJDK(args[0]);\n    }\n}\n```\n\nPlease note that this code is a simplified example of how you might switch JDK versions within a running Java application. It does not actually change the system-wide `JAVA_HOME` or `Path` environment variables, which would require administrative privileges and a different approach (such as using native code or shell scripts). The code only changes the environment variables for the current Java process. To truly switch JDK versions system-wide, you would typically need to modify the environment variables outside of Java, such as through a batch file or shell script."}
{"user_prompt": "用java语法,读取java文件并去除其中的所有注释，可以使用正则表达式或解析器来实现,输出去除所有注释的文件,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java语法,读取java文件并去除其中的所有注释，可以使用正则表达式或解析器来实现,输出去除所有注释的文件,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ImageClassifierTest {\n\n    @Test\n    public void testClassifyImages_case1() {\n        ImageClassifier.classifyImages(\"test1\", 280, 440);\n        assertTrue((new File(\"test1/folder_1/1.jpg\").exists()));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class ImageClassifierTest {\n\n    @Test\n    public void testClassifyImages_case1() {\n        ImageClassifier.classifyImages(\"test1\", 280, 440);\n        assertTrue((new File(\"test1/folder_1/1.jpg\").exists()));\n    }\n}", "_id": 185, "response": "```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class CommentRemover {\n\n    public static void removeCommentsFromFile(String inputFilePath, String outputFilePath) throws IOException {\n        BufferedReader reader = null;\n        BufferedWriter writer = null;\n\n        try {\n            reader = new BufferedReader(new FileReader(inputFilePath));\n            writer = new BufferedWriter(new FileWriter(outputFilePath));\n\n            String line;\n            boolean inBlockComment = false;\n\n            while ((line = reader.readLine()) != null) {\n                if (inBlockComment) {\n                    if (line.contains(\"*/\")) {\n                        line = line.substring(line.indexOf(\"*/\") + 2);\n                        inBlockComment = false;\n                    } else {\n                        continue;\n                    }\n                }\n\n                while (line.contains(\"/*\")) {\n                    int start = line.indexOf(\"/*\");\n                    int end = line.indexOf(\"*/\", start + 2);\n\n                    if (end == -1) {\n                        line = line.substring(0, start);\n                        inBlockComment = true;\n                        break;\n                    } else {\n                        line = line.substring(0, start) + line.substring(end + 2);\n                    }\n                }\n\n                if (!inBlockComment) {\n                    int singleLineCommentIndex = line.indexOf(\"//\");\n                    if (singleLineCommentIndex != -1) {\n                        line = line.substring(0, singleLineCommentIndex);\n                    }\n                }\n\n                line = line.trim();\n                if (!line.isEmpty()) {\n                    writer.write(line);\n                    writer.newLine();\n                }\n            }\n        } finally {\n            if (reader != null) {\n                reader.close();\n            }\n            if (writer != null) {\n                writer.close();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String inputFilePath = \"path/to/input/JavaFile.java\";\n        String outputFilePath = \"path/to/output/JavaFileWithoutComments.java\";\n\n        try {\n            removeCommentsFromFile(inputFilePath, outputFilePath);\n            System.out.println(\"Comments have been successfully removed from the file.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nThis Java code defines a class `CommentRemover` with a method `removeCommentsFromFile` that reads a Java file, removes all comments, and writes the result to a new file. The `main` method demonstrates how to use this method. Please replace `path/to/input/JavaFile.java` and `path/to/output/JavaFileWithoutComments.java` with the actual paths to your input and output files."}
{"user_prompt": "用java函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TestConvertLabels {\n\n\n    @Test\n    void testConvertLabels1(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>1</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class TestConvertLabels {\n\n\n    @Test\n    void testConvertLabels1(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>1</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n}", "_id": 187, "response": "```java\nimport java.util.Arrays;\n\npublic class DistanceMetrics {\n\n    // Calculate Euclidean distance\n    public static double euclideanDistance(double[] a, double[] b) {\n        double sum = 0.0;\n        for (int i = 0; i < a.length; i++) {\n            sum += Math.pow(a[i] - b[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n\n    // Calculate Manhattan distance\n    public static double manhattanDistance(double[] a, double[] b) {\n        double sum = 0.0;\n        for (int i = 0; i < a.length; i++) {\n            sum += Math.abs(a[i] - b[i]);\n        }\n        return sum;\n    }\n\n    // Calculate Chebyshev distance\n    public static double chebyshevDistance(double[] a, double[] b) {\n        double max = 0.0;\n        for (int i = 0; i < a.length; i++) {\n            max = Math.max(max, Math.abs(a[i] - b[i]));\n        }\n        return max;\n    }\n\n    // Calculate Minkowski distance\n    public static double minkowskiDistance(double[] a, double[] b, double p) {\n        double sum = 0.0;\n        for (int i = 0; i < a.length; i++) {\n            sum += Math.pow(Math.abs(a[i] - b[i]), p);\n        }\n        return Math.pow(sum, 1 / p);\n    }\n\n    // Calculate Cosine similarity\n    public static double cosineSimilarity(double[] a, double[] b) {\n        double dotProduct = 0.0;\n        double normA = 0.0;\n        double normB = 0.0;\n        for (int i = 0; i < a.length; i++) {\n            dotProduct += a[i] * b[i];\n            normA += Math.pow(a[i], 2);\n            normB += Math.pow(b[i], 2);\n        }\n        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n    }\n\n    // Calculate Hamming distance\n    public static int hammingDistance(String a, String b) {\n        int distance = 0;\n        for (int i = 0; i < a.length(); i++) {\n            if (a.charAt(i) != b.charAt(i)) {\n                distance++;\n            }\n        }\n        return distance;\n    }\n\n    // Calculate Jaccard similarity\n    public static double jaccardSimilarity(double[] a, double[] b) {\n        double intersection = 0.0;\n        double union = 0.0;\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] == b[i]) {\n                intersection++;\n            }\n            union++;\n        }\n        return intersection / union;\n    }\n\n    public static void main(String[] args) {\n        double[] vectorA = {1.0, 2.0, 3.0};\n        double[] vectorB = {2.0, 3.0, 4.0};\n        String stringA = \"11001\";\n        String stringB = \"10011\";\n\n        System.out.println(\"Euclidean Distance: \" + euclideanDistance(vectorA, vectorB));\n        System.out.println(\"Manhattan Distance: \" + manhattanDistance(vectorA, vectorB));\n        System.out.println(\"Chebyshev Distance: \" + chebyshevDistance(vectorA, vectorB));\n        System.out.println(\"Minkowski Distance (p=3): \" + minkowskiDistance(vectorA, vectorB, 3));\n        System.out.println(\"Cosine Similarity: \" + cosineSimilarity(vectorA, vectorB));\n        System.out.println(\"Hamming Distance: \" + hammingDistance(stringA, stringB));\n        System.out.println(\"Jaccard Similarity: \" + jaccardSimilarity(vectorA, vectorB));\n    }\n}\n```"}
{"user_prompt": "用java标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddUser1() {\n        UserManager userManager = new UserManager();\n        // Test case 1: Invalid name\n        assertEquals(\"Name illegal\", userManager.addUser(\"123\", \"M\", \"000100200000\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MainTest {\n\n    @Test\n    void testAddUser1() {\n        UserManager userManager = new UserManager();\n        // Test case 1: Invalid name\n        assertEquals(\"Name illegal\", userManager.addUser(\"123\", \"M\", \"000100200000\"));\n    }\n}", "_id": 188, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BoundingBox {\n    public double xmin;\n    public double ymin;\n    public double xmax;\n    public double ymax;\n    public int category;\n\n    public BoundingBox(double xmin, double ymin, double xmax, double ymax, int category) {\n        this.xmin = xmin;\n        this.ymin = ymin;\n        this.xmax = xmax;\n        this.ymax = ymax;\n        this.category = category;\n    }\n\n    public double getArea() {\n        return (xmax - xmin) * (ymax - ymin);\n    }\n}\n\npublic class IoUHelper {\n    public static double calculateIoU(BoundingBox box1, BoundingBox box2) {\n        double intersectionXmin = Math.max(box1.xmin, box2.xmin);\n        double intersectionYmin = Math.max(box1.ymin, box2.ymin);\n        double intersectionXmax = Math.min(box1.xmax, box2.xmax);\n        double intersectionYmax = Math.min(box1.ymax, box2.ymax);\n\n        double intersectionArea = Math.max(0, intersectionXmax - intersectionXmin) *\n                                  Math.max(0, intersectionYmax - intersectionYmin);\n\n        double unionArea = box1.getArea() + box2.getArea() - intersectionArea;\n\n        return (unionArea == 0) ? 0 : intersectionArea / unionArea;\n    }\n\n    public static void categorizeBoxes(List<BoundingBox> boxes, BoundingBox region, double threshold) {\n        for (BoundingBox box : boxes) {\n            if (calculateIoU(box, region) > threshold) {\n                box.category = 0;\n            }\n        }\n    }\n}\n\npublic class UserManager {\n    // Other methods of UserManager\n\n    public String addUser(String name, String gender, String id) {\n        // Implementation of addUser method\n        // This is a placeholder for the actual implementation\n        return \"\";\n    }\n}\n\n// Example usage:\n// List<BoundingBox> boxes = new ArrayList<>();\n// boxes.add(new BoundingBox(10, 10, 50, 50, 1));\n// BoundingBox region = new BoundingBox(20, 20, 60, 60, -1);\n// IoUHelper.categorizeBoxes(boxes, region, 0.2);\n// for (BoundingBox box : boxes) {\n//     System.out.println(\"Category: \" + box.category);\n// }\n```"}
{"user_prompt": "java语言根据图像长宽设定三个阈值进行分类，当长或宽小于阈值100时输出到文件夹folder_1，当长或宽大于阈值100小于阈值200时输出到文件夹folder_2，其它输出到文件夹folder_3,", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\njava语言根据图像长宽设定三个阈值进行分类，当长或宽小于阈值100时输出到文件夹folder_1，当长或宽大于阈值100小于阈值200时输出到文件夹folder_2，其它输出到文件夹folder_3,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass DistanceTest {\n\n    @Test\n    void testEuclideanDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(5.196152422706632, Distance.euclideanDistance(pointA, pointB));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class DistanceTest {\n\n    @Test\n    void testEuclideanDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(5.196152422706632, Distance.euclideanDistance(pointA, pointB));\n    }\n}", "_id": 186, "response": "```java\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ImageClassifier {\n\n    public static void classifyImage(int width, int height) {\n        String targetFolder;\n        if (width < 100 || height < 100) {\n            targetFolder = \"folder_1\";\n        } else if (width < 200 && height < 200) {\n            targetFolder = \"folder_2\";\n        } else {\n            targetFolder = \"folder_3\";\n        }\n        moveImageToFolder(targetFolder);\n    }\n\n    private static void moveImageToFolder(String folderName) {\n        // Assuming the image is represented as a File object named imageFile\n        File imageFile = getImageFile(); // Placeholder for the actual image file retrieval method\n        File targetDirectory = new File(folderName);\n\n        if (!targetDirectory.exists()) {\n            targetDirectory.mkdirs();\n        }\n\n        File dest = new File(targetDirectory, imageFile.getName());\n        try {\n            if (imageFile.renameTo(dest)) {\n                System.out.println(\"Image moved successfully to \" + folderName);\n            } else {\n                System.out.println(\"Failed to move the image to \" + folderName);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static File getImageFile() {\n        // Placeholder method to simulate retrieving an image file\n        // In a real scenario, this method would return the actual image file to be classified\n        return new File(\"path/to/image.jpg\");\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        classifyImage(150, 99); // Should move the image to folder_1\n        classifyImage(150, 150); // Should move the image to folder_2\n        classifyImage(250, 300); // Should move the image to folder_3\n    }\n}\n```"}
{"user_prompt": "请用java语言为用户设立一个 User 类：\n私有属性至少包括姓名（仅可能由 26 个字母大小写和下划线构成）、性别（字符 M/F/O，分别表示男性/女性/其他）、ID卡号（符合下述合法格式）\nID卡号一共12位，每个用户唯一\n前4位的范围是[0001,1237]\n中间4位的范围为[0020,0460]\n最后四位为生物识别库提供的生物识别码，前三位的范围为[000,100]，最后一位表示持有人的性别，0代表女性，1代表男性，2代表其他。\n合法的ID卡号示例：\n0023 0122 0991\n1000 0072 0000\n不合法的ID卡号示例：\n0000 0122 0991\n0030 0500 1010\n1234 0123 0553\n需要为用户的3种属性提供相应的 getter 和 setter 方法\n实现方法 String toString() 打印用户格式化信息，具体要求如下：\n1.冒号为英文字符 :\n2.不包含多余的空格\n3.所有字符为半角字符\n以 jack，ID卡号 0910 0072 0112 为例：\nName:jack\nSex:O\nID:091000720112 \n实现添加用户方法，命令格式如下：\n选项\t[参数 1]\t[参数 2]\t[参数 3]\t功能描述\naddUser\t姓名\t性别\t卡号\t新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。\n具体要求如下：\n在输入 addUser 命令时，并不保证参数数量严格对应，这也是一种非法情况，需要在终端输出：\nArguments illegal\n如果参数合法，按以下顺序依次进行信息检查\n姓名由 26 个字母和下划线构成，其他情况请输出\nName illegal\n性别必须为 F / M / O，其他情况请输出\nSex illegal\n卡号需满足指定格式，非法（包括尾号和性别不符的情况）请输出\nID number illegal\n一张卡号只能注册一次，若注册卡号已存在请输出\nID number exist\n如果存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n如果输入合法，按 toString() 输出格式打印刚添加的用户信息。如：\naddUser LaoWang M\nArguments illegal\naddUser LaoWang GHS 123123\nSex illegal\naddUser LaoWang M 003005001010\nAadhaar number illegal\naddUser LaoWang M 002301220991\nName:LaoWang\nSex:M\nAadhaar:002301220991\naddUser HaiWang M 002301220991\nAadhaar number exist", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请用java语言为用户设立一个 User 类：\n私有属性至少包括姓名（仅可能由 26 个字母大小写和下划线构成）、性别（字符 M/F/O，分别表示男性/女性/其他）、ID卡号（符合下述合法格式）\nID卡号一共12位，每个用户唯一\n前4位的范围是[0001,1237]\n中间4位的范围为[0020,0460]\n最后四位为生物识别库提供的生物识别码，前三位的范围为[000,100]，最后一位表示持有人的性别，0代表女性，1代表男性，2代表其他。\n合法的ID卡号示例：\n0023 0122 0991\n1000 0072 0000\n不合法的ID卡号示例：\n0000 0122 0991\n0030 0500 1010\n1234 0123 0553\n需要为用户的3种属性提供相应的 getter 和 setter 方法\n实现方法 String toString() 打印用户格式化信息，具体要求如下：\n1.冒号为英文字符 :\n2.不包含多余的空格\n3.所有字符为半角字符\n以 jack，ID卡号 0910 0072 0112 为例：\nName:jack\nSex:O\nID:091000720112 \n实现添加用户方法，命令格式如下：\n选项\t[参数 1]\t[参数 2]\t[参数 3]\t功能描述\naddUser\t姓名\t性别\t卡号\t新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。\n具体要求如下：\n在输入 addUser 命令时，并不保证参数数量严格对应，这也是一种非法情况，需要在终端输出：\nArguments illegal\n如果参数合法，按以下顺序依次进行信息检查\n姓名由 26 个字母和下划线构成，其他情况请输出\nName illegal\n性别必须为 F / M / O，其他情况请输出\nSex illegal\n卡号需满足指定格式，非法（包括尾号和性别不符的情况）请输出\nID number illegal\n一张卡号只能注册一次，若注册卡号已存在请输出\nID number exist\n如果存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n如果输入合法，按 toString() 输出格式打印刚添加的用户信息。如：\naddUser LaoWang M\nArguments illegal\naddUser LaoWang GHS 123123\nSex illegal\naddUser LaoWang M 003005001010\nAadhaar number illegal\naddUser LaoWang M 002301220991\nName:LaoWang\nSex:M\nAadhaar:002301220991\naddUser HaiWang M 002301220991\nAadhaar number exist\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass CopyFileTest {\n\n\n    @Test\n    void testCopyAndMoveFile1() {\n        String sourceFilePath = \"test1/test.txt\";\n        String destinationDirectory = \"test1/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class CopyFileTest {\n\n\n    @Test\n    void testCopyAndMoveFile1() {\n        String sourceFilePath = \"test1/test.txt\";\n        String destinationDirectory = \"test1/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n}", "_id": 189, "response": "```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\npublic class User {\n    private static final Map<String, User> usersById = new HashMap<>();\n    private static final Pattern namePattern = Pattern.compile(\"^[a-zA-Z_]+$\");\n    private static final Pattern idPattern = Pattern.compile(\"^(\\\\d{4}) (\\\\d{4}) (\\\\d{3}[012])$\");\n\n    private String name;\n    private char sex; // 'M', 'F', or 'O'\n    private String idCardNumber;\n\n    public User(String name, char sex, String idCardNumber) {\n        this.name = name;\n        this.sex = sex;\n        this.idCardNumber = idCardNumber;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        if (namePattern.matcher(name).matches()) {\n            this.name = name;\n        } else {\n            throw new IllegalArgumentException(\"Name illegal\");\n        }\n    }\n\n    public char getSex() {\n        return sex;\n    }\n\n    public void setSex(char sex) {\n        if (sex == 'M' || sex == 'F' || sex == 'O') {\n            this.sex = sex;\n        } else {\n            throw new IllegalArgumentException(\"Sex illegal\");\n        }\n    }\n\n    public String getIdCardNumber() {\n        return idCardNumber;\n    }\n\n    public void setIdCardNumber(String idCardNumber) {\n        if (isValidIdCardNumber(idCardNumber)) {\n            this.idCardNumber = idCardNumber;\n        } else {\n            throw new IllegalArgumentException(\"ID number illegal\");\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"Name:\" + name + \"\\nSex:\" + sex + \"\\nID:\" + idCardNumber.replace(\" \", \"\");\n    }\n\n    public static void addUser(String name, char sex, String idCardNumber) {\n        try {\n            if (!namePattern.matcher(name).matches()) {\n                System.out.println(\"Name illegal\");\n                return;\n            }\n            if (sex != 'M' && sex != 'F' && sex != 'O') {\n                System.out.println(\"Sex illegal\");\n                return;\n            }\n            if (!isValidIdCardNumber(idCardNumber)) {\n                System.out.println(\"ID number illegal\");\n                return;\n            }\n            if (usersById.containsKey(idCardNumber)) {\n                System.out.println(\"ID number exist\");\n                return;\n            }\n            User user = new User(name, sex, idCardNumber);\n            usersById.put(idCardNumber, user);\n            System.out.println(user);\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    private static boolean isValidIdCardNumber(String idCardNumber) {\n        if (!idPattern.matcher(idCardNumber).matches()) {\n            return false;\n        }\n        String[] parts = idCardNumber.split(\" \");\n        int prefix = Integer.parseInt(parts[0]);\n        int middle = Integer.parseInt(parts[1]);\n        int bioCode = Integer.parseInt(parts[2].substring(0, 3));\n        char sexCode = parts[2].charAt(3);\n\n        return prefix >= 1 && prefix <= 1237 &&\n               middle >= 20 && middle <= 460 &&\n               bioCode >= 0 && bioCode <= 100 &&\n               ((sexCode == '0' && bioCode < 100) || (sexCode == '1' && bioCode < 100) || (sexCode == '2'));\n    }\n}\n```"}
{"user_prompt": "请使用java完成一个进度条类ProgressBar以展示工程进度。具体要求如下：1.接受一个参数totalTasks，表示总任务数；2.包含taskCompleted()方法，用于标记任务完成；3.updateProgressBar()方法，用于更新进度条的显示。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请使用java完成一个进度条类ProgressBar以展示工程进度。具体要求如下：1.接受一个参数totalTasks，表示总任务数；2.包含taskCompleted()方法，用于标记任务完成；3.updateProgressBar()方法，用于更新进度条的显示。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ValidPasswordTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@123\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class ValidPasswordTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@123\"));\n    }\n}", "_id": 191, "response": "```java\npublic class ProgressBar {\n    private int totalTasks;\n    private int completedTasks;\n    private int lastPercentage;\n\n    public ProgressBar(int totalTasks) {\n        this.totalTasks = totalTasks;\n        this.completedTasks = 0;\n        this.lastPercentage = 0;\n    }\n\n    public void taskCompleted() {\n        if (completedTasks < totalTasks) {\n            completedTasks++;\n            updateProgressBar();\n        }\n    }\n\n    public void updateProgressBar() {\n        int currentPercentage = (int) ((completedTasks / (double) totalTasks) * 100);\n        if (currentPercentage != lastPercentage) {\n            lastPercentage = currentPercentage;\n            System.out.print(\"\\rProgress: [\");\n            int progressBars = currentPercentage / 2; // Assuming we want 50 characters in total for the progress bar\n            for (int i = 0; i < 50; i++) {\n                if (i < progressBars) {\n                    System.out.print(\"#\");\n                } else {\n                    System.out.print(\" \");\n                }\n            }\n            System.out.print(\"] \" + currentPercentage + \"%\");\n        }\n    }\n}\n```"}
{"user_prompt": "创建一个名为LinearRegressionLoss的java类，编写三个静态方法用于计算线性回归中常用的三种损失函数均方误差，平均绝对误差和Huber损失，并在main方法中手动生成数据，调用这三个方法计算相应的损失，并输出相应的计算结果。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建一个名为LinearRegressionLoss的java类，编写三个静态方法用于计算线性回归中常用的三种损失函数均方误差，平均绝对误差和Huber损失，并在main方法中手动生成数据，调用这三个方法计算相应的损失，并输出相应的计算结果。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass LinearRegressionLossTest {\n\n    @Test\n    public void testCalculateMSE1() {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        assertEquals(0.25, LinearRegressionLoss.calculateMSE(actual, predicted));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class LinearRegressionLossTest {\n\n    @Test\n    public void testCalculateMSE1() {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        assertEquals(0.25, LinearRegressionLoss.calculateMSE(actual, predicted));\n    }\n}", "_id": 192, "response": "```java\npublic class LinearRegressionLoss {\n\n    public static double calculateMSE(double[] actual, double[] predicted) {\n        double sum = 0;\n        for (int i = 0; i < actual.length; i++) {\n            sum += Math.pow(actual[i] - predicted[i], 2);\n        }\n        return sum / actual.length;\n    }\n\n    public static double calculateMAE(double[] actual, double[] predicted) {\n        double sum = 0;\n        for (int i = 0; i < actual.length; i++) {\n            sum += Math.abs(actual[i] - predicted[i]);\n        }\n        return sum / actual.length;\n    }\n\n    public static double calculateHuberLoss(double[] actual, double[] predicted, double delta) {\n        double sum = 0;\n        for (int i = 0; i < actual.length; i++) {\n            double error = actual[i] - predicted[i];\n            if (Math.abs(error) <= delta) {\n                sum += 0.5 * Math.pow(error, 2);\n            } else {\n                sum += delta * (Math.abs(error) - 0.5 * delta);\n            }\n        }\n        return sum / actual.length;\n    }\n\n    public static void main(String[] args) {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        double delta = 1.0;\n\n        double mse = calculateMSE(actual, predicted);\n        double mae = calculateMAE(actual, predicted);\n        double huberLoss = calculateHuberLoss(actual, predicted, delta);\n\n        System.out.println(\"Mean Squared Error (MSE): \" + mse);\n        System.out.println(\"Mean Absolute Error (MAE): \" + mae);\n        System.out.println(\"Huber Loss: \" + huberLoss);\n    }\n}\n```"}
{"user_prompt": "对于java中time包的考察\n编写一个Java程序来计算两个日期之间的间隔。给定两个字符串格式的日期（\"2023-03-15\"和\"2023-04-14\"），计算它们之间的完整天数差。程序应能处理不同年份和闰年。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对于java中time包的考察\n编写一个Java程序来计算两个日期之间的间隔。给定两个字符串格式的日期（\"2023-03-15\"和\"2023-04-14\"），计算它们之间的完整天数差。程序应能处理不同年份和闰年。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass DaysBetweenDatesTest {\n\n    @Test\n    void testCalculateDaysBetweenDates() {\n        assertEquals(30, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-04-14\"));\n        assertEquals(365, DaysBetweenDates.calculateDaysBetweenDates(\"2023-01-01\", \"2024-01-01\"));\n        assertEquals(366, DaysBetweenDates.calculateDaysBetweenDates(\"2024-01-01\", \"2025-01-01\"));\n        assertEquals(0, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-15\"));\n        assertEquals(1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-16\"));\n        assertEquals(-1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-16\", \"2023-03-15\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class DaysBetweenDatesTest {\n\n    @Test\n    void testCalculateDaysBetweenDates() {\n        assertEquals(30, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-04-14\"));\n        assertEquals(365, DaysBetweenDates.calculateDaysBetweenDates(\"2023-01-01\", \"2024-01-01\"));\n        assertEquals(366, DaysBetweenDates.calculateDaysBetweenDates(\"2024-01-01\", \"2025-01-01\"));\n        assertEquals(0, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-15\"));\n        assertEquals(1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-16\"));\n        assertEquals(-1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-16\", \"2023-03-15\"));\n    }\n}", "_id": 193, "response": "```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n\n    public static int calculateDaysBetweenDates(String startDateStr, String endDateStr) {\n        LocalDate startDate = LocalDate.parse(startDateStr);\n        LocalDate endDate = LocalDate.parse(endDateStr);\n        return (int) ChronoUnit.DAYS.between(startDate, endDate);\n    }\n\n    public static void main(String[] args) {\n        // Example usage of the calculateDaysBetweenDates method\n        System.out.println(calculateDaysBetweenDates(\"2023-03-15\", \"2023-04-14\")); // Output: 30\n        System.out.println(calculateDaysBetweenDates(\"2023-01-01\", \"2024-01-01\")); // Output: 365\n        System.out.println(calculateDaysBetweenDates(\"2024-01-01\", \"2025-01-01\")); // Output: 366\n        System.out.println(calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-15\")); // Output: 0\n        System.out.println(calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-16\")); // Output: 1\n        System.out.println(calculateDaysBetweenDates(\"2023-03-16\", \"2023-03-15\")); // Output: -1\n    }\n}\n```"}
{"user_prompt": "手动编写数据，使用java语言编写K均值（K-means）聚类算法。计算输出每个数据样本的结果", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n手动编写数据，使用java语言编写K均值（K-means）聚类算法。计算输出每个数据样本的结果\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass LongestPathTest {\n\n    @Test\n    public void testLengthLongestPath1() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class LongestPathTest {\n\n    @Test\n    public void testLengthLongestPath1() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n}", "_id": 190, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class KMeans {\n    private int k;\n    private int maxIterations;\n    private List<Point> points;\n    private List<Cluster> clusters;\n\n    public KMeans(int k, int maxIterations) {\n        this.k = k;\n        this.maxIterations = maxIterations;\n        this.points = new ArrayList<>();\n        this.clusters = new ArrayList<>();\n    }\n\n    public void addPoint(double x, double y) {\n        points.add(new Point(x, y));\n    }\n\n    public void execute() {\n        // Step 1: Initialize clusters with random centroids\n        initializeClusters();\n\n        // Step 2: Iterate until convergence or max iterations reached\n        int iteration = 0;\n        boolean convergence = false;\n        while (!convergence && iteration < maxIterations) {\n            // Step 2.1: Assign points to the nearest cluster\n            assignClusters();\n\n            // Step 2.2: Recalculate centroids\n            convergence = recalculateCentroids();\n\n            iteration++;\n        }\n    }\n\n    private void initializeClusters() {\n        Random random = new Random();\n        for (int i = 0; i < k; i++) {\n            Point centroid = points.get(random.nextInt(points.size()));\n            Cluster cluster = new Cluster(centroid);\n            clusters.add(cluster);\n        }\n    }\n\n    private void assignClusters() {\n        for (Point point : points) {\n            double minDistance = Double.MAX_VALUE;\n            Cluster closestCluster = null;\n            for (Cluster cluster : clusters) {\n                double distance = point.distance(cluster.getCentroid());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestCluster = cluster;\n                }\n            }\n            if (closestCluster != null) {\n                closestCluster.addPoint(point);\n            }\n        }\n    }\n\n    private boolean recalculateCentroids() {\n        boolean convergence = true;\n        for (Cluster cluster : clusters) {\n            Point oldCentroid = cluster.getCentroid();\n            Point newCentroid = cluster.calculateCentroid();\n            if (!newCentroid.equals(oldCentroid)) {\n                convergence = false;\n            }\n            cluster.setCentroid(newCentroid);\n        }\n        return convergence;\n    }\n\n    public List<Cluster> getClusters() {\n        return clusters;\n    }\n\n    public static class Point {\n        private double x;\n        private double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distance(Point other) {\n            return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            Point point = (Point) obj;\n            return Double.compare(point.x, x) == 0 && Double.compare(point.y, y) == 0;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.2f, %.2f)\", x, y);\n        }\n    }\n\n    public static class Cluster {\n        private List<Point> points;\n        private Point centroid;\n\n        public Cluster(Point centroid) {\n            this.centroid = centroid;\n            this.points = new ArrayList<>();\n        }\n\n        public void addPoint(Point point) {\n            points.add(point);\n        }\n\n        public Point calculateCentroid() {\n            double sumX = 0;\n            double sumY = 0;\n            for (Point point : points) {\n                sumX += point.x;\n                sumY += point.y;\n            }\n            return new Point(sumX / points.size(), sumY / points.size());\n        }\n\n        public Point getCentroid() {\n            return centroid;\n        }\n\n        public void setCentroid(Point centroid) {\n            this.centroid = centroid;\n        }\n\n        public List<Point> getPoints() {\n            return points;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Cluster with centroid %s and points: %s\", centroid, points);\n        }\n    }\n\n    public static void main(String[] args) {\n        KMeans kMeans = new KMeans(3, 100);\n        // Add points manually or generate randomly\n        kMeans.addPoint(1.0, 1.0);\n        kMeans.addPoint(1.5, 2.0);\n        kMeans.addPoint(3.0, 4.0);\n        kMeans.addPoint(5.0, 7.0);\n        kMeans.addPoint(3.5, 5.0);\n        kMeans.addPoint(4.5, 5.0);\n        kMeans.addPoint(3.0, 3.5);\n        kMeans.execute();\n\n        for (Cluster cluster : kMeans.getClusters()) {\n            System.out.println(cluster);\n        }\n    }\n}\n```"}
{"user_prompt": "创建一个名为 GameItem 的类，包含属性：道具名称、类型、数量。分别是String, String, int类型。\n创建一个名为 Inventory 的类，用于管理游戏道具。它应该能够添加道具、删除道具、查找道具，列出道具。\n函数名分别为：addItem(GameItem item)，removeItem(String itemName)，findItem(String itemName)，listItems()\n在main函数中测试GameItem和Inventory类，比如先新建两个gameitem并添加到inventory里面，然后listItems()，然后去寻找其中一个item，使用findItem函数。随后移除一个gameitem，然后再次listItems()。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建一个名为 GameItem 的类，包含属性：道具名称、类型、数量。分别是String, String, int类型。\n创建一个名为 Inventory 的类，用于管理游戏道具。它应该能够添加道具、删除道具、查找道具，列出道具。\n函数名分别为：addItem(GameItem item)，removeItem(String itemName)，findItem(String itemName)，listItems()\n在main函数中测试GameItem和Inventory类，比如先新建两个gameitem并添加到inventory里面，然后listItems()，然后去寻找其中一个item，使用findItem函数。随后移除一个gameitem，然后再次listItems()。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass q10Test {\n\n    @Test\n    public void testGameItemAndInventory() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        assertEquals(2, inventory.items.size());\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        assertNotNull(foundItem);\n        assertEquals(\"Potion\", foundItem.getName());\n\n        inventory.removeItem(\"Sword\");\n        assertEquals(1, inventory.items.size());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class q10Test {\n\n    @Test\n    public void testGameItemAndInventory() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        assertEquals(2, inventory.items.size());\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        assertNotNull(foundItem);\n        assertEquals(\"Potion\", foundItem.getName());\n\n        inventory.removeItem(\"Sword\");\n        assertEquals(1, inventory.items.size());\n    }\n}", "_id": 194, "response": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass GameItem {\n    private String name;\n    private String type;\n    private int quantity;\n\n    public GameItem(String name, String type, int quantity) {\n        this.name = name;\n        this.type = type;\n        this.quantity = quantity;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public int getQuantity() {\n        return quantity;\n    }\n}\n\nclass Inventory {\n    private List<GameItem> items;\n\n    public Inventory() {\n        items = new ArrayList<>();\n    }\n\n    public void addItem(GameItem item) {\n        items.add(item);\n    }\n\n    public void removeItem(String itemName) {\n        items.removeIf(item -> item.getName().equals(itemName));\n    }\n\n    public GameItem findItem(String itemName) {\n        for (GameItem item : items) {\n            if (item.getName().equals(itemName)) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    public void listItems() {\n        for (GameItem item : items) {\n            System.out.println(\"Item: \" + item.getName() + \", Type: \" + item.getType() + \", Quantity: \" + item.getQuantity());\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        System.out.println(\"Listing all items after addition:\");\n        inventory.listItems();\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        if (foundItem != null) {\n            System.out.println(\"Found item: \" + foundItem.getName());\n        }\n\n        inventory.removeItem(\"Sword\");\n        System.out.println(\"Listing all items after removal:\");\n        inventory.listItems();\n    }\n}\n```"}
{"user_prompt": "商店由N个销售区组成，并且销售区由M个干货架组成，货架上面又须要放置P种货物。请你善用继承分别编写商店、销售区、货架和货物的实体类，并利用泛型随机生成货物。货物包含id、名字和价格三个属性。最后首先按照销售区域号排序，区域号相同的按照货架号排序，打印展示货物", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n商店由N个销售区组成，并且销售区由M个干货架组成，货架上面又须要放置P种货物。请你善用继承分别编写商店、销售区、货架和货物的实体类，并利用泛型随机生成货物。货物包含id、名字和价格三个属性。最后首先按照销售区域号排序，区域号相同的按照货架号排序，打印展示货物\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MaxLCMGCDTest {\n\n\n    @Test\n    public void testWithNEqualTo1() {\n        assertEquals(0, MaxLCMGCD.maxLCMMinusGCD(1));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MaxLCMGCDTest {\n\n\n    @Test\n    public void testWithNEqualTo1() {\n        assertEquals(0, MaxLCMGCD.maxLCMMinusGCD(1));\n    }\n}", "_id": 195, "response": "```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n// Base class for all entities in the store\nabstract class StoreEntity {\n    protected int id;\n\n    public StoreEntity(int id) {\n        this.id = id;\n    }\n\n    public int getId() {\n        return id;\n    }\n}\n\n// SalesArea entity\nclass SalesArea extends StoreEntity {\n    private List<Shelf<?>> shelves;\n\n    public SalesArea(int id) {\n        super(id);\n        shelves = new ArrayList<>();\n    }\n\n    public void addShelf(Shelf<?> shelf) {\n        shelves.add(shelf);\n    }\n\n    public List<Shelf<?>> getShelves() {\n        return shelves;\n    }\n}\n\n// Shelf entity\nclass Shelf<T extends Product> extends StoreEntity {\n    private List<T> products;\n\n    public Shelf(int id) {\n        super(id);\n        products = new ArrayList<>();\n    }\n\n    public void addProduct(T product) {\n        products.add(product);\n    }\n\n    public List<T> getProducts() {\n        return products;\n    }\n}\n\n// Product entity\nclass Product {\n    private int id;\n    private String name;\n    private double price;\n\n    public Product(int id, String name, double price) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Product{id=%d, name='%s', price=%.2f}\", id, name, price);\n    }\n}\n\n// Store entity\nclass Store {\n    private List<SalesArea> salesAreas;\n\n    public Store() {\n        salesAreas = new ArrayList<>();\n    }\n\n    public void addSalesArea(SalesArea salesArea) {\n        salesAreas.add(salesArea);\n    }\n\n    public List<SalesArea> getSalesAreas() {\n        return salesAreas;\n    }\n\n    public void displayProducts() {\n        // Sort sales areas by id\n        Collections.sort(salesAreas, (a1, a2) -> Integer.compare(a1.getId(), a2.getId()));\n\n        for (SalesArea area : salesAreas) {\n            // Sort shelves by id within each sales area\n            Collections.sort(area.getShelves(), (s1, s2) -> Integer.compare(s1.getId(), s2.getId()));\n\n            for (Shelf<?> shelf : area.getShelves()) {\n                for (Product product : shelf.getProducts()) {\n                    System.out.println(product);\n                }\n            }\n        }\n    }\n}\n\n// Main class to demonstrate functionality\npublic class StoreDemo {\n    public static void main(String[] args) {\n        Store store = new Store();\n        Random random = new Random();\n\n        // Create sales areas, shelves, and products\n        for (int i = 1; i <= 3; i++) { // Assuming 3 sales areas\n            SalesArea salesArea = new SalesArea(i);\n            for (int j = 1; j <= 2; j++) { // Assuming 2 shelves per sales area\n                Shelf<Product> shelf = new Shelf<>(j);\n                for (int k = 1; k <= 5; k++) { // Assuming 5 products per shelf\n                    int productId = i * 100 + j * 10 + k;\n                    Product product = new Product(productId, \"Product\" + productId, random.nextDouble() * 100);\n                    shelf.addProduct(product);\n                }\n                salesArea.addShelf(shelf);\n            }\n            store.addSalesArea(salesArea);\n        }\n\n        // Display products sorted by sales area and shelf\n        store.displayProducts();\n    }\n}\n```"}
{"user_prompt": "模拟报文的发送端和接收端，在接收到发送端的传输报文后，进行哈夫曼编码压缩，形成编码后报文并发送出去，然后再接收端进行解码，还原内容并打印显示出报文内容", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n模拟报文的发送端和接收端，在接收到发送端的传输报文后，进行哈夫曼编码压缩，形成编码后报文并发送出去，然后再接收端进行解码，还原内容并打印显示出报文内容\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass HuffmanTest {\n\n    @Test\n    void testEncodeAndDecode1() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"hello world\");\n        assertEquals(\"hello world\", huffman.recv());\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class HuffmanTest {\n\n    @Test\n    void testEncodeAndDecode1() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"hello world\");\n        assertEquals(\"hello world\", huffman.recv());\n    }\n}", "_id": 196, "response": "```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\npublic class Huffman {\n\n    private static class Node {\n        char ch;\n        int freq;\n        Node left = null, right = null;\n\n        Node(char ch, int freq) {\n            this.ch = ch;\n            this.freq = freq;\n        }\n\n        Node(Node left, Node right) {\n            this.freq = left.freq + right.freq;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    private Node root;\n    private Map<Character, String> charToCodeMap;\n    private Map<String, Character> codeToCharMap;\n\n    public Huffman() {\n        this.charToCodeMap = new HashMap<>();\n        this.codeToCharMap = new HashMap<>();\n    }\n\n    public void send(String message) {\n        if (message == null || message.isEmpty()) {\n            return;\n        }\n        buildHuffmanTree(message);\n        encodeMessage(message);\n    }\n\n    public String recv() {\n        StringBuilder decodedMessage = new StringBuilder();\n        Node current = root;\n        for (char code : encodedMessage.toCharArray()) {\n            current = code == '0' ? current.left : current.right;\n            if (current.left == null && current.right == null) {\n                decodedMessage.append(current.ch);\n                current = root;\n            }\n        }\n        return decodedMessage.toString();\n    }\n\n    private void buildHuffmanTree(String message) {\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char ch : message.toCharArray()) {\n            freqMap.put(ch, freqMap.getOrDefault(ch, 0) + 1);\n        }\n\n        PriorityQueue<Node> pq = new PriorityQueue<>((l, r) -> l.freq - r.freq);\n        for (Map.Entry<Character, Integer> entry : freqMap.entrySet()) {\n            pq.add(new Node(entry.getKey(), entry.getValue()));\n        }\n\n        while (pq.size() > 1) {\n            Node left = pq.poll();\n            Node right = pq.poll();\n            pq.add(new Node(left, right));\n        }\n\n        root = pq.peek();\n        buildCodeMap(root, \"\");\n    }\n\n    private void buildCodeMap(Node node, String str) {\n        if (node != null) {\n            if (node.left == null && node.right == null) {\n                charToCodeMap.put(node.ch, str);\n                codeToCharMap.put(str, node.ch);\n            } else {\n                buildCodeMap(node.left, str + \"0\");\n                buildCodeMap(node.right, str + \"1\");\n            }\n        }\n    }\n\n    private String encodedMessage;\n\n    private void encodeMessage(String message) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : message.toCharArray()) {\n            sb.append(charToCodeMap.get(ch));\n        }\n        encodedMessage = sb.toString();\n    }\n}\n```"}
{"user_prompt": "编写一个 Java 函数，使用正则表达式来验证一个字符串是否是有效的电子邮件地址。电子邮件地址的一般格式为 username@domain.com。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个 Java 函数，使用正则表达式来验证一个字符串是否是有效的电子邮件地址。电子邮件地址的一般格式为 username@domain.com。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ValidEmailTest {\n\n    @Test\n    void testIsValidEmail1() {\n        assertTrue(ValidEmail.isValidEmail(\"example@example.com\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class ValidEmailTest {\n\n    @Test\n    void testIsValidEmail1() {\n        assertTrue(ValidEmail.isValidEmail(\"example@example.com\"));\n    }\n}", "_id": 197, "response": "```java\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class ValidEmail {\n\n    public static boolean isValidEmail(String email) {\n        String emailRegex = \"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\";\n        Pattern pattern = Pattern.compile(emailRegex);\n        Matcher matcher = pattern.matcher(email);\n        return matcher.matches();\n    }\n}\n```"}
{"user_prompt": "异常检测的问题：考察对Exception的重写。\n创建一个简单的银行账户类 BankAccount，其中包含一个处理取款操作的方法。这个方法应该能够检测和抛出异常，比如当账户余额不足时。\n\n创建一个名为BankAccount的类，包含属性：账户余额。\n在BankAccount类中，实现一个withdraw方法，该方法接受一个取款金额参数。\n如果取款金额大于账户余额，方法应抛出一个自定义的异常 InsufficientFundsException。\n在 main 函数中，创建一个 BankAccount 对象，先往里面存500，然后取600，看看是否会调用到实现好的InsufficientFundsException并打印其报错信息。", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n异常检测的问题：考察对Exception的重写。\n创建一个简单的银行账户类 BankAccount，其中包含一个处理取款操作的方法。这个方法应该能够检测和抛出异常，比如当账户余额不足时。\n\n创建一个名为BankAccount的类，包含属性：账户余额。\n在BankAccount类中，实现一个withdraw方法，该方法接受一个取款金额参数。\n如果取款金额大于账户余额，方法应抛出一个自定义的异常 InsufficientFundsException。\n在 main 函数中，创建一个 BankAccount 对象，先往里面存500，然后取600，看看是否会调用到实现好的InsufficientFundsException并打印其报错信息。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass q13Test {\n\n        @Test\n        void testWithdraw1() {\n            BankAccount account = new BankAccount(500.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(600.0));\n        }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class q13Test {\n\n        @Test\n        void testWithdraw1() {\n            BankAccount account = new BankAccount(500.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(600.0));\n        }\n}", "_id": 198, "response": "```java\nclass BankAccount {\n    private double balance;\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public void deposit(double amount) {\n        balance += amount;\n    }\n\n    public void withdraw(double amount) throws InsufficientFundsException {\n        if (amount > balance) {\n            throw new InsufficientFundsException(\"Insufficient funds for withdrawal\");\n        }\n        balance -= amount;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n}\n\nclass InsufficientFundsException extends Exception {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount(500.0);\n        try {\n            account.withdraw(600.0);\n        } catch (InsufficientFundsException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```"}
{"user_prompt": "Java中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "_id": 200, "response": "```java\npublic class StringUtils {\n\n    public static String alternateCase(String input) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (i % 2 == 0) {\n                result.append(Character.toUpperCase(c));\n            } else {\n                result.append(Character.toLowerCase(c));\n            }\n        }\n        return result.toString();\n    }\n\n    // Main method for testing purposes\n    public static void main(String[] args) {\n        System.out.println(alternateCase(\"legendary\")); // Should print \"LeGeNdArY\"\n    }\n}\n```"}
{"user_prompt": "请使用StringBuilder和StringBuffer，创建一个简单的Markdown解析器，它能够将特定的Markdown语法转换为HTML。你的任务是处理以下Markdown特性：\n\n# 开头的行转换为 <h1> 标签。\n## 开头的行转换为 <h2> 标签。\n* 开头的行（后跟空格）转换为 <li> 标签（列表项）。\n文本行（不符合上述情况）转换为 <p> 标签。\n注意，Markdown语法规定，每个标记（如#，##，*）后必须紧跟一个空格。\n\n输入：\n# Header 1\nThis is a paragraph.\n## Header 2\n* List item 1\n* List item 2\n\n输出：\n<h1>Header 1</h1>\n<p>This is a paragraph.</p>\n<h2>Header 2</h2>\n<ul>\n<li>List item 1</li>\n<li>List item 2</li>\n</ul>", "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请使用StringBuilder和StringBuffer，创建一个简单的Markdown解析器，它能够将特定的Markdown语法转换为HTML。你的任务是处理以下Markdown特性：\n\n# 开头的行转换为 <h1> 标签。\n## 开头的行转换为 <h2> 标签。\n* 开头的行（后跟空格）转换为 <li> 标签（列表项）。\n文本行（不符合上述情况）转换为 <p> 标签。\n注意，Markdown语法规定，每个标记（如#，##，*）后必须紧跟一个空格。\n\n输入：\n# Header 1\nThis is a paragraph.\n## Header 2\n* List item 1\n* List item 2\n\n输出：\n<h1>Header 1</h1>\n<p>This is a paragraph.</p>\n<h2>Header 2</h2>\n<ul>\n<li>List item 1</li>\n<li>List item 2</li>\n</ul>\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MarkdownToHTMLTest {\n\n    @Test\n    void testParseMarkdown1() {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\";\n        String expected = \"<h1>Header 1</h1>\\n<p>This is a paragraph.</p>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n}", "template": "你的任务是生成{language}代码来解决以下问题，生成的代码必须位于代码块```{language}和```之间，最多只允许有一个代码块：\n{prompt}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\n{test_demo}", "test_demo": "class MarkdownToHTMLTest {\n\n    @Test\n    void testParseMarkdown1() {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\";\n        String expected = \"<h1>Header 1</h1>\\n<p>This is a paragraph.</p>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n}", "_id": 199, "response": "```java\npublic class MarkdownToHTML {\n\n    public static String parseMarkdown(String markdown) {\n        StringBuilder html = new StringBuilder();\n        StringBuffer listBuffer = new StringBuffer();\n        boolean inList = false;\n\n        String[] lines = markdown.split(\"\\n\");\n        for (String line : lines) {\n            if (line.startsWith(\"# \")) {\n                html.append(\"<h1>\").append(line.substring(2)).append(\"</h1>\\n\");\n            } else if (line.startsWith(\"## \")) {\n                html.append(\"<h2>\").append(line.substring(3)).append(\"</h2>\\n\");\n            } else if (line.startsWith(\"* \")) {\n                if (!inList) {\n                    inList = true;\n                    listBuffer.append(\"<ul>\\n\");\n                }\n                listBuffer.append(\"<li>\").append(line.substring(2)).append(\"</li>\\n\");\n            } else {\n                if (inList) {\n                    listBuffer.append(\"</ul>\\n\");\n                    html.append(listBuffer.toString());\n                    listBuffer.setLength(0); // Clear the buffer\n                    inList = false;\n                }\n                html.append(\"<p>\").append(line).append(\"</p>\\n\");\n            }\n        }\n\n        if (inList) {\n            listBuffer.append(\"</ul>\\n\");\n            html.append(listBuffer.toString());\n        }\n\n        return html.toString();\n    }\n}\n```"}
